<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- é˜²æ­¢ç€è¦½å™¨å¿«å– -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>æ•¸ä½æ·±æ·µ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Noto Sans TC', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei", Roboto, Arial, sans-serif;
            background: linear-gradient(180deg, #0a0e1a 0%, #1a1f35 100%);
            color: #e0e6ff;
            line-height: 1.6;
            min-height: 100vh;
            background-attachment: fixed;
            overflow-x: hidden;
            /* é‡å°æ‰‹æ©Ÿå…¨è¢å¹•å„ªåŒ– */
            display: flex;
            flex-direction: column;
        }
        
        .container { 
            max-width: 1600px; 
            margin: 0 auto; 
            padding: 15px; 
            /* è®“ container ä½”æ»¿å‰©é¤˜é«˜åº¦ */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        
        h1 { 
            font-family: inherit; 
            color: #00d9ff; 
            text-align: center;
            font-size: clamp(1.8rem, 6vw, 3rem); 
            margin: 25px 0;
            text-shadow: 0 0 25px rgba(0, 217, 255, 1), 0 0 50px rgba(0, 217, 255, 0.6), 0 0 75px rgba(0, 217, 255, 0.3);
            letter-spacing: 6px; 
            font-weight: 900;
        }
        
        .subtitle { 
            text-align: center; 
            color: #7a8fb8; 
            font-size: clamp(0.9rem, 2.2vw, 1.1rem); 
            margin-bottom: 25px; 
            font-style: italic;
            font-weight: 500; 
        }
        
        .game-layout { 
            display: grid; 
            grid-template-columns: 1fr; 
            gap: 15px; 
            /* è®“ game-layout ä½”æ»¿ container å‰©é¤˜é«˜åº¦ */
            flex-grow: 1;
        }
        
        /* æ‰‹æ©Ÿç›´å¼ä½ˆå±€å„ªåŒ–ï¼šå°‡ä¸‰å€‹é¢æ¿å †ç–Šï¼Œä¸¦è®“ä¸­é–“æ—¥èªŒå€åŸŸä½”æ»¿å‰©é¤˜ç©ºé–“ */
        @media (max-width: 767px) {
            .game-layout {
                grid-template-columns: 1fr; /* å–®æ¬„ä½ˆå±€ */
                /* ç¢ºä¿æ•´å€‹ä½ˆå±€ä½”æ»¿å‰©é¤˜ç©ºé–“ï¼Œä¸¦æ§åˆ¶æ»¾å‹• */
                height: 100%; 
                overflow-y: auto; /* å…è¨±æ•´é«”æ»¾å‹• */
                /* ç§»é™¤ grid-template-rowsï¼Œè®“å…§å®¹è‡ªç„¶å †ç–Š */
            }
            .panel {
                /* ç¢ºä¿æ‰‹æ©Ÿæ¨¡å¼ä¸‹çš„é¢æ¿ä¸æœƒè¢«é™åˆ¶é«˜åº¦ */
                min-height: auto;
            }
            .log-container {
                /* è®“æ—¥èªŒå€åŸŸä½”æ»¿å‰©é¤˜é«˜åº¦ */
                height: 25vh; /* è¨­ç½®ä¸€å€‹å›ºå®šé«˜åº¦ï¼Œç¢ºä¿æ—¥èªŒå¯è¦‹ */
                flex-grow: 0; /* ç§»é™¤ flex-grow é¿å…éåº¦æ‹‰ä¼¸ */
            }
            .panel:nth-child(2) { /* ä¸­é–“é¢æ¿ï¼šæˆ°é¬¥æ—¥èªŒ */
                display: block; /* æ¢å¾© block é¿å… flex è¡çª */
                min-height: auto;
            }
            /* èª¿æ•´ container padding æ¸›å°‘ç©ºé–“æµªè²» */
            .container {
                padding: 10px;
            }
        }
        
        @media (min-width: 768px) { 
            .game-layout { 
                grid-template-columns: 350px 1fr; /* æ”¹ç‚ºå…©æ¬„ä½ˆå±€ */
                grid-template-rows: 1fr; /* æ©«å‘ä½ˆå±€ */
            } 
            .container { 
                padding: 20px; 
            } 
        }
        
        @media (min-width: 1200px) { 
            .game-layout { 
                grid-template-columns: 400px 1fr; /* å¯¬è¢å¹•ä¹Ÿæ˜¯å…©æ¬„ */
            } 
        }
        
        .panel { 
            background: linear-gradient(135deg, rgba(26, 31, 53, 0.98) 0%, rgba(15, 20, 40, 0.98) 100%);
            border: 3px solid #00d9ff; 
            border-radius: 15px; 
            padding: 25px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.4), inset 0 0 40px rgba(0, 217, 255, 0.08), 0 5px 20px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .panel::before {
            content: ''; 
            position: absolute; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0;
            border-radius: 10px; 
            background: radial-gradient(circle at top left, rgba(0, 217, 255, 0.1), transparent 50%);
            pointer-events: none;
        }
        
        h2 {
            font-family: inherit; 
            color: #00d9ff; 
            font-size: clamp(1.2rem, 2.8vw, 1.5rem);
            margin-bottom: 18px; 
            padding-bottom: 12px; 
            border-bottom: 3px solid #00d9ff;
            text-shadow: 0 0 15px rgba(0, 217, 255, 0.7), 0 0 30px rgba(0, 217, 255, 0.3); 
            font-weight: 700;
            letter-spacing: 1px;
        }
        
        .stats-grid { 
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px; 
            margin-bottom: 15px; 
        }
        
        /* ç§»å‹•ç«¯å–®åˆ—å¸ƒå±€ */
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .stat-item { 
            background: rgba(0, 217, 255, 0.08); 
            padding: 12px; 
            border-radius: 10px;
            border: 2px solid rgba(0, 217, 255, 0.4); 
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0, 217, 255, 0.1);
        }
        
        .stat-item:hover { 
            border-color: #00d9ff; 
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.3); 
        }
        
        .stat-label { 
            font-size: 0.75rem; 
            color: #7a8fb8; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            font-weight: 600; 
        }
        
        .stat-value { 
            font-size: clamp(1.3rem, 3vw, 1.6rem); 
            font-weight: bold; 
            color: #00d9ff; 
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5); 
        }
        
        .resources { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 8px; 
            margin-bottom: 15px; 
        }
        
        .resource { 
            background: rgba(0, 217, 255, 0.08); 
            padding: 12px 16px; 
            border-radius: 10px;
            border: 2px solid rgba(0, 217, 255, 0.4); 
            font-size: clamp(0.9rem, 2.2vw, 1rem);
            flex: 1; 
            min-width: 100px; 
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 217, 255, 0.15);
            transition: all 0.3s;
        }
        
        .resource:hover {
            border-color: #00d9ff;
            box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .log-container { 
            height: 400px; /* æ¡Œé¢é è¨­é«˜åº¦ */
            overflow-y: auto; 
            background: rgba(0, 0, 0, 0.5);
            padding: 15px; 
            border-radius: 8px; 
            border: 1px solid rgba(0, 217, 255, 0.3);
        }
        
        @media (max-width: 767px) {
            .log-container {
                height: 25vh; /* æ‰‹æ©Ÿä¸Šä½¿ç”¨è¦–çª—é«˜åº¦æ¯”ä¾‹ */
                flex-grow: 0;
                min-height: 150px;
            }
        }
        
        @media (min-width: 768px) { 
            .log-container { 
                height: 600px; 
            } 
        }
        
        .log-container::-webkit-scrollbar { width: 8px; }
        .log-container::-webkit-scrollbar-track { background: #0a0e1a; }
        .log-container::-webkit-scrollbar-thumb { background: #00d9ff; border-radius: 4px; }
        .log-container::-webkit-scrollbar-thumb:hover { background: #00ffff; }
        
        .log-entry { 
            margin-bottom: 12px; 
            padding: 14px; 
            background: rgba(0, 217, 255, 0.08);
            border-left: 4px solid #00d9ff; 
            border-radius: 6px; 
            animation: fadeIn 0.3s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }
        
        .log-entry:hover {
            background: rgba(0, 217, 255, 0.12);
            border-left-color: #00ffff;
            box-shadow: 0 3px 10px rgba(0, 217, 255, 0.2);
        }
        
        @keyframes fadeIn { 
            from { 
                opacity: 0; 
                transform: translateY(-10px); 
            } 
            to { 
                opacity: 1; 
                transform: translateY(0); 
            } 
        }
        
        .log-time { 
            color: #7a8fb8; 
            font-size: 0.7rem; 
            font-family: monospace; 
        }
        
        .log-text { 
            margin-top: 6px; 
            font-size: clamp(0.85rem, 2.2vw, 0.95rem);
            line-height: 1.5; 
        }
        
        .controls { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); 
            gap: 8px; 
            margin-top: 15px; 
        }
        
        button { 
            background: linear-gradient(135deg, #00d9ff 0%, #0099cc 100%);
            color: #0a0e1a; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 10px;
            cursor: pointer; 
            font-weight: bold; 
            font-family: inherit;
            font-size: clamp(0.9rem, 2.2vw, 1.05rem); 
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.5); 
            position: relative; 
            overflow: hidden;
            border: 2px solid rgba(0, 217, 255, 0.3);
        }
        
        button::before {
            content: ''; 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            width: 0; 
            height: 0;
            border-radius: 50%; 
            background: rgba(255,255,255,0.4);
            transform: translate(-50%, -50%); 
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before { 
            width: 300px; 
            height: 300px; 
        }
        
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 0 25px rgba(0, 217, 255, 0.8); 
        }
        
        button:active { 
            transform: translateY(0); 
        }
        
        button:disabled { 
            background: linear-gradient(135deg, #2a3550 0%, #1a2035 100%);
            cursor: not-allowed; 
            color: #5a6b8f; 
            box-shadow: none;
        }
        
        .modal { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: rgba(0,0,0,0.95); 
            align-items: center; 
            justify-content: center;
            z-index: 1000; 
            padding: 20px;
        }
        
        .modal.active { 
            display: flex; 
        }
        
        .modal-content { 
            background: linear-gradient(135deg, rgba(26, 31, 53, 0.98) 0%, rgba(15, 20, 40, 0.98) 100%);
            padding: 25px; 
            border-radius: 12px; 
            max-width: 600px; 
            width: 100%;
            max-height: 80vh; 
            overflow-y: auto; 
            border: 3px solid #00d9ff;
            box-shadow: 0 0 50px rgba(0, 217, 255, 0.6);
        }
        
        .hp-bar { 
            width: 100%; 
            height: 24px; 
            background: rgba(0, 0, 0, 0.6);
            border-radius: 12px; 
            overflow: hidden; 
            margin-top: 8px; 
            border: 2px solid rgba(0, 217, 255, 0.4);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .hp-fill { 
            height: 100%; 
            background: linear-gradient(90deg, #ff3366 0%, #00d9ff 50%, #00ff88 100%);
            transition: width 0.5s ease; 
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }
        
        .equipment-slot {
            background: rgba(0, 217, 255, 0.08); 
            border: 2px dashed rgba(0, 217, 255, 0.4);
            border-radius: 10px; 
            padding: 14px; 
            margin-bottom: 12px;
            cursor: pointer; 
            transition: all 0.3s;
            min-height: 65px;
            box-shadow: 0 2px 6px rgba(0, 217, 255, 0.1);
        }
        
        .equipment-slot:hover { 
            border-color: #00d9ff; 
            background: rgba(0, 217, 255, 0.1); 
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.3); 
        }
        
        .equipment-slot.equipped { 
            border-style: solid; 
            border-color: #00d9ff; 
            background: rgba(0, 217, 255, 0.1); 
        }
        
        .equipment-slot.set-bonus {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5), inset 0 0 15px rgba(0, 255, 136, 0.2);
            animation: setGlow 2s ease-in-out infinite;
        }
        
        @keyframes setGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5), inset 0 0 15px rgba(0, 255, 136, 0.2); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.8), inset 0 0 20px rgba(0, 255, 136, 0.3); }
        }
        
        .equipment-name { 
            font-weight: bold; 
            color: #00d9ff; 
            margin-bottom: 5px; 
        }
        
        .equipment-stats { 
            font-size: 0.8rem; 
            color: #7a8fb8; 
        }
        
        .rarity-common { color: #E6E6E6; }
        .rarity-rare { color: #4EA5FF; }
        .rarity-epic { color: #B388FF; }
        .rarity-mythic { color: #FF9F43; }
        
        @media (max-width: 767px) {
            .panel { padding: 15px; }
            h2 { font-size: 1.1rem; }
            .game-layout { grid-template-columns: 1fr; }
        }
        
        /* å¤©è³¦ç³»çµ±æ¨£å¼ */
        .talent-tab {
            background: rgba(78, 165, 255, 0.1);
            border: 1px solid rgba(78, 165, 255, 0.3);
            color: #4EA5FF;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .talent-tab:hover {
            background: rgba(78, 165, 255, 0.2);
            border-color: rgba(78, 165, 255, 0.5);
        }
        
        .talent-tab.active {
            background: linear-gradient(135deg, #4EA5FF 0%, #00d9ff 100%);
            border-color: #4EA5FF;
            color: #000;
            font-weight: bold;
        }
        
        .talent-card {
            background: rgba(78, 165, 255, 0.05);
            border: 1px solid rgba(78, 165, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        
        .talent-card:hover {
            background: rgba(78, 165, 255, 0.1);
            border-color: rgba(78, 165, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .talent-card.max-level {
            background: rgba(255, 215, 0, 0.05);
            border-color: rgba(255, 215, 0, 0.3);
        }
        
        .talent-upgrade-btn {
            background: linear-gradient(135deg, #4EA5FF 0%, #00d9ff 100%);
            border: none;
            color: #000;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .talent-upgrade-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(78, 165, 255, 0.5);
        }
        
        .talent-upgrade-btn:disabled {
            background: rgba(128, 128, 128, 0.3);
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* æ¯æ—¥ä»»å‹™æ¨£å¼ */
        .quest-card {
            background: linear-gradient(135deg, rgba(78, 165, 255, 0.08) 0%, rgba(0, 217, 255, 0.05) 100%);
            border: 2px solid rgba(78, 165, 255, 0.4);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .quest-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #4EA5FF 0%, #00d9ff 100%);
        }
        
        .quest-card:hover {
            background: linear-gradient(135deg, rgba(78, 165, 255, 0.12) 0%, rgba(0, 217, 255, 0.08) 100%);
            border-color: rgba(78, 165, 255, 0.6);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3);
        }
        
        .quest-card.completed {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.08) 0%, rgba(0, 204, 102, 0.05) 100%);
            border-color: rgba(0, 255, 136, 0.4);
            opacity: 0.8;
        }
        
        .quest-card.completed::before {
            background: linear-gradient(180deg, #00ff88 0%, #00cc66 100%);
        }
        
        .quest-progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin: 8px 0;
        }
        
        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4EA5FF 0%, #00d9ff 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: bold;
            color: #000;
        }
        
        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-left: 8px;
        }
        
        .quest-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #00d9ff;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }
        
        .quest-difficulty {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .quest-difficulty.easy {
            background: linear-gradient(135deg, rgba(0, 255, 0, 0.2) 0%, rgba(0, 200, 0, 0.1) 100%);
            color: #00ff00;
            border: 1px solid rgba(0, 255, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }
        
        .quest-difficulty.normal {
            background: linear-gradient(135deg, rgba(78, 165, 255, 0.2) 0%, rgba(0, 217, 255, 0.1) 100%);
            color: #4EA5FF;
            border: 1px solid rgba(78, 165, 255, 0.5);
            box-shadow: 0 0 10px rgba(78, 165, 255, 0.3);
        }
        
        .quest-difficulty.hard {
            background: linear-gradient(135deg, rgba(255, 0, 255, 0.2) 0%, rgba(200, 0, 200, 0.1) 100%);
            color: #ff00ff;
            border: 1px solid rgba(255, 0, 255, 0.5);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.3);
        }
        
        .quest-desc {
            color: #7a8fb8;
            font-size: 0.9rem;
            margin-bottom: 8px;
            padding-left: 8px;
            line-height: 1.4;
        }
        
        .quest-rewards {
            display: flex;
            gap: 12px;
            margin: 8px 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }
        
        .quest-rewards span {
            color: #00ff88;
            font-weight: bold;
            font-size: 0.95rem;
        }
        
        .quest-completed-badge {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2) 0%, rgba(0, 204, 102, 0.1) 100%);
            color: #00ff88;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-weight: bold;
            border: 1px solid rgba(0, 255, 136, 0.5);
        }
        
        /* ç¨±è™Ÿç³»çµ±æ¨£å¼ */
        .title-category-tab {
            background: rgba(78, 165, 255, 0.1);
            border: 1px solid rgba(78, 165, 255, 0.3);
            color: #4EA5FF;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9rem;
        }
        
        .title-category-tab:hover {
            background: rgba(78, 165, 255, 0.2);
            border-color: rgba(78, 165, 255, 0.5);
        }
        
        .title-category-tab.active {
            background: linear-gradient(135deg, #4EA5FF 0%, #00d9ff 100%);
            border-color: #4EA5FF;
            color: #000;
            font-weight: bold;
        }
        
        .title-card {
            background: rgba(78, 165, 255, 0.05);
            border: 2px solid rgba(78, 165, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            transition: all 0.3s;
            cursor: pointer;
            text-align: center;
        }
        
        .title-card:hover {
            background: rgba(78, 165, 255, 0.1);
            border-color: rgba(78, 165, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .title-card.locked {
            background: rgba(128, 128, 128, 0.05);
            border-color: rgba(128, 128, 128, 0.3);
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .title-card.locked:hover {
            transform: none;
        }
        
        .title-card.equipped {
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.6);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
        }
        
        .title-rarity-common { border-color: rgba(200, 200, 200, 0.5); }
        .title-rarity-rare { border-color: rgba(78, 165, 255, 0.6); }
        .title-rarity-epic { border-color: rgba(163, 53, 238, 0.6); }
        .title-rarity-legendary { border-color: rgba(255, 215, 0, 0.8); }
        
        .title-name {
            font-weight: bold;
            font-size: 1rem;
            margin-bottom: 5px;
        }
        
        .title-rarity-common .title-name { color: #c8c8c8; }
        .title-rarity-rare .title-name { color: #4EA5FF; }
        .title-rarity-epic .title-name { color: #a335ee; }
        .title-rarity-legendary .title-name { color: #FFD700; }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¸»é¸å–® -->
        <div id="start-screen" style="text-align: center; padding: 50px 20px;">
            <h1 style="font-size: clamp(2rem, 6vw, 3rem); margin-bottom: 20px;">âš¡ æ•¸ä½æ·±æ·µ âš¡</h1>
            <div class="subtitle" style="font-size: 1.2rem; margin-bottom: 50px;">ã€Œæ¢ç´¢æ•¸æ“šæµ·æ´‹æ·±è™•ï¼Œæ­é–‹æ·±æ·µçš„ç§˜å¯†ã€</div>
            <div class="panel" style="max-width: 500px; margin: 0 auto;">
                <h2>ğŸ® ä¸»é¸å–®</h2>
                <div style="display: flex; flex-direction: column; gap: 15px; margin-top: 30px;">
                    <button id="new-game-btn" style="width: 100%; padding: 20px; font-size: 1.2rem;">ğŸ†• é–‹å§‹æ–°éŠæˆ²</button>
                    <button id="load-game-btn" style="width: 100%; padding: 20px; font-size: 1.2rem;">ğŸ’¾ è®€å–å­˜æª”</button>
                    <button id="how-to-play-btn" style="width: 100%; padding: 20px; font-size: 1.2rem;">â“ å¦‚ä½•éŠç©</button>
                </div>
            </div>
        </div>

        <!-- è§’è‰²å‰µå»º -->
        <div id="character-creation" style="display:none;">
            <h1>âš¡ è§’è‰²å‰µå»º âš¡</h1>
            <div class="panel" style="max-width: 800px; margin: 30px auto;">
                <h2>ğŸ“ è¼¸å…¥è§’è‰²åç¨±</h2>
                <input type="text" id="character-name" placeholder="è«‹è¼¸å…¥ä½ çš„åå­—" maxlength="12" style="
                    width: 100%; padding: 15px; font-size: 1.1rem; border-radius: 8px;
                    border: 2px solid #00d9ff; background: rgba(0, 217, 255, 0.05);
                    color: #e0e6ff; font-family: inherit; margin-top: 15px;
                ">
                
                <h2 style="margin-top: 30px;">ğŸ¯ é¸æ“‡è·æ¥­</h2>
                <div id="class-selection" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 20px; max-height: none; overflow: visible;">
                    <!-- è·æ¥­å¡ç‰‡å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
                
                <button id="confirm-character-btn" style="width: 100%; margin-top: 30px; padding: 15px; font-size: 1.1rem;">âœ… é–‹å§‹å†’éšª</button>
                <button id="back-to-menu-btn" style="width: 100%; margin-top: 10px; padding: 12px; background: linear-gradient(135deg, #5a6b8f 0%, #3a4b6f 100%);">â† è¿”å›ä¸»é¸å–®</button>
            </div>
        </div>


        <!-- æŠ€èƒ½é¸æ“‡ -->
        <div id="skill-selection" style="display:none;">
            <h1>âš¡ æŠ€èƒ½é¸æ“‡ âš¡</h1>
            <div class="panel" style="max-width: 900px; margin: 30px auto;">
                <h2>ğŸ¯ é¸æ“‡ä½ çš„å°ˆå±¬æŠ€èƒ½</h2>
                <p style="color: #7a8fb8; text-align: center; margin: 15px 0;">å¾ä»¥ä¸‹10å€‹æŠ€èƒ½ä¸­é¸æ“‡1å€‹ä½œç‚ºä½ çš„å°ˆå±¬æŠ€èƒ½</p>
                
                <div id="skill-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-top: 30px;">
                    <!-- æŠ€èƒ½å¡ç‰‡å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
                
                <button id="confirm-skill-btn" style="width: 100%; margin-top: 30px; padding: 15px; font-size: 1.1rem;">âœ… ç¢ºèªé¸æ“‡</button>
            </div>
        </div>
        <!-- éŠæˆ²ä¸»ä»‹é¢ -->
        <div id="game-main" style="display:none;">
            <h1 id="game-title">âš¡ æ•¸ä½æ·±æ·µ âš¡</h1>
            <div class="subtitle" id="game-subtitle">ã€Œç³»çµ±å•Ÿå‹•ä¸­...ã€</div>
            
            <div class="game-layout">
                <!-- å·¦å´é¢æ¿ï¼šè§’è‰²ç‹€æ…‹ -->
                <div class="panel" style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.03) 0%, rgba(78, 165, 255, 0.03) 100%); border: 2px solid rgba(0, 217, 255, 0.2);">
                    <h2 style="background: linear-gradient(135deg, #00d9ff 0%, #4EA5FF 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.2rem; margin-bottom: 15px;">ğŸ‘¤ è§’è‰²ç‹€æ…‹</h2>
                    
                    <!-- è§’è‰²è³‡è¨Šå¡ç‰‡ -->
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                        <!-- ç­‰ç´š + è§’è‰²å -->
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
                            <div style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); padding: 5px 12px; border-radius: 8px; font-size: 1.1rem; font-weight: bold; color: #000; text-shadow: none; box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);">
                                Lv.<span id="player-level">1</span>
                            </div>
                            <div style="font-size: 1.4rem; font-weight: bold; color: #00d9ff; text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);" id="player-name">å·¥ç¨‹å¸«</div>
                        </div>
                        <div style="font-size: 0.9rem; color: #7a8fb8; text-align: center; margin-bottom: 10px;" id="player-class">ç³»çµ±æ¶æ§‹å¸«</div>
                        
                        <!-- è·æ¥­è¢«å‹•é¡¯ç¤º -->
                        <div id="class-bonus-display" style="margin-top: 10px; padding: 6px 10px; background: rgba(0, 217, 255, 0.1); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 6px;">
                            <div style="font-size: 0.7rem; color: #888; margin-bottom: 2px;">ğŸ“Š è·æ¥­è¢«å‹•</div>
                            <div id="class-bonus-text" style="font-size: 0.8rem; color: #7a8fb8;">æ¯ç´š +10 HP, +9 DEF</div>
                        </div>
                        
                        <!-- æŠ€èƒ½æ•ˆæœé¡¯ç¤º -->
                        <div id="skill-effect-display" style="margin-top: 8px; padding: 6px 10px; background: rgba(186, 104, 200, 0.15); border: 1px solid rgba(186, 104, 200, 0.5); border-radius: 6px;">
                            <div style="font-size: 0.7rem; color: #aaa; margin-bottom: 2px;">âš¡ æŠ€èƒ½æ•ˆæœ</div>
                            <div id="skill-effect-text" style="font-size: 0.85rem; color: #ce93d8; font-weight: 500;">æœªé¸æ“‡æŠ€èƒ½</div>
                        </div>
                        
                        <div id="current-title-badge" style="margin-top: 10px; padding: 8px 12px; background: linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 165, 0, 0.15) 100%); border: 1px solid rgba(255, 215, 0, 0.5); border-radius: 8px; display: none;">
                            <div style="font-size: 0.75rem; color: #888; margin-bottom: 3px;">ğŸ† ç›®å‰ç¨±è™Ÿ</div>
                            <div id="current-title-name" style="font-size: 0.95rem; font-weight: bold; color: #FFD700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.5);">ç„¡</div>
                        </div>
                    </div>
                    
                    <!-- HPè¡€æ¢ -->
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 0.85rem; color: #7a8fb8;">â¤ï¸ ç”Ÿå‘½å€¼</span>
                            <span style="font-size: 0.9rem; font-weight: bold; color: #ff6b6b;" id="player-hp">100/100</span>
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); height: 24px; border-radius: 12px; border: 2px solid rgba(255, 107, 107, 0.5); overflow: hidden; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);">
                            <div id="player-hp-bar" style="height: 100%; background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%); transition: width 0.3s ease; box-shadow: 0 0 10px rgba(255, 107, 107, 0.5); width: 100%;"></div>
                        </div>
                        <div style="margin-top: 8px; font-size: 0.75rem; display: flex; align-items: center; gap: 5px; flex-wrap: wrap;">
                            <input type="checkbox" id="auto-potion-toggle" onchange="toggleAutoPotion()" style="cursor: pointer;">
                            <label for="auto-potion-toggle" style="color: #7a8fb8; cursor: pointer;">è‡ªå‹•å–è—¥</label>
                            <select id="potion-selector" onchange="selectPotionType()" style="background: rgba(0, 217, 255, 0.1); border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff; padding: 2px 5px; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">
                                <option value="">é¸æ“‡è—¥æ°´...</option>
                            </select>
                            <select id="auto-potion-threshold" onchange="updateAutoPotionThreshold()" style="background: rgba(0, 217, 255, 0.1); border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff; padding: 2px 5px; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">
                                <option value="30">30%</option>
                                <option value="40">40%</option>
                                <option value="50" selected>50%</option>
                                <option value="60">60%</option>
                                <option value="70">70%</option>
                            </select>
                        </div>
                    </div>
                    
                    <!-- é«”åŠ›è¡€æ¢ -->
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 0.85rem; color: #7a8fb8;">âš¡ é«”åŠ›</span>
                            <div>
                                <span style="font-size: 0.9rem; font-weight: bold; color: #4EA5FF;" id="player-ap">20/20</span>
                                <span id="ap-timer" style="font-size: 0.75rem; color: #00ff88; margin-left: 5px;"></span>
                            </div>
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); height: 20px; border-radius: 10px; border: 2px solid rgba(78, 165, 255, 0.5); overflow: hidden; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);">
                            <div id="player-ap-bar" style="height: 100%; background: linear-gradient(90deg, #4EA5FF 0%, #00d9ff 100%); transition: width 0.3s ease; box-shadow: 0 0 10px rgba(78, 165, 255, 0.5); width: 100%;"></div>
                        </div>
                    </div>
                    
                    <!-- ç¶“é©—å€¼è¡€æ¢ -->
                    <div style="margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <span style="font-size: 0.85rem; color: #7a8fb8;">â­ ç¶“é©—å€¼</span>
                            <span style="font-size: 0.9rem; font-weight: bold; color: #FFD700;" id="player-exp">0/100</span>
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); height: 18px; border-radius: 9px; border: 2px solid rgba(255, 215, 0, 0.5); overflow: hidden; box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);">
                            <div id="player-exp-bar" style="height: 100%; background: linear-gradient(90deg, #FFD700 0%, #FFA500 100%); transition: width 0.3s ease; box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); width: 0%;"></div>
                        </div>
                    </div>
                    
                    <div class="resources" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                        <div class="resource" style="background: rgba(255, 215, 0, 0.08); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); text-align: center;">
                            <div style="color: #7a8fb8; font-size: 0.7rem; margin-bottom: 4px;">ğŸ’° é‡‘å¹£</div>
                            <div style="color: #FFD700; font-weight: bold; font-size: 1.1rem;" id="player-gold">100</div>
                        </div>
                        <div class="resource" style="background: rgba(78, 165, 255, 0.08); padding: 10px; border-radius: 8px; border: 1px solid rgba(78, 165, 255, 0.3); text-align: center;">
                            <div style="color: #7a8fb8; font-size: 0.7rem; margin-bottom: 4px;">ğŸ”· ç¢ç‰‡</div>
                            <div style="color: #4EA5FF; font-weight: bold; font-size: 1.1rem;" id="player-shards">0</div>
                        </div>
                        <div class="resource" style="background: rgba(156, 39, 176, 0.08); padding: 10px; border-radius: 8px; border: 1px solid rgba(156, 39, 176, 0.3); text-align: center;">
                            <div style="color: #7a8fb8; font-size: 0.7rem; margin-bottom: 4px;">ğŸ”¨ å¼·åŒ–çŸ³</div>
                            <div style="color: #9C27B0; font-weight: bold; font-size: 1.1rem;" id="player-enhance-stone">0</div>
                        </div>
                        <div class="resource" style="background: rgba(255, 152, 0, 0.08); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.3); text-align: center;">
                            <div style="color: #7a8fb8; font-size: 0.7rem; margin-bottom: 4px;">ğŸ² é‡é‘„çŸ³</div>
                            <div style="color: #FF9800; font-weight: bold; font-size: 1.1rem;" id="player-reforge-stone">0</div>
                        </div>
                    </div>
                    
                    <!-- å¢ç›Šç‹€æ…‹é¡¯ç¤º -->
                    <div id="buffs-container" style="margin-top: 15px; display: none;">
                        <h3 style="font-size: 0.9rem; color: #00d9ff; margin-bottom: 8px;">ğŸ¯ ç•¶å‰å¢ç›Š</h3>
                        <div id="buffs-list" style="font-size: 0.75rem; color: #7a8fb8; line-height: 1.6;">
                            <!-- å‹•æ…‹ç”Ÿæˆ -->
                        </div>
                    </div>
                    
                    <h2 style="margin-top: 20px; background: linear-gradient(135deg, #00d9ff 0%, #4EA5FF 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.1rem;">âš”ï¸ å±¬æ€§</h2>
                    <div class="stats-grid">
                        <!-- åŸºç¤å±¬æ€§ -->
                        <div class="stat-item">
                            <div class="stat-label">âš”ï¸ æ”»æ“Š</div>
                            <div class="stat-value" id="player-atk">10</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ›¡ï¸ é˜²ç¦¦</div>
                            <div class="stat-value" id="player-def">5</div>
                        </div>
                        
                        <!-- æš´æ“Šå±¬æ€§ -->
                        <div class="stat-item">
                            <div class="stat-label">ğŸ’¥ æš´æ“Šç‡</div>
                            <div class="stat-value" id="player-crit">5%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ’¢ æš´æ“Šå‚·</div>
                            <div class="stat-value" id="player-critdmg">150%</div>
                        </div>
                        
                        <!-- æ–°å¢å±¬æ€§ -->
                        <div class="stat-item">
                            <div class="stat-label">ğŸ”° æ¸›å‚·</div>
                            <div class="stat-value" id="player-dmgred">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ©¸ å¸è¡€</div>
                            <div class="stat-value" id="player-lifesteal">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ—¡ï¸ ç„¡è¦–é˜²ç¦¦</div>
                            <div class="stat-value" id="player-armorpen">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ‘‘ å°é¦–é ˜å‚·å®³</div>
                            <div class="stat-value" id="player-bossdmg">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ’š ç”Ÿå‘½å›å¾©</div>
                            <div class="stat-value" id="player-hpregen">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">â­ ç¶“é©—åŠ æˆ</div>
                            <div class="stat-value" id="player-expbonus">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ€ å¹¸é‹å€¼</div>
                            <div class="stat-value" id="player-luck">0%</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">ğŸ’° é‡‘å¹£åŠ æˆ</div>
                            <div class="stat-value" id="player-goldbonus">0%</div>
                        </div>
                    </div>
                    
                    <h2 style="margin-top: 20px; background: linear-gradient(135deg, #00d9ff 0%, #4EA5FF 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.1rem;">ğŸ² è£å‚™</h2>
                    <div id="set-effect-display" style="background: rgba(0, 255, 136, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(0, 255, 136, 0.3); margin-bottom: 10px; font-size: 0.85rem;">
                        <span style="color: #00ff88; font-weight: bold;">ç›®å‰å¥—è£æ•ˆæœï¼š</span>
                        <span id="set-effect-text" style="color: #7a8fb8;">ç„¡</span>
                    </div>
                    <div id="special-effects-display" style="background: rgba(255, 136, 0, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 136, 0, 0.3); margin-bottom: 10px; font-size: 0.85rem;">
                        <div style="color: #ff8800; font-weight: bold; margin-bottom: 5px;">âœ¨ ç›®å‰è£å‚™ç‰¹æ®Šæ•ˆæœï¼š</div>
                        <div id="special-effects-list" style="color: #7a8fb8; line-height: 1.6;">ç„¡</div>
                    </div>
                    <div id="equipment-slots">
                        <div class="equipment-slot" data-slot="weapon" onclick="openEquipmentModal('weapon')">
                            <div style="color: #7a8fb8; font-size: 0.8rem;">ğŸ—¡ï¸ æ­¦å™¨</div>
                            <div id="equip-weapon" style="color: #5a6b8f; font-size: 0.85rem;">ç©º</div>
                        </div>
                        <div class="equipment-slot" data-slot="armor" onclick="openEquipmentModal('armor')">
                            <div style="color: #7a8fb8; font-size: 0.8rem;">ğŸ›¡ï¸ é˜²å…·</div>
                            <div id="equip-armor" style="color: #5a6b8f; font-size: 0.85rem;">ç©º</div>
                        </div>
                        <div class="equipment-slot" data-slot="accessory1" onclick="openEquipmentModal('accessory1')">
                            <div style="color: #7a8fb8; font-size: 0.8rem;">ğŸ’ é£¾å“1</div>
                            <div id="equip-accessory1" style="color: #5a6b8f; font-size: 0.85rem;">ç©º</div>
                        </div>
                        <div class="equipment-slot" data-slot="accessory2" onclick="openEquipmentModal('accessory2')">
                            <div style="color: #7a8fb8; font-size: 0.8rem;">ğŸ’ é£¾å“2</div>
                            <div id="equip-accessory2" style="color: #5a6b8f; font-size: 0.85rem;">ç©º</div>
                        </div>
                    </div>
                    
                    <!-- éš¨å¾é¡¯ç¤ºå€ -->
                    <h2 style="margin-top: 20px; background: linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.1rem;">ğŸ¾ éš¨å¾</h2>
                    <div id="companion-display" style="background: rgba(255, 154, 86, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 154, 86, 0.3); min-height: 60px; cursor: pointer;" onclick="openCompanionModal()">
                        <div id="companion-info" style="color: #7a8fb8; font-size: 0.85rem; text-align: center;">
                            ç„¡è£å‚™éš¨å¾<br>
                            <span style="color: #ff9a56; font-size: 0.75rem;">é»æ“Šç®¡ç†</span>
                        </div>
                    </div>
                    
                    <!-- å¡ç‰Œé¡¯ç¤ºå€ -->
                    <h2 style="margin-top: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: 1.1rem;">ğŸ´ å¡ç‰Œ</h2>
                    <div id="card-slots-display" style="background: rgba(138, 43, 226, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                        <!-- å‹•æ…‹ç”Ÿæˆ -->
                    </div>
                </div>
                
                <!-- ä¸­é–“é¢æ¿ï¼šæˆ°é¬¥æ—¥èªŒèˆ‡æ§åˆ¶ -->
                <div class="panel">
                    <h2>ğŸ“œ æˆ°é¬¥æ—¥èªŒ</h2>
                    
                    <!-- å¿«æ·æ“ä½œæ¬„ -->
                    <div style="display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;">
                        <button onclick="openBagModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">ğŸ’ èƒŒåŒ…</button>
                        <button onclick="openShopModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">ğŸª å•†åº—</button>
                        <button onclick="openDailyQuestsModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);">ğŸ“‹ ä»»å‹™</button>
                        <button onclick="openTalentsModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">âœ¨ å¤©è³¦</button>
                        <button onclick="openCompanionModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #ff9a56 0%, #ff6a88 100%);">ğŸ¾ éš¨å¾</button>
                        <button onclick="openPetModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">ğŸ² å¯µç‰©</button>
                        <button onclick="openCardModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">ğŸ´ å¡ç‰Œ</button>
                        <button onclick="openCodexModal()" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);">ğŸ“– åœ–é‘‘</button>
                        <button onclick="openIterationModal()" id="quick-iteration-btn" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); display: none;">ğŸ”„ è¿­ä»£</button>
                        <button id="auto-equip-btn" style="flex: 1; min-width: 80px; padding: 8px; font-size: 0.9rem; background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);">âš™ï¸ è‡ªå‹•</button>
                    </div>
                    
                    <!-- å€åŸŸè³‡è¨Šï¼ˆé ‚éƒ¨ï¼‰ -->
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 10px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px; text-align: center;">
                        <span style="color: #00d9ff; font-weight: bold; font-size: 1rem;">ğŸ—ºï¸ <span id="current-region">å…¥é–€é–‹ç™¼å±¤</span></span>
                        <span style="color: #7a8fb8; margin: 0 10px;">|</span>
                        <span style="color: #FFD700; font-weight: bold;" id="difficulty">Ã—1.0</span>
                        <span style="color: #7a8fb8; margin: 0 10px;">|</span>
                        <span style="color: #00d9ff; font-weight: bold;">é€²åº¦: <span id="battle-progress">0/10</span></span>
                    </div>
                    
                    <!-- æ€ªç‰©HPé¡¯ç¤ºå€ï¼ˆç§»åˆ°æ—¥èªŒä¸Šæ–¹ï¼‰ -->
                    <div id="enemy-hp-container" style="display: none; margin-bottom: 15px; padding: 12px; background: rgba(0, 217, 255, 0.05); border-radius: 8px; border: 2px solid rgba(0, 217, 255, 0.3); min-height: 80px;">
                        <div id="enemy-name-display" style="font-size: 1rem; font-weight: bold; color: #ffd700; margin-bottom: 8px; text-align: center; min-height: 24px; line-height: 24px;"></div>
                        <div class="enemy-hp-bar" style="position: relative; width: 100%; height: 28px; background: rgba(0, 0, 0, 0.6); border-radius: 14px; border: 2px solid rgba(0, 217, 255, 0.5); overflow: hidden;">
                            <div id="enemy-hp-fill" style="height: 100%; background: linear-gradient(90deg, #4CAF50 0%, #66BB6A 100%); transition: width 0.5s ease, background 0.3s ease; box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);"></div>
                            <div id="enemy-hp-text" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-weight: bold; font-size: 0.9rem; text-shadow: 0 0 4px rgba(0, 0, 0, 0.8), 1px 1px 2px rgba(0, 0, 0, 1);"></div>
                        </div>
                    </div>
                    
                    <div class="log-container" id="battle-log">
                        <div class="log-entry">
                            <div class="log-time">[ç³»çµ±]</div>
                            <div class="log-text">æ­¡è¿ä¾†åˆ°æ•¸ä½æ·±æ·µï¼é–‹å§‹ä½ çš„æ¢ç´¢ä¹‹æ—…å§ï¼</div>
                        </div>
                    </div>
                    
                    <!-- æŒ‰éˆ•å€åŸŸï¼šä¿ç•™æ ¸å¿ƒæ“ä½œ -->
                    <div class="controls" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- éŠæˆ²æ“ä½œ -->
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="toggleAutoExplore()" id="auto-explore-btn" style="flex: 1; min-width: 120px;">â–¶ï¸ è‡ªå‹•æˆ°é¬¥</button>
                        </div>
                        
                        <!-- å…¶ä»–åŠŸèƒ½ -->
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="openShardShopModal()" style="flex: 1; min-width: 90px;">ğŸ”· ç¢ç‰‡å•†åº—</button>
                            <button onclick="openSalvageModal()" style="flex: 1; min-width: 90px;">âš™ï¸ åˆ†è§£</button>
                        </div>
                        
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="openRegionModal()" style="flex: 1; min-width: 90px;">ğŸ—ºï¸ åˆ‡æ›å€åŸŸ</button>
                            <button onclick="openDungeonsModal()" style="flex: 1; min-width: 90px;">ğŸ° å‰¯æœ¬</button>
                        </div>
                        
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="openEndlessModal()" style="flex: 1; min-width: 90px; background: linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%);">ğŸ—¼ ç„¡ç›¡æŒ‘æˆ°</button>
                        </div>
                        
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="openTitlesModal()" style="flex: 1; min-width: 90px;">ğŸ† ç¨±è™Ÿ</button>
                            <button onclick="openHowToPlay()" style="flex: 1; min-width: 90px;">â“ èªªæ˜</button>
                        </div>
                        
                        <!-- ç³»çµ±åŠŸèƒ½ -->
                        <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                            <button onclick="exportSave()" style="flex: 1; min-width: 90px;">ğŸ“¥ åŒ¯å‡º</button>
                            <button onclick="importSave()" style="flex: 1; min-width: 90px;">ğŸ“¤ åŒ¯å…¥</button>
                        </div>
                        
                        <!-- BGM æ§åˆ¶ -->
                        <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 5px;">
                            <button id="bgm-toggle-btn" onclick="toggleBGM()" style="padding: 10px 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-size: 0.9rem; transition: all 0.3s;">
                                ğŸµ BGM: ON
                            </button>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="color: #7a8fb8; font-size: 0.85rem;">ğŸ”Š</label>
                                <input type="range" id="bgm-volume" min="0" max="100" value="50" oninput="changeBGMVolume(this.value)" style="flex: 1; accent-color: #667eea;">
                                <span id="volume-display" style="color: #7a8fb8; font-size: 0.85rem; min-width: 35px;">50%</span>
                            </div>
                        </div>
                    </div>
                    
                    <!-- çµ±è¨ˆè³‡è¨Šï¼ˆåº•éƒ¨ï¼‰ -->
                    <div style="background: rgba(0, 217, 255, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin-top: 15px; text-align: center; font-size: 0.85rem;">
                        <span style="color: #7a8fb8;">ğŸ“Š</span>
                        <span style="color: #00d9ff; margin-left: 5px;">æ“Šæ•—: <span id="stat-kills" style="font-weight: bold;">0</span></span>
                        <span style="color: #7a8fb8; margin: 0 8px;">|</span>
                        <span style="color: #4EA5FF;">è£å‚™: <span id="stat-items" style="font-weight: bold;">0</span></span>
                        <span style="color: #7a8fb8; margin: 0 8px;">|</span>
                        <span style="color: #7a8fb8;">æ™‚é–“: <span id="stat-time" style="font-weight: bold;">0åˆ†</span></span>
                    </div>
                    
                    <input type="file" id="import-file-input" accept=".json" style="display: none;" onchange="handleImportFile(event)">
                </div>
            </div>
        </div>
    </div>

    <!-- èƒŒåŒ…æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="bag-modal">
        <div class="modal-content">
            <h2>ğŸ’ èƒŒåŒ… (<span id="bag-count">0/50</span>)</h2>
            <div id="bag-items" style="max-height: 400px; overflow-y: auto;">
                <p style="color: #7a8fb8; text-align: center; padding: 20px;">èƒŒåŒ…æ˜¯ç©ºçš„</p>
            </div>
            <button onclick="closeBagModal()" style="margin-top: 15px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

    <!-- è£å‚™é¸æ“‡æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="equipment-modal">
        <div class="modal-content">
            <h2 id="equipment-modal-title">é¸æ“‡è£å‚™</h2>
            <div id="equipment-list" style="max-height: 400px; overflow-y: auto;">
            </div>
            <button onclick="closeEquipmentModal()" style="margin-top: 15px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

    <!-- å€åŸŸé¸æ“‡æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="region-modal">
        <div class="modal-content">
            <h2>ğŸ—ºï¸ é¸æ“‡å€åŸŸ</h2>
            <div id="region-list">
                <!-- å€åŸŸæŒ‰éˆ•å°‡ç”± JavaScript ç”Ÿæˆ -->
            </div>
            <button onclick="closeRegionModal()" style="margin-top: 15px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

    <!-- å•†åº—æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="shop-modal">
        <div class="modal-content">
            <h2>ğŸª å•†åº—</h2>
            <div style="margin: 15px 0;">
                <h3 style="color: #00d9ff; margin-bottom: 10px;">è³¼è²·è—¥æ°´</h3>
                <div id="shop-items">
                    <!-- å•†å“å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
            </div>
            <button onclick="closeShopModal()" style="margin-top: 15px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

    <!-- åˆ†è§£æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="salvage-modal">
        <div class="modal-content">
            <h2>âš™ï¸ åˆ†è§£è£å‚™</h2>
            <p style="color: #7a8fb8; margin: 10px 0;">åˆ†è§£è£å‚™å¯ç²å¾—ç¢ç‰‡</p>
            <div id="salvage-items" style="max-height: 400px; overflow-y: auto;">
                <p style="color: #7a8fb8; text-align: center; padding: 20px;">æ²’æœ‰å¯åˆ†è§£çš„è£å‚™</p>
            </div>
            <button onclick="closeSalvageModal()" style="margin-top: 15px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

    <!-- ç¢ç‰‡å•†åº—æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="shard-shop-modal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>ğŸ”· ç¢ç‰‡å•†åº—</h2>
            <p style="color: #4EA5FF; font-size: 1.1rem; margin: 10px 0;">ç•¶å‰ç¢ç‰‡ï¼š<span id="shop-shards-display" style="font-weight: bold;">0</span></p>
            
            <!-- åˆ†é æŒ‰éˆ• -->
            <div style="display: flex; gap: 10px; margin: 15px 0; flex-wrap: wrap;">
                <button onclick="switchShopTab('equipment')" id="shop-tab-equipment" style="flex: 1; min-width: 100px;">ğŸª è£å‚™</button>
                <button onclick="switchShopTab('consumable')" id="shop-tab-consumable" style="flex: 1; min-width: 100px;">ğŸ§ª æ¶ˆè€—å“</button>
                <button onclick="switchShopTab('special')" id="shop-tab-special" style="flex: 1; min-width: 100px;">âœ¨ ç‰¹æ®Š</button>
            </div>
            
            <!-- å•†åº—å…§å®¹ -->
            <div id="shop-content" style="max-height: 500px; overflow-y: auto; padding: 10px 0;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <button onclick="closeShardShopModal()" style="margin-top: 15px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

        <!-- å¦‚ä½•éŠç©æ¨¡æ…‹è¦–çª— -->
    <!-- å¦‚ä½•éŠç©æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="how-to-play-modal">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <h2 style="text-align: center; margin-bottom: 20px;">â“ å¦‚ä½•éŠç©</h2>
            
            <!-- Tab æ¨™ç±¤ -->
            <div style="display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;">
                <button class="how-to-play-tab active" onclick="switchHowToPlayTab('quickstart')" data-tab="quickstart" style="flex: 1; min-width: 120px; padding: 12px; font-size: 0.9rem; background: linear-gradient(135deg, #00d9ff 0%, #4EA5FF 100%); border: none; border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                    ğŸš€ å¿«é€Ÿå…¥é–€
                </button>
                <button class="how-to-play-tab" onclick="switchHowToPlayTab('combat')" data-tab="combat" style="flex: 1; min-width: 120px; padding: 12px; font-size: 0.9rem; background: rgba(0, 217, 255, 0.2); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                    âš”ï¸ æˆ°é¬¥èˆ‡å±¬æ€§
                </button>
                <button class="how-to-play-tab" onclick="switchHowToPlayTab('gear')" data-tab="gear" style="flex: 1; min-width: 120px; padding: 12px; font-size: 0.9rem; background: rgba(0, 217, 255, 0.2); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                    ğŸ’ è£å‚™èˆ‡å¼·åŒ–
                </button>
                <button class="how-to-play-tab" onclick="switchHowToPlayTab('advanced')" data-tab="advanced" style="flex: 1; min-width: 120px; padding: 12px; font-size: 0.9rem; background: rgba(0, 217, 255, 0.2); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                    ğŸŒŸ é€²éšç³»çµ±
                </button>
                <button class="how-to-play-tab" onclick="switchHowToPlayTab('prestige')" data-tab="prestige" style="flex: 1; min-width: 120px; padding: 12px; font-size: 0.9rem; background: rgba(0, 217, 255, 0.2); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; cursor: pointer; transition: all 0.3s;">
                    ğŸ”„ è¿­ä»£èˆ‡å¤©è³¦
                </button>
            </div>
            
            <!-- Tab å…§å®¹ -->
            <div id="how-to-play-content" style="text-align: left; color: #e0e6ff; line-height: 1.8;">
                
                <!-- å¿«é€Ÿå…¥é–€ -->
                <div class="how-to-play-panel" id="panel-quickstart" style="display: block;">
                    <h3 style="color: #00d9ff; text-align: center; margin-bottom: 20px;">ğŸš€ æ–°æ‰‹å¿«é€Ÿå…¥é–€</h3>
                    <p style="color: #7a8fb8; text-align: center; font-size: 1.1rem; margin-bottom: 30px;">æ­¡è¿ä¾†åˆ°æ•¸ä½æ·±æ·µï¼åªéœ€5å€‹æ­¥é©Ÿ,ç«‹å³é–‹å§‹ä½ çš„å†’éšªï¼</p>
                    
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                        <h4 style="color: #00d9ff; margin-bottom: 10px;">ğŸ“ æ­¥é©Ÿ1: å‰µå»ºè§’è‰²</h4>
                        <p style="color: #7a8fb8;">è¼¸å…¥ä½ çš„è§’è‰²åå­—,ç„¶å¾Œå¾<strong style="color: #00d9ff;">9ç¨®è·æ¥­</strong>ä¸­é¸æ“‡ä¸€å€‹ã€‚ä¸ç”¨æ“”å¿ƒ,æ¯å€‹è·æ¥­éƒ½å¾ˆå¼·,é¸ä¸€å€‹ä½ å–œæ­¡çš„å°±å¥½!</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">ğŸ’¡ æç¤º: æ–°æ‰‹æ¨è–¦<strong style="color: #00d9ff;">ç³»çµ±æ¶æ§‹å¸«</strong>(å¦å…‹å‹)æˆ–<strong style="color: #00d9ff;">æ•¸æ“šç§‘å­¸å®¶</strong>(å‡è¡¡å‹)</p>
                    </div>
                    
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                        <h4 style="color: #00d9ff; margin-bottom: 10px;">âš¡ æ­¥é©Ÿ2: é¸æ“‡æŠ€èƒ½</h4>
                        <p style="color: #7a8fb8;">å¾<strong style="color: #00d9ff;">10å€‹æŠ€èƒ½</strong>ä¸­é¸æ“‡1å€‹ä½œç‚ºä½ çš„å°ˆå±¬æŠ€èƒ½ã€‚æŠ€èƒ½åˆ†ç‚º<strong style="color: #ff6b6b;">æ”»æ“Šå‹</strong>ã€<strong style="color: #4ea5ff;">é˜²ç¦¦å‹</strong>å’Œ<strong style="color: #00ff88;">å¢ç›Šå‹</strong>ã€‚</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">ğŸ’¡ æç¤º: æ”»æ“Šå‹æŠ€èƒ½é©åˆå¿«é€Ÿæ¨é€²,é˜²ç¦¦å‹æŠ€èƒ½é©åˆç©©å¥ç©æ³•</p>
                    </div>
                    
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                        <h4 style="color: #00d9ff; margin-bottom: 10px;">â–¶ï¸ æ­¥é©Ÿ3: é–‹å§‹æˆ°é¬¥</h4>
                        <p style="color: #7a8fb8;">é»æ“Šä¸»ç•«é¢å·¦å´çš„<strong style="color: #00d9ff;">ã€Œâ–¶ï¸ è‡ªå‹•æˆ°é¬¥ã€</strong>æŒ‰éˆ•,éŠæˆ²æœƒè‡ªå‹•å¹«ä½ æˆ°é¬¥ã€‚ä½ åªéœ€è¦åè‘—çœ‹æ—¥èªŒ,ç­‰å¾…å‹åˆ©!</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">ğŸ’¡ æç¤º: æˆ°é¬¥æ¶ˆè€—<strong style="color: #00d9ff;">1é»é«”åŠ›(AP)</strong>,é«”åŠ›æœƒè‡ªå‹•å›å¾©</p>
                    </div>
                    
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                        <h4 style="color: #00d9ff; margin-bottom: 10px;">ğŸ’ æ­¥é©Ÿ4: ç©¿ä¸Šè£å‚™</h4>
                        <p style="color: #7a8fb8;">æˆ°é¬¥å‹åˆ©å¾Œ,é»æ“Š<strong style="color: #00d9ff;">ã€ŒğŸ’ èƒŒåŒ…ã€</strong>æŸ¥çœ‹ç²å¾—çš„è£å‚™ã€‚é¸æ“‡å±¬æ€§æ›´å¥½çš„è£å‚™,é»æ“Š<strong style="color: #00d9ff;">ã€Œå¿«é€Ÿè£å‚™ã€</strong>ç©¿ä¸Š!</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">ğŸ’¡ æç¤º: è£å‚™å“è³ªå¾ä½åˆ°é«˜: <span style="color: #9e9e9e;">ç°</span> < <span style="color: #4caf50;">ç¶ </span> < <span style="color: #2196f3;">è—</span> < <span style="color: #9c27b0;">ç´«</span> < <span style="color: #ff9800;">æ©™</span> < <span style="color: #f44336;">ç´…</span> < <span style="color: #ffd700;">é‡‘</span></p>
                    </div>
                    
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                        <h4 style="color: #00d9ff; margin-bottom: 10px;">ğŸ”„ æ­¥é©Ÿ5: é‡è¤‡å¾ªç’°</h4>
                        <p style="color: #7a8fb8; font-size: 1.1rem; text-align: center;"><strong style="color: #00d9ff;">æˆ°é¬¥</strong> â†’ <strong style="color: #00d9ff;">ç²å¾—è£å‚™</strong> â†’ <strong style="color: #00d9ff;">è®Šå¼·</strong> â†’ <strong style="color: #00d9ff;">æŒ‘æˆ°æ›´å¼·çš„æ•µäºº</strong></p>
                        <p style="color: #888; font-size: 0.9rem; margin-top: 10px; text-align: center;">å°±æ˜¯é€™éº¼ç°¡å–®!ç¾åœ¨ä½ å·²ç¶“æŒæ¡äº†éŠæˆ²çš„æ ¸å¿ƒç©æ³•!</p>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, rgba(0, 217, 255, 0.15) 0%, rgba(78, 165, 255, 0.15) 100%); padding: 20px; border-radius: 10px; border: 2px solid rgba(0, 217, 255, 0.5); margin-top: 20px;">
                        <h4 style="color: #00d9ff; text-align: center; margin-bottom: 10px;">ğŸ¯ æ¥ä¸‹ä¾†åšä»€éº¼?</h4>
                        <ul style="color: #7a8fb8; margin-left: 20px;">
                            <li>æ¯<strong style="color: #00d9ff;">10å ´æˆ°é¬¥</strong>æœƒé‡åˆ°<strong style="color: #ffd700;">Boss</strong>,çå‹µæ›´è±åš!</li>
                            <li>é”åˆ°<strong style="color: #00d9ff;">26ç´š</strong>å¾Œå¯ä»¥åˆ‡æ›åˆ°æ›´é«˜ç´šçš„å€åŸŸ</li>
                            <li>é»æ“Š<strong style="color: #00d9ff;">ã€ŒğŸ’° å•†åº—ã€</strong>è³¼è²·è—¥æ°´å’Œé“å…·</li>
                            <li>é»æ“Š<strong style="color: #00d9ff;">ã€ŒğŸ”¨ éµåŒ èˆ–ã€</strong>å¼·åŒ–æˆ–åˆ†è§£è£å‚™</li>
                            <li>é»æ“Š<strong style="color: #00d9ff;">ã€ŒğŸ“– åœ–é‘‘ã€</strong>æŸ¥çœ‹æ”¶é›†é€²åº¦å’Œè§£é–ç¨±è™Ÿ</li>
                            <li>é»æ“Š<strong style="color: #00d9ff;">ã€Œâš™ï¸ è‡ªå‹•ã€</strong>å•Ÿç”¨è‡ªå‹•è£å‚™èˆ‡åˆ†è§£</li>
                            <li>é»æ“Šå…¶ä»–TabæŸ¥çœ‹æ›´å¤šé€²éšç³»çµ±!</li>
                        </ul>
                    </div>
                </div>
                
                <!-- æˆ°é¬¥èˆ‡å±¬æ€§ -->
                <div class="how-to-play-panel" id="panel-combat" style="display: none;">
                    <h3 style="color: #00d9ff; text-align: center; margin-bottom: 20px;">âš”ï¸ æˆ°é¬¥èˆ‡å±¬æ€§</h3>
                    
                    <h4 style="color: #00d9ff; margin-top: 20px;">ğŸ“Š è§’è‰²å±¬æ€§èªªæ˜</h4>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0; background: rgba(0, 217, 255, 0.05);">
                        <thead>
                            <tr style="background: rgba(0, 217, 255, 0.15);">
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">å±¬æ€§</th>
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">èªªæ˜</th>
                            </tr>
                        </thead>
                        <tbody style="color: #7a8fb8;">
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ff6b6b;">ç”Ÿå‘½å€¼ (HP)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">ä½ çš„è¡€é‡,æ­¸é›¶å°±æœƒæ­»äº¡(ä½†ä¸æœƒæå¤±è£å‚™)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ff9800;">æ”»æ“ŠåŠ› (ATK)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">æ±ºå®šä½ é€ æˆçš„å‚·å®³,è¶Šé«˜è¶Šå¥½</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #2196f3;">é˜²ç¦¦åŠ› (DEF)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">æ¸›å°‘å—åˆ°çš„å‚·å®³</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ffd700;">æš´æ“Šç‡ (CRIT)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">è§¸ç™¼æš´æ“Šçš„æ©Ÿç‡(%)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ffd700;">æš´æ“Šå‚·å®³ (CRITDMG)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">æš´æ“Šæ™‚é€ æˆçš„å‚·å®³å€ç‡(%)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #9c27b0;">æ¸›å‚· (DMG RED)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">é¡å¤–æ¸›å°‘å—åˆ°çš„å‚·å®³(%),ä¸Šé™75%</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #f44336;">å¸è¡€ (LIFESTEAL)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">æ”»æ“Šæ™‚å›å¾©é€ æˆå‚·å®³çš„ä¸€å®šæ¯”ä¾‹(%)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #00ffff;">ç„¡è¦–é˜²ç¦¦ (ARMORPEN)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">ç„¡è¦–æ•µäººä¸€å®šæ¯”ä¾‹çš„é˜²ç¦¦(%)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #4caf50;">å¹¸é‹ (LUCK)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">æå‡è£å‚™æ‰è½æ©Ÿç‡(%)</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ffd700;">é‡‘å¹£ç²å– (GOLD)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">å¢åŠ æˆ°é¬¥ç²å¾—çš„é‡‘å¹£(%)</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">âš”ï¸ æˆ°é¬¥æµç¨‹</h4>
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin: 15px 0;">
                        <ol style="color: #7a8fb8; margin-left: 20px; line-height: 2;">
                            <li>é»æ“Š<strong style="color: #00d9ff;">ã€Œâ–¶ï¸ è‡ªå‹•æˆ°é¬¥ã€</strong>æ¶ˆè€—1é»é«”åŠ›(AP)</li>
                            <li>è‡ªå‹•é‡åˆ°æ•µäººä¸¦é€²å…¥<strong style="color: #00d9ff;">å›åˆåˆ¶æˆ°é¬¥</strong></li>
                            <li>ç©å®¶å…ˆæ”»æ“Š â†’ æ•µäººåæ“Š â†’ å¾ªç’°ç›´åˆ°ä¸€æ–¹HPæ­¸é›¶</li>
                            <li>å‹åˆ©ç²å¾—<strong style="color: #ffd700;">ç¶“é©—ã€é‡‘å¹£</strong>,æœ‰æ©Ÿç‡æ‰è½<strong style="color: #9c27b0;">è£å‚™</strong>å’Œ<strong style="color: #4ea5ff;">æ¶ˆè€—å“</strong></li>
                            <li>æ¯<strong style="color: #ffd700;">10å ´æˆ°é¬¥</strong>æœƒé‡åˆ°<strong style="color: #ff9800;">Boss</strong>,çå‹µÃ—3!</li>
                        </ol>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ’ª æ€ªç‰©è©ç¶´</h4>
                    <p style="color: #7a8fb8;">å¶çˆ¾æœƒé‡åˆ°å¸¶æœ‰ç‰¹æ®Šè©ç¶´çš„<strong style="color: #ff9800;">èè‹±æ€ªç‰©</strong>,å®ƒå€‘æ›´å¼·å¤§,ä½†çå‹µä¹Ÿæ›´è±åš!</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;">
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <strong style="color: #ff6b6b;">ğŸ”¥ ç‹‚æš´</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">æ”»æ“ŠåŠ›+30%</span>
                        </div>
                        <div style="background: rgba(33, 150, 243, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(33, 150, 243, 0.3);">
                            <strong style="color: #2196f3;">ğŸ›¡ï¸ å …éŸŒ</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">é˜²ç¦¦åŠ›+40%</span>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <strong style="color: #ffd700;">âš¡ è¿…æ·</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">æš´æ“Šç‡+15%</span>
                        </div>
                        <div style="background: rgba(156, 39, 176, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(156, 39, 176, 0.3);">
                            <strong style="color: #9c27b0;">ğŸ’š å†ç”Ÿ</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">æ¯å›åˆå›å¾©5%HP</span>
                        </div>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">âš¡ é«”åŠ›ç³»çµ±</h4>
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">æ¯æ¬¡æˆ°é¬¥æ¶ˆè€—<strong style="color: #00d9ff;">1é»é«”åŠ›(AP)</strong>,é«”åŠ›ä¸Šé™<strong style="color: #00d9ff;">100é»</strong>ã€‚</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">é«”åŠ›æœƒ<strong style="color: #00ff88;">è‡ªå‹•å›å¾©</strong>,æ¯<strong style="color: #00d9ff;">2åˆ†é˜</strong>å›å¾©<strong style="color: #00d9ff;">1é»</strong>ã€‚</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: ä¹Ÿå¯ä»¥åœ¨å•†åº—è³¼è²·<strong style="color: #00d9ff;">èƒ½é‡è—¥æ°´</strong>ç«‹å³å›å¾©é«”åŠ›!</p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ’€ æ­»äº¡æ©Ÿåˆ¶</h4>
                    <div style="background: rgba(244, 67, 54, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(244, 67, 54, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">å¦‚æœä½ çš„HPæ­¸é›¶,ä½ æœƒ<strong style="color: #f44336;">æ­»äº¡</strong>,ä½†<strong style="color: #00ff88;">ä¸æœƒæå¤±ä»»ä½•è£å‚™æˆ–ç¶“é©—</strong>!</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">æ­»äº¡å¾Œ,ä½ çš„HPæœƒè‡ªå‹•å›å¾©åˆ°<strong style="color: #00d9ff;">10%</strong>,å¯ä»¥ç¹¼çºŒæˆ°é¬¥ã€‚</p>
                    </div>
                </div>
                
                <!-- è£å‚™èˆ‡å¼·åŒ– -->
                <div class="how-to-play-panel" id="panel-gear" style="display: none;">
                    <h3 style="color: #00d9ff; text-align: center; margin-bottom: 20px;">ğŸ’ è£å‚™èˆ‡å¼·åŒ–</h3>
                    
                    <h4 style="color: #00d9ff; margin-top: 20px;">ğŸ’ è£å‚™å“è³ª</h4>
                    <p style="color: #7a8fb8;">è£å‚™åˆ†ç‚º8ç¨®å“è³ª,å“è³ªè¶Šé«˜,å±¬æ€§é»æ•¸è¶Šå¤š!</p>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0; background: rgba(0, 217, 255, 0.05);">
                        <thead>
                            <tr style="background: rgba(0, 217, 255, 0.15);">
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">å“è³ª</th>
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">å±¬æ€§é»æ•¸</th>
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">ç‰¹é»</th>
                            </tr>
                        </thead>
                        <tbody style="color: #7a8fb8;">
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #9e9e9e;">æ™®é€š(ç°)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">10</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">åŸºç¤è£å‚™</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #4caf50;">å„ªè³ª(ç¶ )</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">18</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">ç•¥å¼·æ–¼æ™®é€š</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #2196f3;">ç²¾è‰¯(è—)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">28</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">å¯èƒ½å¸¶æœ‰è©ç¶´</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #9c27b0;">ç¨€æœ‰(ç´«)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">40</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">é€šå¸¸å¸¶æœ‰è©ç¶´</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ff9800;">å²è©©(æ©™)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">52</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">å¼·å¤§çš„è©ç¶´</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #f44336;">å‚³èªª(ç´…)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">60</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">é ‚ç´šè£å‚™</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ffd700;">ç¥è©±(é‡‘)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">65</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">æ¥µç¨€æœ‰</td>
                            </tr>
                            <tr style="background: rgba(0, 255, 255, 0.1);">
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #00ffff;">å¥—è£(é’)</strong></td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">45</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);"><strong style="color: #ffd700;">å¯è§¸ç™¼å¥—è£æ•ˆæœ!</strong></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">âœ¨ è£å‚™è©ç¶´</h4>
                    <p style="color: #7a8fb8;">é«˜å“è³ªè£å‚™æœƒé™„å¸¶<strong style="color: #ff9800;">å‰ç¶´</strong>å’Œ<strong style="color: #2196f3;">å¾Œç¶´</strong>,æä¾›å¼·å¤§çš„ç‰¹æ®Šæ•ˆæœ!</p>
                    
                    <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.3); margin: 15px 0;">
                        <h5 style="color: #ff9800; margin-bottom: 10px;">ğŸ”¥ å‰ç¶´è©ç¶´(æ­¦å™¨å°ˆå±¬)</h5>
                        <ul style="color: #7a8fb8; margin-left: 20px; font-size: 0.9rem;">
                            <li><strong style="color: #ff9800;">ç†¾ç†±çš„</strong>: 15%æ©Ÿç‡é€ æˆé¡å¤–50%å‚·å®³</li>
                            <li><strong style="color: #ff9800;">é–ƒé›»çš„</strong>: 20%æ©Ÿç‡é€£é–å‚·å®³</li>
                            <li><strong style="color: #ff9800;">å—œè¡€çš„</strong>: æ“Šæ®ºå›å¾©15%æœ€å¤§ç”Ÿå‘½</li>
                            <li><strong style="color: #ffd700;">ç¥è–çš„</strong>: 10%æ©Ÿç‡é€ æˆ200%å‚·å®³</li>
                        </ul>
                    </div>
                    
                    <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(33, 150, 243, 0.3); margin: 15px 0;">
                        <h5 style="color: #2196f3; margin-bottom: 10px;">ğŸ›¡ï¸ å¾Œç¶´è©ç¶´(é˜²å…·å°ˆå±¬)</h5>
                        <ul style="color: #7a8fb8; margin-left: 20px; font-size: 0.9rem;">
                            <li><strong style="color: #2196f3;">å®ˆè­·</strong>: è‡´å‘½å‚·åªæ‰£1è¡€(30%æ©Ÿç‡)</li>
                            <li><strong style="color: #2196f3;">å†ç”Ÿ</strong>: æ¯5ç§’å›å¾©2%æœ€å¤§ç”Ÿå‘½</li>
                            <li><strong style="color: #2196f3;">åå°„</strong>: åå½ˆ10%å‚·å®³çµ¦æ•µäºº</li>
                            <li><strong style="color: #ffd700;">é­”ç›¾</strong>: æˆ°é¬¥é–‹å§‹ç²å¾—20%æœ€å¤§ç”Ÿå‘½è­·ç›¾</li>
                        </ul>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ½ å¥—è£ç³»çµ±</h4>
                    <p style="color: #7a8fb8;">ç©¿æˆ´åŒåçš„<strong style="color: #00ffff;">å¥—è£è£å‚™</strong>å¯ä»¥è§¸ç™¼è¶…å¼·å¤§çš„å¥—è£æ•ˆæœ!</p>
                    <div style="background: rgba(0, 255, 255, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 255, 255, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;"><strong style="color: #00ffff;">2ä»¶å¥—</strong>: æä¾›åŸºç¤å±¬æ€§åŠ æˆ</p>
                        <p style="color: #7a8fb8; margin-top: 8px;"><strong style="color: #00ffff;">4ä»¶å¥—</strong>: è§£é–<strong style="color: #ffd700;">ç‰¹æ®Šæ•ˆæœ</strong>(ä¾‹å¦‚:æš´æ“Šé€£é–ã€æ“Šæ®ºå›è¡€ç­‰)</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: 4ä»¶å¥—çš„ç‰¹æ®Šæ•ˆæœéå¸¸å¼·å¤§,å„ªå…ˆæ”¶é›†!</p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ”¨ å¼·åŒ–èˆ‡åˆ†è§£</h4>
                    <p style="color: #7a8fb8;">é»æ“Š<strong style="color: #00d9ff;">ã€ŒğŸ”¨ éµåŒ é‹ªã€</strong>å¯ä»¥å¼·åŒ–æˆ–åˆ†è§£è£å‚™ã€‚</p>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            <h5 style="color: #00d9ff; margin-bottom: 10px;">â¬†ï¸ å¼·åŒ–è£å‚™</h5>
                            <p style="color: #7a8fb8; font-size: 0.9rem;">æ¶ˆè€—<strong style="color: #ffd700;">é‡‘å¹£</strong>å’Œ<strong style="color: #9c27b0;">å¼·åŒ–çŸ³</strong>,æå‡è£å‚™çš„å±¬æ€§å€¼ã€‚</p>
                            <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">æ¯æ¬¡å¼·åŒ–+1ç´š,å±¬æ€§æå‡5%</p>
                        </div>
                        <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            <h5 style="color: #00d9ff; margin-bottom: 10px;">â™»ï¸ åˆ†è§£è£å‚™</h5>
                            <p style="color: #7a8fb8; font-size: 0.9rem;">å°‡ä¸éœ€è¦çš„è£å‚™åˆ†è§£æˆ<strong style="color: #9c27b0;">ç¢ç‰‡</strong>å’Œ<strong style="color: #ff9800;">ææ–™</strong>ã€‚</p>
                            <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">å“è³ªè¶Šé«˜,ç²å¾—çš„ç¢ç‰‡è¶Šå¤š</p>
                        </div>
                    </div>
                </div>
                
                <!-- é€²éšç³»çµ± -->
                <div class="how-to-play-panel" id="panel-advanced" style="display: none;">
                    <h3 style="color: #00d9ff; text-align: center; margin-bottom: 20px;">ğŸŒŸ é€²éšç³»çµ±</h3>
                    
                    <h4 style="color: #00d9ff; margin-top: 20px;">ğŸ´ å¡ç‰Œç³»çµ±</h4>
                    <div style="background: rgba(156, 39, 176, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(156, 39, 176, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">æ“Šæ•—æ•µäººæœ‰æ©Ÿç‡æ‰è½<strong style="color: #9c27b0;">å¡ç‰Œ</strong>,è£å‚™å¾Œæä¾›æ°¸ä¹…è¢«å‹•åŠ æˆã€‚</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">ä½ å¯ä»¥åŒæ™‚è£å‚™<strong style="color: #00d9ff;">2å¼µå¡ç‰Œ</strong>,çµ„æˆä½ çš„å¥—ç‰Œã€‚</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">å¡ç‰Œå¯ä»¥ä½¿ç”¨<strong style="color: #9c27b0;">ç¢ç‰‡</strong>å‡ç´š,æå‡æ•ˆæœã€‚</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: è£å‚™åŒç³»åˆ—çš„å¡ç‰Œå¯ä»¥è§¸ç™¼<strong style="color: #ffd700;">å¥—ç‰Œæ•ˆæœ</strong>!</p>
                    </div>
                    
                    <h5 style="color: #9c27b0; margin-top: 15px;">âœ¨ å¡ç‰Œè©ç¶´ç³»çµ±</h5>
                    <div style="background: rgba(156, 39, 176, 0.08); padding: 12px; border-radius: 6px; margin: 10px 0;">
                        <p style="color: #7a8fb8; font-size: 0.9rem;">å¡ç‰Œæ‰è½æ™‚æœƒéš¨æ©Ÿé™„å¸¶<strong style="color: #ffd700;">è©ç¶´</strong>ï¼Œæä¾›é¡å¤–å±¬æ€§åŠ æˆï¼</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem; margin-top: 8px;">è©ç¶´æ•¸é‡å–æ±ºæ–¼å¡ç‰Œå“è³ªï¼š</p>
                        <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 5px; font-size: 0.85rem;">
                            <li><span style="color: #888;">æ™®é€š/ç²¾è‰¯</span>ï¼šç„¡è©ç¶´</li>
                            <li><span style="color: #4EA5FF;">ç¨€æœ‰</span>ï¼š1å€‹è©ç¶´</li>
                            <li><span style="color: #9c27b0;">å²è©©</span>ï¼š2å€‹è©ç¶´</li>
                            <li><span style="color: #ff9800;">å‚³èªª</span>ï¼š3å€‹è©ç¶´</li>
                            <li><span style="color: #ffd700;">æ°¸æ†</span>ï¼š4å€‹è©ç¶´</li>
                        </ul>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 10px 0;">
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <strong style="color: #ff6b6b;">âš”ï¸ æ”»æ“Šå‹</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.8rem;">ç‹‚æš´ã€è‡´å‘½ã€ç²¾æº–ã€ç ´ç”²ã€å—œè¡€</span>
                        </div>
                        <div style="background: rgba(78, 165, 255, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(78, 165, 255, 0.3);">
                            <strong style="color: #4EA5FF;">ğŸ›¡ï¸ é˜²ç¦¦å‹</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.8rem;">å …éŸŒã€å®ˆè­·ã€åæ“Šã€å†ç”Ÿã€ä¸å±ˆ</span>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <strong style="color: #ffd700;">âœ¨ ç‰¹æ®Šå‹</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.8rem;">å¹¸é‹ã€ç¥é€Ÿã€æ™ºæ…§ã€è²ªå©ªã€ç¶“é©—</span>
                        </div>
                    </div>
                    
                    <h5 style="color: #9c27b0; margin-top: 15px;">ğŸ”€ å¡ç‰Œèåˆç³»çµ±</h5>
                    <div style="background: rgba(255, 152, 0, 0.1); padding: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid rgba(255, 152, 0, 0.3);">
                        <p style="color: #7a8fb8; font-size: 0.9rem;">å°‡<strong style="color: #00d9ff;">3å¼µç›¸åŒçš„æ»¿ç´šå¡ç‰Œ</strong>èåˆæˆ<strong style="color: #ffd700;">1å¼µæ›´é«˜å“è³ªçš„å¡ç‰Œ</strong>ï¼</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem; margin-top: 8px;">èåˆè¦å‰‡ï¼š</p>
                        <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 5px; font-size: 0.85rem;">
                            <li>éœ€è¦3å¼µ<strong style="color: #00d9ff;">ç›¸åŒID</strong>çš„å¡ç‰Œ</li>
                            <li>æ‰€æœ‰å¡ç‰Œå¿…é ˆé”åˆ°<strong style="color: #00ff88;">æœ€é«˜ç­‰ç´š</strong></li>
                            <li>èåˆå¾Œå“è³ªæå‡ä¸€éšï¼ˆç¨€æœ‰â†’å²è©©â†’å‚³èªªâ†’æ°¸æ†ï¼‰</li>
                            <li>è©ç¶´ç¹¼æ‰¿ï¼š<strong style="color: #ffd700;">50%æ©Ÿç‡</strong>ç¹¼æ‰¿åŸè©ç¶´ + <strong style="color: #00ff88;">30%æ©Ÿç‡</strong>ç²å¾—æ–°è©ç¶´</li>
                            <li>æ°¸æ†éšå¡ç‰Œç„¡æ³•ç¹¼çºŒèåˆ</li>
                        </ul>
                        <p style="color: #888; font-size: 0.8rem; margin-top: 8px;">ğŸ’¡ æç¤º: åœ¨å¡ç‰Œç•Œé¢é»æ“Šã€ŒğŸ”€ èåˆã€æŒ‰éˆ•å³å¯é€²è¡Œèåˆï¼</p>
                    </div>
                    
                    <h5 style="color: #9c27b0; margin-top: 15px;">â™»ï¸ å¡ç‰Œå›æ”¶</h5>
                    <div style="background: rgba(244, 67, 54, 0.1); padding: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid rgba(244, 67, 54, 0.3);">
                        <p style="color: #7a8fb8; font-size: 0.9rem;">ä¸éœ€è¦çš„å¡ç‰Œå¯ä»¥å›æ”¶æˆ<strong style="color: #9c27b0;">ç¢ç‰‡</strong>ï¼Œç”¨æ–¼å‡ç´šå…¶ä»–å¡ç‰Œï¼</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem; margin-top: 8px;">å›æ”¶ç¢ç‰‡æ•¸é‡ï¼š</p>
                        <table style="width: 100%; border-collapse: collapse; margin-top: 8px; font-size: 0.85rem;">
                            <tr>
                                <td style="padding: 5px; color: #888;">æ™®é€š</td>
                                <td style="padding: 5px; color: #7a8fb8;">1 ç¢ç‰‡</td>
                                <td style="padding: 5px; color: #888;">ç²¾è‰¯</td>
                                <td style="padding: 5px; color: #7a8fb8;">3 ç¢ç‰‡</td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; color: #4EA5FF;">ç¨€æœ‰</td>
                                <td style="padding: 5px; color: #7a8fb8;">10 ç¢ç‰‡</td>
                                <td style="padding: 5px; color: #9c27b0;">å²è©©</td>
                                <td style="padding: 5px; color: #7a8fb8;">30 ç¢ç‰‡</td>
                            </tr>
                            <tr>
                                <td style="padding: 5px; color: #ff9800;">å‚³èªª</td>
                                <td style="padding: 5px; color: #7a8fb8;">100 ç¢ç‰‡</td>
                                <td style="padding: 5px; color: #ffd700;">æ°¸æ†</td>
                                <td style="padding: 5px; color: #7a8fb8;">300 ç¢ç‰‡</td>
                            </tr>
                        </table>
                        <p style="color: #888; font-size: 0.8rem; margin-top: 8px;">ğŸ’¡ æç¤º: åœ¨å¡ç‰Œç•Œé¢é»æ“Šã€Œâ™»ï¸ å›æ”¶ã€æŒ‰éˆ•é¸æ“‡è¦å›æ”¶çš„å¡ç‰Œï¼</p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ¾ éš¨å¾ç³»çµ±</h4>
                    <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">åœ¨å•†åº—è³¼è²·æˆ–ç‰¹æ®Šæ‰è½<strong style="color: #ff9800;">éš¨å¾</strong>,ç‰¢å€‘æœƒè·Ÿè‘—ä½ ä¸€èµ·æˆ°é¬¥!</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">éš¨å¾æä¾›<strong style="color: #00d9ff;">è¢«å‹•å±¬æ€§åŠ æˆ</strong>,ä¸¦ä¸”æœƒåœ¨æˆ°é¬¥ä¸­<strong style="color: #00d9ff;">ä¸»å‹•é‡‹æ”¾æŠ€èƒ½</strong>ã€‚</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">éš¨å¾å¯ä»¥é€éæˆ°é¬¥<strong style="color: #00ff88;">å‡ç´š</strong>,è®Šå¾—æ›´å¼·å¤§ã€‚</p>
                    </div>
                    
                    <h5 style="color: #ff9800; margin-top: 15px;">ğŸ› ï¸ éš¨å¾è£å‚™ç³»çµ±</h5>
                    <div style="background: rgba(78, 165, 255, 0.1); padding: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid rgba(78, 165, 255, 0.3);">
                        <p style="color: #7a8fb8; font-size: 0.9rem;">ç‚ºä½ çš„éš¨å¾è£å‚™<strong style="color: #4EA5FF;">å°ˆå±¬è£å‚™</strong>ï¼Œå¤§å¹…æå‡æˆ°é¬¥åŠ›ï¼</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem; margin-top: 8px;">è£å‚™ä¾†æºï¼š</p>
                        <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 5px; font-size: 0.85rem;">
                            <li>æ“Šæ•—æ€ªç‰©æœ‰æ©Ÿç‡æ‰è½</li>
                            <li>å“è³ªè¶Šé«˜ï¼Œæ‰è½æ©Ÿç‡è¶Šä½</li>
                            <li>é‡è¤‡è£å‚™æœƒè‡ªå‹•è½‰æ›ç‚º<strong style="color: #ffd700;">è£å‚™ç¢ç‰‡</strong></li>
                        </ul>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin: 10px 0;">
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <strong style="color: #ff6b6b;">âš”ï¸ æ”»æ“Šå‹è£å‚™</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.8rem;">æå‡æ”»æ“Šã€æš´æ“Šã€æš´å‚·</span><br>
                            <span style="color: #888; font-size: 0.75rem;">é¾çˆªã€æƒ¡é­”ä¹‹åˆƒç­‰</span>
                        </div>
                        <div style="background: rgba(78, 165, 255, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(78, 165, 255, 0.3);">
                            <strong style="color: #4EA5FF;">ğŸ›¡ï¸ é˜²ç¦¦å‹è£å‚™</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.8rem;">æå‡é˜²ç¦¦ã€ç”Ÿå‘½ã€æ¸›å‚·</span><br>
                            <span style="color: #888; font-size: 0.75rem;">è–ç›¾ã€é˜²ç¦¦æ ¸å¿ƒç­‰</span>
                        </div>
                        <div style="background: rgba(76, 175, 80, 0.1); padding: 10px; border-radius: 6px; border: 1px solid rgba(76, 175, 80, 0.3);">
                            <strong style="color: #4caf50;">ğŸ’š å›å¾©å‹è£å‚™</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.8rem;">æå‡ç”Ÿå‘½ã€å›å¾©ã€å¸è¡€</span><br>
                            <span style="color: #888; font-size: 0.75rem;">ç”Ÿå‘½è­·ç¬¦ã€æ²»ç™‚ä¹‹å¿ƒç­‰</span>
                        </div>
                    </div>
                    
                    <h5 style="color: #ff9800; margin-top: 15px;">âœ¨ çµ„åˆæ•ˆæœç³»çµ±</h5>
                    <div style="background: rgba(0, 255, 136, 0.1); padding: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid rgba(0, 255, 136, 0.3);">
                        <p style="color: #7a8fb8; font-size: 0.9rem;">éš¨å¾å’Œè£å‚™çš„<strong style="color: #ffd700;">é¡å‹çµ„åˆ</strong>æœƒè§¸ç™¼ç‰¹æ®Šæ•ˆæœï¼</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem; margin-top: 8px;">çµ„åˆé¡å‹ï¼š</p>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; font-size: 0.85rem;">
                        <div style="background: rgba(255, 215, 0, 0.08); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <strong style="color: #ffd700;">âš–ï¸ æ°¸æ†çµ„åˆ</strong><br>
                            <span style="color: #7a8fb8;">æ°¸æ†éšéš¨å¾ + ä»»æ„è£å‚™</span><br>
                            <span style="color: #00ff88;">æ”»+10% é˜²+10% è¡€+10%</span>
                        </div>
                        <div style="background: rgba(255, 107, 107, 0.08); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <strong style="color: #ff6b6b;">âš”ï¸ æ¥µé™æ”»å‹¢</strong><br>
                            <span style="color: #7a8fb8;">æ”»æ“Šéš¨å¾ + æ”»æ“Šè£å‚™</span><br>
                            <span style="color: #00ff88;">æ”»+15% æš´æ“Š+10%</span>
                        </div>
                        <div style="background: rgba(78, 165, 255, 0.08); padding: 10px; border-radius: 6px; border: 1px solid rgba(78, 165, 255, 0.3);">
                            <strong style="color: #4EA5FF;">ğŸ›¡ï¸ éµå£é˜²ç¦¦</strong><br>
                            <span style="color: #7a8fb8;">é˜²ç¦¦éš¨å¾ + é˜²ç¦¦è£å‚™</span><br>
                            <span style="color: #00ff88;">é˜²+15% æ¸›å‚·+10%</span>
                        </div>
                        <div style="background: rgba(76, 175, 80, 0.08); padding: 10px; border-radius: 6px; border: 1px solid rgba(76, 175, 80, 0.3);">
                            <strong style="color: #4caf50;">ğŸ’š ç”Ÿå‘½ä¹‹æº</strong><br>
                            <span style="color: #7a8fb8;">å›å¾©éš¨å¾ + å›å¾©è£å‚™</span><br>
                            <span style="color: #00ff88;">è¡€+15% å›å¾©+5%</span>
                        </div>
                        <div style="background: rgba(255, 152, 0, 0.08); padding: 10px; border-radius: 6px; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <strong style="color: #ff9800;">âš”ï¸ğŸ›¡ï¸ æ”»é˜²ä¸€é«”</strong><br>
                            <span style="color: #7a8fb8;">æ”»æ“Šéš¨å¾ + é˜²ç¦¦è£å‚™</span><br>
                            <span style="color: #00ff88;">æ”»+5% é˜²+5%</span>
                        </div>
                        <div style="background: rgba(233, 30, 99, 0.08); padding: 10px; border-radius: 6px; border: 1px solid rgba(233, 30, 99, 0.3);">
                            <strong style="color: #e91e63;">âš”ï¸ğŸ’š ç‹‚æˆ°å£«</strong><br>
                            <span style="color: #7a8fb8;">æ”»æ“Šéš¨å¾ + å›å¾©è£å‚™</span><br>
                            <span style="color: #00ff88;">æ”»+8% å¸è¡€+3%</span>
                        </div>
                    </div>
                    
                    <h5 style="color: #ff9800; margin-top: 15px;">â¬†ï¸ è£å‚™å‡ç´š</h5>
                    <div style="background: rgba(156, 39, 176, 0.1); padding: 12px; border-radius: 6px; margin: 10px 0; border: 1px solid rgba(156, 39, 176, 0.3);">
                        <p style="color: #7a8fb8; font-size: 0.9rem;">ä½¿ç”¨<strong style="color: #ffd700;">è£å‚™ç¢ç‰‡</strong>å‡ç´šè£å‚™ï¼Œæå‡æ•ˆæœï¼</p>
                        <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 5px; font-size: 0.85rem;">
                            <li>æœ€é«˜ç­‰ç´šï¼š<strong style="color: #00d9ff;">Lv.10</strong></li>
                            <li>æ¯ç´šæå‡ï¼š<strong style="color: #00ff88;">+10%</strong> æ•ˆæœ</li>
                            <li>å‡ç´šæ¶ˆè€—ï¼šç­‰ç´š Ã— 10 + 20 ç¢ç‰‡</li>
                        </ul>
                        <p style="color: #888; font-size: 0.8rem; margin-top: 8px;">ğŸ’¡ æç¤º: åœ¨éš¨å¾ç•Œé¢æŸ¥çœ‹è£å‚™æ”¶è—ä¸¦é€²è¡Œå‡ç´šï¼</p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ“‹ æ¯æ—¥ä»»å‹™</h4>
                    <div style="background: rgba(33, 150, 243, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(33, 150, 243, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">æ¯å¤©æœƒåˆ·æ–°<strong style="color: #2196f3;">5å€‹æ¯æ—¥ä»»å‹™</strong>,å®Œæˆå¾Œå¯ä»¥ç²å¾—è±åšçå‹µã€‚</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">ä»»å‹™é¡å‹åŒ…æ‹¬:æ“Šæ•—æ•µäººã€æ”¶é›†è£å‚™ã€ä½¿ç”¨æŠ€èƒ½ç­‰ã€‚</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: å®Œæˆæ‰€æœ‰ä»»å‹™å¯ä»¥ç²å¾—<strong style="color: #ffd700;">å®Œæˆåº¦çå‹µ</strong>!</p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ° å‰¯æœ¬ç³»çµ±</h4>
                    <p style="color: #7a8fb8;">æŒ‘æˆ°ç‰¹æ®Š<strong style="color: #ff9800;">å‰¯æœ¬</strong>ä¾†è¾²æŒ‡å®šçš„è³‡æº!</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;">
                        <div style="background: rgba(0, 217, 255, 0.08); padding: 12px; border-radius: 6px; border: 1px solid rgba(0, 217, 255, 0.3);">
                            <strong style="color: #00d9ff;">ğŸ¯ ä¿®ç…‰ä¹‹åœ°</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">ç²å¾—å¤§é‡ç¶“é©—å€¼</span>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.08); padding: 12px; border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <strong style="color: #ffd700;">ğŸ’° å¯¶è—æ´çªŸ</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">ç²å¾—å¤§é‡é‡‘å¹£</span>
                        </div>
                        <div style="background: rgba(255, 152, 0, 0.08); padding: 12px; border-radius: 6px; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <strong style="color: #ff9800;">âš”ï¸ éºè·¡æ¢ç´¢</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">ç²å¾—é«˜å“è³ªè£å‚™</span>
                        </div>
                        <div style="background: rgba(156, 39, 176, 0.08); padding: 12px; border-radius: 6px; border: 1px solid rgba(156, 39, 176, 0.3);">
                            <strong style="color: #9c27b0;">ğŸ’ è³‡æºç¤¦å ´</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">ç²å¾—ç¢ç‰‡å’Œææ–™</span>
                        </div>
                    </div>
                    <p style="color: #888; font-size: 0.85rem;">æ¯ç¨®å‰¯æœ¬æœ‰4å€‹é›£åº¦,é›£åº¦è¶Šé«˜çå‹µè¶Šå¥½!</p>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ’¤ é›¢ç·šæ”¶ç›Š</h4>
                    <div style="background: rgba(0, 255, 136, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 255, 136, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">é—œæ‰éŠæˆ²ä¹Ÿæœƒè‡ªå‹•ç´¯ç©æ”¶ç›Š!</p>
                        <p style="color: #7a8fb8; margin-top: 10px;">ä¸‹æ¬¡ä¸Šç·šæ™‚æœƒå½ˆå‡º<strong style="color: #00ff88;">é›¢ç·šæ”¶ç›Šè¦–çª—</strong>,é¡¯ç¤ºä½ ç²å¾—çš„ç¶“é©—ã€é‡‘å¹£ã€è£å‚™ç­‰ã€‚</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: é›¢ç·šæ”¶ç›Šæœ‰ä¸Šé™,è¨˜å¾—å®šæœŸä¸Šç·šé ˜å–!</p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ“– åœ–é‘‘ç³»çµ±</h4>
                    <p style="color: #7a8fb8;">æ”¶é›†æ€ªç‰©ã€è£å‚™ã€éš¨å¾ã€å¡ç‰‡çš„è³‡è¨Šï¼Œè§£é–<strong style="color: #ffd700;">ç¨±è™Ÿ</strong>å’Œ<strong style="color: #00ff88;">çå‹µ</strong>ï¼</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin: 15px 0;">
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <h5 style="color: #ff6b6b; margin-bottom: 8px;">ğŸ‘¾ æ€ªç‰©åœ–é‘‘</h5>
                            <p style="color: #7a8fb8; font-size: 0.85rem;">è¨˜éŒ„æ“Šæ•—æ•¸é‡ï¼Œé”åˆ°<strong style="color: #00d9ff;">1000æ®º</strong>è§£é–çå‹µï¼</p>
                            <p style="color: #888; font-size: 0.75rem; margin-top: 5px;">â€¢ æ™®é€šæ€ªç‰©ï¼š32ç¨®
<br>â€¢ ç²¾è‹±æ€ªç‰©ï¼š16ç¨®
<br>â€¢ Bossï¼š5ç¨®</p>
                        </div>
                        <div style="background: rgba(156, 39, 176, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(156, 39, 176, 0.3);">
                            <h5 style="color: #9c27b0; margin-bottom: 8px;">ğŸ›¡ï¸ è£å‚™åœ–é‘‘</h5>
                            <p style="color: #7a8fb8; font-size: 0.85rem;">è¨˜éŒ„ç²å¾—çš„è£å‚™ï¼Œæ”¶é›†<strong style="color: #00d9ff;">å¥—è£</strong>è§£é–ç¨±è™Ÿï¼</p>
                            <p style="color: #888; font-size: 0.75rem; margin-top: 5px;">â€¢ 4å€‹å€åŸŸ
<br>â€¢ æ¯å€åŸŸ2å¥—è£
<br>â€¢ æ”¶é›†çå‹µç¨±è™Ÿ</p>
                        </div>
                        <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <h5 style="color: #ff9800; margin-bottom: 8px;">ğŸ¾ éš¨å¾åœ–é‘‘</h5>
                            <p style="color: #7a8fb8; font-size: 0.85rem;">æ”¶é›†éš¨å¾ï¼Œè§£é–<strong style="color: #00d9ff;">é¡å‹å°ˆå®¶</strong>ç¨±è™Ÿï¼</p>
                            <p style="color: #888; font-size: 0.75rem; margin-top: 5px;">â€¢ æ”¶é›†5/10/15/20å€‹
<br>â€¢ æ”»æ“Š/é˜²ç¦¦/æ¢å¾©/å¹³è¡¡
<br>â€¢ ç¨±è™ŸåŠ æˆ</p>
                        </div>
                        <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3);">
                            <h5 style="color: #667eea; margin-bottom: 8px;">ğŸ´ å¡ç‰‡åœ–é‘‘</h5>
                            <p style="color: #7a8fb8; font-size: 0.85rem;">æ”¶é›†å¡ç‰‡ï¼Œè§£é–<strong style="color: #00d9ff;">æ”¶è—å®¶</strong>ç¨±è™Ÿï¼</p>
                            <p style="color: #888; font-size: 0.75rem; margin-top: 5px;">â€¢ æ”¶é›†10/20/30/40å¼µ
<br>â€¢ ç¨±è™Ÿå±¬æ€§åŠ æˆ
<br>â€¢ å±•ç¤ºæ”¶è—</p>
                        </div>
                    </div>
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); margin: 15px 0;">
                        <p style="color: #ffd700; font-weight: bold; margin-bottom: 8px;">ğŸ† åœ–é‘‘çå‹µ</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ æ€ªç‰©1000æ®ºï¼š<strong style="color: #00d9ff;">å¼·åŒ–çŸ³ x50</strong> + <strong style="color: #ffd700;">ç¨±è™Ÿ</strong></p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ å¥—è£æ”¶é›†ï¼š<strong style="color: #ffd700;">ç¨±è™Ÿ</strong> + <strong style="color: #00ff88;">å±¬æ€§åŠ æˆ</strong></p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ éš¨å¾æ”¶é›†ï¼š<strong style="color: #ffd700;">ç¨±è™Ÿ</strong> + <strong style="color: #00ff88;">ç‰¹æ®Šæ•ˆæœ</strong></p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ å¡ç‰‡æ”¶é›†ï¼š<strong style="color: #ffd700;">ç¨±è™Ÿ</strong> + <strong style="color: #00ff88;">å±¬æ€§åŠ æˆ</strong></p>
                    </div>
                    <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: é»æ“Šä¸»ç•Œé¢çš„<strong style="color: #00d9ff;">ã€ŒğŸ“– åœ–é‘‘ã€</strong>æŒ‰éˆ•æŸ¥çœ‹æ”¶é›†é€²åº¦ï¼</p>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">âš™ï¸ è‡ªå‹•è£å‚™èˆ‡åˆ†è§£</h4>
                    <p style="color: #7a8fb8;">æ™ºèƒ½ç®¡ç†è£å‚™ï¼Œç¯€çœæ™‚é–“ï¼Œè®“ä½ å°ˆæ³¨æ–¼æˆ°é¬¥ï¼</p>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 15px 0;">
                        <div style="background: rgba(0, 255, 136, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 255, 136, 0.3);">
                            <h5 style="color: #00ff88; margin-bottom: 10px;">ğŸ¯ è‡ªå‹•è£å‚™</h5>
                            <p style="color: #7a8fb8; font-size: 0.9rem;">ç²å¾—æ–°è£å‚™æ™‚è‡ªå‹•æ¯”è¼ƒè©•åˆ†ï¼Œå¦‚æœæ›´å¥½å‰‡<strong style="color: #00d9ff;">è‡ªå‹•è£å‚™</strong>ï¼</p>
                            <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 10px; font-size: 0.85rem;">
                                <li>ç¶œåˆè©•åˆ†ç³»çµ±</li>
                                <li>è€ƒæ…®å¥—è£æ•ˆæœ</li>
                                <li>æ™ºèƒ½é¸æ“‡æ§½ä½</li>
                            </ul>
                        </div>
                        <div style="background: rgba(244, 67, 54, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(244, 67, 54, 0.3);">
                            <h5 style="color: #f44336; margin-bottom: 10px;">ğŸ”§ è‡ªå‹•åˆ†è§£</h5>
                            <p style="color: #7a8fb8; font-size: 0.9rem;">è‡ªå‹•åˆ†è§£ä½å“è³ªè£å‚™ï¼Œç²å¾—<strong style="color: #00d9ff;">å¼·åŒ–çŸ³</strong>ææ–™ï¼</p>
                            <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 10px; font-size: 0.85rem;">
                                <li>å¯é¸å“è³ªï¼ˆæ™®é€š/ç²¾è‰¯/ç¨€æœ‰ï¼‰</li>
                                <li>ä¿è­·å¥—è£è£å‚™</li>
                                <li>èƒŒåŒ…æ»¿æ™‚è‡ªå‹•åˆ†è§£</li>
                            </ul>
                        </div>
                    </div>
                    <div style="background: rgba(168, 237, 234, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(168, 237, 234, 0.3); margin: 15px 0;">
                        <p style="color: #a8edea; font-weight: bold; margin-bottom: 8px;">ğŸ› ï¸ å¦‚ä½•ä½¿ç”¨</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">1. é»æ“Šä¸»ç•Œé¢çš„<strong style="color: #00d9ff;">ã€Œâš™ï¸ è‡ªå‹•ã€</strong>æŒ‰éˆ•</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">2. å•Ÿç”¨<strong style="color: #00ff88;">è‡ªå‹•è£å‚™</strong>å’Œ<strong style="color: #f44336;">è‡ªå‹•åˆ†è§£</strong></p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">3. é¸æ“‡è¦åˆ†è§£çš„è£å‚™å“è³ª</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">4. è¨­ç½®ä¿è­·è¦å‰‡ï¼ˆå¥—è£ã€è€ƒæ…®å¥—è£æ•ˆæœï¼‰</p>
                    </div>
                    <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: è‡ªå‹•åŠŸèƒ½å¯ä»¥éš¨æ™‚é–‹é—œï¼Œä¸¦ä¸”æœƒé¡¯ç¤ºè©³ç´°çš„çµ±è¨ˆè³‡è¨Šï¼</p>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ—ºï¸ å€åŸŸæ¢ç´¢</h4>
                    <p style="color: #7a8fb8;">éŠæˆ²æœ‰<strong style="color: #00d9ff;">4å€‹å€åŸŸ</strong>,ç­‰ç´šè¶Šé«˜,å¯ä»¥æ¢ç´¢æ›´é«˜ç´šçš„å€åŸŸ!</p>
                    <table style="width: 100%; border-collapse: collapse; margin: 15px 0; background: rgba(0, 217, 255, 0.05);">
                        <thead>
                            <tr style="background: rgba(0, 217, 255, 0.15);">
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">å€åŸŸ</th>
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">ç­‰ç´šéœ€æ±‚</th>
                                <th style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.3); color: #00d9ff;">çå‹µå€ç‡</th>
                            </tr>
                        </thead>
                        <tbody style="color: #7a8fb8;">
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">ğŸ”° å…¥é–€é–‹ç™¼å±¤</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Lv.1+</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Ã—1.0</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">âš—ï¸ ç ”ç™¼æ ¸å¿ƒå±¤</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Lv.26+</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Ã—1.3</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">ğŸ–¥ï¸ è³‡æ–™è£‚éš™</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Lv.51+</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Ã—1.7</td>
                            </tr>
                            <tr>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">âš›ï¸ æ·±äº•è‡¨ç•Œå±¤</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Lv.76+</td>
                                <td style="padding: 10px; border: 1px solid rgba(0, 217, 255, 0.2);">Ã—2.3</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- è¿­ä»£èˆ‡å¤©è³¦ -->
                <div class="how-to-play-panel" id="panel-prestige" style="display: none;">
                    <h3 style="color: #00d9ff; text-align: center; margin-bottom: 20px;">ğŸ”„ è¿­ä»£èˆ‡å¤©è³¦</h3>
                    
                    <h4 style="color: #00d9ff; margin-top: 20px;">ğŸ”„ ä»€éº¼æ˜¯è¿­ä»£?</h4>
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8; font-size: 1.05rem;">ç•¶ä½ é”åˆ°<strong style="color: #ffd700;">100ç´š</strong>ä¸¦å®Œæˆæ‰€æœ‰ä¸»ç·šBosså¾Œ,å¯ä»¥é¸æ“‡<strong style="color: #00d9ff;">è¿­ä»£</strong>ã€‚</p>
                        <p style="color: #7a8fb8; margin-top: 15px;">è¿­ä»£å¾Œ,ä½ çš„<strong style="color: #f44336;">ç­‰ç´šã€è£å‚™ã€é‡‘å¹£</strong>æœƒé‡ç½®,ä½†ä½ æœƒç²å¾—<strong style="color: #ffd700;">æ°¸ä¹…çš„å¼·åŒ–</strong>!</p>
                        <p style="color: #7a8fb8; margin-top: 15px; font-size: 1.1rem; text-align: center;"><strong style="color: #00ff88;">é€™æ˜¯éŠæˆ²çš„æ ¸å¿ƒé•·æœŸç›®æ¨™!</strong></p>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ è¿­ä»£çå‹µ</h4>
                    <div style="display: grid; grid-template-columns: 1fr; gap: 15px; margin: 15px 0;">
                        <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <h5 style="color: #ffd700; margin-bottom: 10px;">ğŸ’ è¿­ä»£é»æ•¸(IP)</h5>
                            <p style="color: #7a8fb8; font-size: 0.95rem;">æ ¹æ“šä½ çš„<strong style="color: #00d9ff;">ç­‰ç´šã€æ“Šæ•—æ•¸ã€å‚³èªªè£å‚™æ•¸é‡</strong>ç­‰è¨ˆç®—ç²å¾—çš„IPé»æ•¸ã€‚</p>
                            <p style="color: #7a8fb8; margin-top: 8px;">IPå¯ä»¥ç”¨ä¾†å­¸ç¿’<strong style="color: #00d9ff;">å¤©è³¦</strong>,ç²å¾—æ°¸ä¹…åŠ æˆ!</p>
                        </div>
                        <div style="background: rgba(156, 39, 176, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(156, 39, 176, 0.3);">
                            <h5 style="color: #9c27b0; margin-bottom: 10px;">ğŸ’ ç¢ç‰‡ä¿ç•™</h5>
                            <p style="color: #7a8fb8; font-size: 0.95rem;">æ ¹æ“šè¿­ä»£æ¬¡æ•¸,ä¿ç•™ä¸€å®šæ¯”ä¾‹çš„<strong style="color: #9c27b0;">ç¢ç‰‡</strong>åˆ°ä¸‹ä¸€è¼ªã€‚</p>
                            <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">ç¬¬1æ¬¡è¿­ä»£ä¿ç•™10%,ä¹‹å¾Œæ¯æ¬¡+5%,æœ€é«˜25%</p>
                        </div>
                        <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.3);">
                            <h5 style="color: #ff9800; margin-bottom: 10px;">ğŸ† è¿­ä»£ç¨±è™Ÿ</h5>
                            <p style="color: #7a8fb8; font-size: 0.95rem;">æ¯æ¬¡è¿­ä»£è§£é–æ–°<strong style="color: #ff9800;">ç¨±è™Ÿ</strong>,è£å‚™å¾Œæä¾›æ°¸ä¹…å±¬æ€§åŠ æˆã€‚</p>
                            <p style="color: #888; font-size: 0.85rem; margin-top: 8px;">ä¾‹å¦‚:ã€Œåˆæ¬¡è¿­ä»£è€…ã€ã€ã€Œè¿­ä»£å¤§å¸«ã€ç­‰</p>
                        </div>
                    </div>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">âœ¨ å¤©è³¦ç³»çµ±</h4>
                    <p style="color: #7a8fb8;">ä½¿ç”¨<strong style="color: #ffd700;">è¿­ä»£é»æ•¸(IP)</strong>åœ¨å¤©è³¦æ¨¹ä¸­å­¸ç¿’å¼·å¤§çš„æ°¸ä¹…è¢«å‹•æ•ˆæœ!</p>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin: 15px 0;">
                        <div style="background: rgba(255, 107, 107, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.3);">
                            <strong style="color: #ff6b6b;">âš”ï¸ æˆ°é¬¥å¤©è³¦</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">æå‡æ”»æ“Šã€æš´æ“Šã€æš´å‚·</span>
                        </div>
                        <div style="background: rgba(33, 150, 243, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(33, 150, 243, 0.3);">
                            <strong style="color: #2196f3;">ğŸ›¡ï¸ é˜²ç¦¦å¤©è³¦</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">æå‡ç”Ÿå‘½ã€é˜²ç¦¦ã€æ¸›å‚·</span>
                        </div>
                        <div style="background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(255, 215, 0, 0.3);">
                            <strong style="color: #ffd700;">ğŸ’° è³‡æºå¤©è³¦</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">å¢åŠ é‡‘å¹£ã€ç¶“é©—ã€æ‰è½</span>
                        </div>
                        <div style="background: rgba(156, 39, 176, 0.1); padding: 12px; border-radius: 6px; border: 1px solid rgba(156, 39, 176, 0.3);">
                            <strong style="color: #9c27b0;">âœ¨ ç‰¹æ®Šå¤©è³¦</strong><br>
                            <span style="color: #7a8fb8; font-size: 0.85rem;">è§£é–ç‰¹æ®Šèƒ½åŠ›</span>
                        </div>
                    </div>
                    <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ æç¤º: å¤©è³¦æ•ˆæœ<strong style="color: #00ff88;">æ°¸ä¹…ç”Ÿæ•ˆ</strong>,å³ä½¿è¿­ä»£ä¹Ÿä¸æœƒæ¶ˆå¤±!</p>
                    
                    <h4 style="color: #00d9ff; margin-top: 25px;">ğŸ† ç¨±è™Ÿç³»çµ±</h4>
                    <p style="color: #7a8fb8;">å®Œæˆç‰¹å®šæˆå°±è§£é–<strong style="color: #ff9800;">ç¨±è™Ÿ</strong>,è£å‚™å¾Œç²å¾—æ°¸ä¹…å±¬æ€§åŠ æˆ!</p>
                    <div style="background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.3); margin: 15px 0;">
                        <p style="color: #7a8fb8;">ç¨±è™Ÿåˆ†ç‚ºå¤šå€‹ç³»åˆ—:</p>
                        <ul style="color: #7a8fb8; margin-left: 20px; margin-top: 10px; font-size: 0.9rem;">
                            <li><strong style="color: #00d9ff;">ğŸ”„ è¿­ä»£è€…ç³»åˆ—</strong>: å®Œæˆè¿­ä»£è§£é–</li>
                            <li><strong style="color: #ff6b6b;">âš”ï¸ æˆ°é¬¥ç³»åˆ—</strong>: æ“Šæ•—å¤§é‡æ•µäººè§£é–</li>
                            <li><strong style="color: #ffd700;">ğŸ’° è²¡å¯Œç³»åˆ—</strong>: ç´¯ç©é‡‘å¹£è§£é–</li>
                            <li><strong style="color: #9c27b0;">ğŸ—ºï¸ æ¢ç´¢ç³»åˆ—</strong>: æ¢ç´¢å€åŸŸè§£é–</li>
                            <li><strong style="color: #667eea;">ğŸ“– åœ–é‘‘ç³»åˆ—</strong>: æ”¶é›†æ€ªç‰©/è£å‚™/éš¨å¾/å¡ç‰‡è§£é–</li>
                        </ul>
                    </div>
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(102, 126, 234, 0.3); margin: 15px 0;">
                        <p style="color: #667eea; font-weight: bold; margin-bottom: 8px;">ğŸ“– åœ–é‘‘ç¨±è™Ÿï¼ˆæ–°ï¼ï¼‰</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ <strong style="color: #ff6b6b;">æ€ªç‰©1000æ®º</strong>ï¼š53å€‹ç¨±è™Ÿï¼ˆæ™®é€š32 + ç²¾è‰16 + Boss5ï¼‰</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ <strong style="color: #9c27b0;">å¥—è£æ”¶é›†</strong>ï¼š6å€‹ç¨±è™Ÿï¼ˆç¸½æ”¶é›† + å€åŸŸå¥—è£ï¼‰</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ <strong style="color: #ff9800;">éš¨å¾æ”¶é›†</strong>ï¼š8å€‹ç¨±è™Ÿï¼ˆé€²åº¦ + é¡å‹å°ˆå®¶ï¼‰</p>
                        <p style="color: #7a8fb8; font-size: 0.9rem;">â€¢ <strong style="color: #667eea;">å¡ç‰‡æ”¶é›†</strong>ï¼š4å€‹ç¨±è™Ÿï¼ˆæ”¶è—å®¶ç³»åˆ—ï¼‰</p>
                        <p style="color: #888; font-size: 0.85rem; margin-top: 10px;">ğŸ’¡ å…±<strong style="color: #ffd700;">71å€‹åœ–é‘‘ç¨±è™Ÿ</strong>ç­‰ä½ è§£é–ï¼</p>
                    </div>
                    
                    <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.15) 0%, rgba(255, 152, 0, 0.15) 100%); padding: 20px; border-radius: 10px; border: 2px solid rgba(255, 215, 0, 0.5); margin-top: 25px;">
                        <h4 style="color: #ffd700; text-align: center; margin-bottom: 10px;">âš ï¸ è¿­ä»£æ³¨æ„äº‹é …</h4>
                        <p style="color: #f44336; text-align: center; font-size: 1.05rem; margin-bottom: 15px;"><strong>è¿­ä»£å°‡é‡ç½®:</strong> ç­‰ç´šã€ç¶“é©—ã€é‡‘å¹£ã€æ‰€æœ‰è£å‚™å’Œç‰©å“ã€å€åŸŸé€²åº¦</p>
                        <p style="color: #00ff88; text-align: center; font-size: 1.05rem;"><strong>è¿­ä»£ä¿ç•™:</strong> è¿­ä»£é»æ•¸ã€å¤©è³¦ã€ç¨±è™Ÿã€éƒ¨åˆ†ç¢ç‰‡</p>
                    </div>
                </div>
                
            </div>
            
            <button onclick="closeHowToPlay()" style="margin-top: 20px; width: 100%; padding: 15px; font-size: 1.1rem;">é—œé–‰</button>
        </div>
    </div>
    
    <script>
        // Tab åˆ‡æ›åŠŸèƒ½
        function switchHowToPlayTab(tabName) {
            // éš±è—æ‰€æœ‰é¢æ¿
            const panels = document.querySelectorAll('.how-to-play-panel');
            panels.forEach(panel => panel.style.display = 'none');
            
            // é¡¯ç¤ºé¸ä¸­çš„é¢æ¿
            document.getElementById('panel-' + tabName).style.display = 'block';
            
            // æ›´æ–°Tabæ¨£å¼
            const tabs = document.querySelectorAll('.how-to-play-tab');
            tabs.forEach(tab => {
                if (tab.getAttribute('data-tab') === tabName) {
                    tab.classList.add('active');
                    tab.style.background = 'linear-gradient(135deg, #00d9ff 0%, #4EA5FF 100%)';
                    tab.style.border = 'none';
                    tab.style.color = '#000';
                    tab.style.fontWeight = 'bold';
                } else {
                    tab.classList.remove('active');
                    tab.style.background = 'rgba(0, 217, 255, 0.2)';
                    tab.style.border = '1px solid rgba(0, 217, 255, 0.3)';
                    tab.style.color = '#e0e6ff';
                    tab.style.fontWeight = 'normal';
                }
            });
        }
    </script>

    <!-- è¿­ä»£ç¢ºèªæ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="iteration-modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>ğŸ”„ è¿­ä»£ç¢ºèª</h2>
            <p style="color: #4EA5FF; font-size: 1.1rem; margin: 15px 0;">ä½ å³å°‡é€²è¡Œç¬¬ <span id="iteration-next-count" style="font-weight: bold; color: #FFD700;">1</span> æ¬¡è¿­ä»£</p>
            
            <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin: 15px 0;">
                <h3 style="color: #00d9ff; margin: 0 0 10px 0;">ğŸ“Š ç•¶å‰ç‹€æ…‹</h3>
                <div style="color: #7a8fb8; font-size: 0.95rem;">
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>ç­‰ç´š</span>
                        <span style="color: #00d9ff; font-weight: bold;" id="iteration-current-level">100</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>æ“Šæ•—æ•¸</span>
                        <span style="color: #00d9ff; font-weight: bold;" id="iteration-current-kills">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>å‚³èªªè£å‚™</span>
                        <span style="color: #f44336; font-weight: bold;" id="iteration-current-legendary">0</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>ç¢ç‰‡</span>
                        <span style="color: #4EA5FF; font-weight: bold;" id="iteration-current-shards">0</span>
                    </div>
                </div>
            </div>
            
            <div style="background: rgba(255, 215, 0, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); margin: 15px 0;">
                <h3 style="color: #FFD700; margin: 0 0 10px 0;">ğŸ è¿­ä»£çå‹µ</h3>
                <div style="color: #7a8fb8; font-size: 0.95rem;">
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>è¿­ä»£é»æ•¸</span>
                        <span style="color: #FFD700; font-weight: bold;" id="iteration-reward-ip">+0 IP</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>ä¿ç•™ç¢ç‰‡</span>
                        <span style="color: #4EA5FF; font-weight: bold;" id="iteration-reward-shards">0 (0%)</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span>ç¨±è™Ÿ</span>
                        <span style="color: #00d9ff; font-weight: bold;" id="iteration-reward-title">ğŸ”„ åˆæ¬¡è¿­ä»£è€…</span>
                    </div>
                </div>
            </div>
            
            <div style="background: rgba(255, 68, 68, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 68, 68, 0.3); margin: 15px 0;">
                <h3 style="color: #f44336; margin: 0 0 10px 0;">âš ï¸ è­¦å‘Š</h3>
                <p style="color: #7a8fb8; font-size: 0.9rem; margin: 5px 0;">ä»¥ä¸‹å…§å®¹å°‡è¢«é‡ç½®ï¼š</p>
                <ul style="color: #f44336; font-size: 0.9rem; margin: 10px 0 0 20px;">
                    <li>ç­‰ç´šã€ç¶“é©—ã€é‡‘å¹£</li>
                    <li>æ‰€æœ‰è£å‚™å’Œç‰©å“</li>
                    <li>å€åŸŸé€²åº¦</li>
                    <li>è‡¨æ™‚å¢ç›Š</li>
                </ul>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="confirmIteration()" style="flex: 1; background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color: #000; font-weight: bold;">ç¢ºèªè¿­ä»£</button>
                <button onclick="closeIterationModal()" style="flex: 1;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- æŠ€èƒ½é¸æ“‡æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="skill-selection-modal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2>âš¡ æŠ€èƒ½é¸æ“‡</h2>
            <p style="color: #7a8fb8; text-align: center; margin: 15px 0;">å¾ä»¥ä¸‹10å€‹æŠ€èƒ½ä¸­é¸æ“‡ä¸€å€‹ä½œç‚ºä½ çš„å°ˆå±¬æŠ€èƒ½</p>
            
            <div id="skill-modal-cards" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 20px 0;">
                <!-- æŠ€èƒ½å¡ç‰‡å°‡ç”± JavaScript ç”Ÿæˆ -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="confirmSkillSelection()" style="flex: 2;">âœ… ç¢ºèªé¸æ“‡</button>
                <button onclick="closeSkillSelectionModal()" style="flex: 1;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- å¤©è³½æ¨¹æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="talents-modal">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <h2>âœ¨ è¿­ä»£å¤©è³¦</h2>
            <div style="display: flex; justify-content: space-between; align-items: center; margin: 15px 0; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3);">
                <div>
                    <span style="color: #7a8fb8;">è¿­ä»£æ¬¡æ•¸ï¼š</span>
                    <span id="talents-iteration-count" style="color: #FFD700; font-weight: bold;">0</span>
                </div>
                <div>
                    <span style="color: #7a8fb8;">å¯ç”¨é»æ•¸ï¼š</span>
                    <span id="talents-available-ip" style="color: #4EA5FF; font-weight: bold; font-size: 1.2rem;">0</span>
                    <span style="color: #7a8fb8;"> IP</span>
                </div>
                <div>
                    <span style="color: #7a8fb8;">ç¸½é»æ•¸ï¼š</span>
                    <span id="talents-total-ip" style="color: #888; font-weight: bold;">0</span>
                    <span style="color: #7a8fb8;"> IP</span>
                </div>
            </div>
            
            <!-- å¤©è³¦ç³»åˆ—åˆ†é  -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                <button onclick="switchTalentTab('combat')" id="talent-tab-combat" class="talent-tab active" style="flex: 1; min-width: 120px;">âš”ï¸ æˆ°é¬¥</button>
                <button onclick="switchTalentTab('defense')" id="talent-tab-defense" class="talent-tab" style="flex: 1; min-width: 120px;">ğŸ›¡ï¸ é˜²ç¦¦</button>
                <button onclick="switchTalentTab('resource')" id="talent-tab-resource" class="talent-tab" style="flex: 1; min-width: 120px;">ğŸ’° è³‡æº</button>
                <button onclick="switchTalentTab('special')" id="talent-tab-special" class="talent-tab" style="flex: 1; min-width: 120px;">âœ¨ ç‰¹æ®Š</button>
            </div>
            
            <!-- å¤©è³¦å…§å®¹å€åŸŸ -->
            <div id="talents-content" style="min-height: 300px;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="closeTalentsModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- æ¯æ—¥ä»»å‹™æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="daily-quests-modal">
        <div class="modal-content" style="max-width: 700px;">
            <h2>ğŸ“‹ æ¯æ—¥ä»»å‹™</h2>
            
            <!-- ä»»å‹™çµ±è¨ˆ -->
            <div style="background: rgba(0, 217, 255, 0.08); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px; display: flex; justify-content: space-around; text-align: center;">
                <div>
                    <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 3px;">ä»Šæ—¥å®Œæˆ</div>
                    <div style="font-size: 1.3rem; font-weight: bold; color: #4EA5FF;">
                        <span id="quests-completed-today">0</span><span style="color: #888;">/5</span>
                    </div>
                </div>
                <div>
                    <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 3px;">ä¸‹æ¬¡é‡ç½®</div>
                    <div style="font-size: 1rem; font-weight: bold; color: #FFD700;" id="quests-reset-time">
                        --:--:--
                    </div>
                </div>
            </div>
            
            <!-- ä»»å‹™åˆ—è¡¨ -->
            <div id="daily-quests-list" style="display: flex; flex-direction: column; gap: 10px; min-height: 300px;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="closeDailyQuestsModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- åœ–é‘‘æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="codex-modal">
        <div class="modal-content" style="max-width: 900px;">
            <h2>ğŸ“– åœ–é‘‘ç³»çµ±</h2>
            
            <!-- åˆ†é æ¨™ç±¤ -->
            <div style="display: flex; gap: 8px; margin-bottom: 15px; border-bottom: 2px solid rgba(0, 217, 255, 0.3); padding-bottom: 10px;">
                <button id="codex-tab-monsters" onclick="switchCodexTab('monsters')" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold;">ğŸ‘¹ æ€ªç‰©</button>
                <button id="codex-tab-equipment" onclick="switchCodexTab('equipment')" style="flex: 1; padding: 10px; background: rgba(255, 255, 255, 0.1); border: none; border-radius: 8px; color: #7a8fb8; cursor: pointer;">ğŸ—¡ï¸ è£å‚™</button>
                <button id="codex-tab-companions" onclick="switchCodexTab('companions')" style="flex: 1; padding: 10px; background: rgba(255, 255, 255, 0.1); border: none; border-radius: 8px; color: #7a8fb8; cursor: pointer;">ğŸ¾ éš¨å¾</button>
                <button id="codex-tab-cards" onclick="switchCodexTab('cards')" style="flex: 1; padding: 10px; background: rgba(255, 255, 255, 0.1); border: none; border-radius: 8px; color: #7a8fb8; cursor: pointer;">ğŸ´ å¡ç‰Œ</button>
            </div>
            
            <!-- ç¸½é€²åº¦é¡¯ç¤º -->
            <div id="codex-progress" style="background: rgba(0, 217, 255, 0.08); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">ç¸½é€²åº¦</div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div id="codex-progress-text" style="font-size: 1.1rem; font-weight: bold; color: #00d9ff;">0/0 (0%)</div>
                    <div id="codex-progress-bar-container" style="flex: 1; margin-left: 15px; background: rgba(0, 0, 0, 0.3); height: 20px; border-radius: 10px; overflow: hidden;">
                        <div id="codex-progress-bar" style="height: 100%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                </div>
            </div>
            
            <!-- å…§å®¹å€åŸŸ -->
            <div id="codex-content" style="max-height: 500px; overflow-y: auto; padding: 10px;">
                <!-- å…§å®¹å°‡ç”± JavaScript å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button onclick="closeCodexModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- ç¨±è™Ÿæ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="titles-modal">
        <div class="modal-content" style="max-width: 800px;">
            <h2>ğŸ† ç¨±è™Ÿç³»çµ±</h2>
            
            <!-- ç•¶å‰è£å‚™ç¨±è™Ÿ -->
            <div style="background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.4); margin-bottom: 15px;">
                <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">ç•¶å‰ç¨±è™Ÿ</div>
                <div id="current-title-display" style="font-size: 1.2rem; font-weight: bold; color: #FFD700;">
                    ç„¡
                </div>
                <div id="current-title-bonus" style="font-size: 0.9rem; color: #4EA5FF; margin-top: 3px;">
                    <!-- å‹•æ…‹é¡¯ç¤ºç¨±è™ŸåŠ æˆ -->
                </div>
            </div>
            
            <!-- ç¨±è™Ÿåˆ†é¡åˆ†é  -->
            <div style="display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap;">
                <button onclick="switchTitleCategory('all')" id="title-cat-all" class="title-category-tab active" style="flex: 1; min-width: 80px;">ğŸŒ å…¨éƒ¨</button>
                <button onclick="switchTitleCategory('combat')" id="title-cat-combat" class="title-category-tab" style="flex: 1; min-width: 80px;">âš”ï¸ æˆ°é¬¥</button>
                <button onclick="switchTitleCategory('collection')" id="title-cat-collection" class="title-category-tab" style="flex: 1; min-width: 80px;">ğŸ“¦ æ”¶é›†</button>
                <button onclick="switchTitleCategory('achievement')" id="title-cat-achievement" class="title-category-tab" style="flex: 1; min-width: 80px;">ğŸ† æˆå°±</button>
                <button onclick="switchTitleCategory('exploration')" id="title-cat-exploration" class="title-category-tab" style="flex: 1; min-width: 80px;">ğŸ—ºï¸ æ¢ç´¢</button>
                <button onclick="switchTitleCategory('special')" id="title-cat-special" class="title-category-tab" style="flex: 1; min-width: 80px;">âœ¨ ç‰¹æ®Š</button>
                <button onclick="switchTitleCategory('codex')" id="title-cat-codex" class="title-category-tab" style="flex: 1; min-width: 80px;">ğŸ“– åœ–é‘‘</button>
            </div>
            
            <!-- ç¨±è™Ÿå…§å®¹å€åŸŸ -->
            <div id="titles-content" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; min-height: 300px;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="closeTitlesModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- å‰¯æœ¬æŒ‘æˆ°æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="dungeons-modal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2>ğŸ° å‰¯æœ¬æŒ‘æˆ°</h2>
            
            <!-- APé¡¯ç¤º -->
            <div style="background: rgba(78, 165, 255, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(78, 165, 255, 0.4); margin-bottom: 15px; text-align: center;">
                <span style="color: #7a8fb8;">ç•¶å‰APï¼š</span>
                <span id="dungeon-ap-display" style="color: #4EA5FF; font-weight: bold; font-size: 1.2rem;">0/50</span>
            </div>
            
            <!-- å‰¯æœ¬åˆ—è¡¨ -->
            <div id="dungeons-list" style="display: flex; flex-direction: column; gap: 15px;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="closeDungeonsModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- å‰¯æœ¬è©³æƒ…æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="dungeon-detail-modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2 id="dungeon-detail-title">å‰¯æœ¬è©³æƒ…</h2>
            <div id="dungeon-detail-content" style="color: #e0e6ff; line-height: 1.8;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="dungeon-challenge-btn" onclick="startDungeonChallenge()" style="flex: 1; background: linear-gradient(135deg, #00d9ff 0%, #00a8cc 100%);">æŒ‘æˆ°</button>
                <button onclick="closeDungeonDetailModal()" style="flex: 1;">è¿”å›</button>
            </div>
        </div>
    </div>

    <!-- å‰¯æœ¬çµç®—æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="dungeon-result-modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2 style="text-align: center; color: #00ff88;">ğŸ‰ æŒ‘æˆ°æˆåŠŸï¼</h2>
            <div id="dungeon-result-content" style="color: #e0e6ff; line-height: 1.8;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="dungeon-rechallenge-btn" onclick="rechallengeDungeon()" style="flex: 1; background: linear-gradient(135deg, #00d9ff 0%, #00a8cc 100%);">å†æ¬¡æŒ‘æˆ°</button>
                <button onclick="closeDungeonResultModal()" style="flex: 1;">è¿”å›åˆ—è¡¨</button>
            </div>
        </div>
    </div>
<!-- MANUS-EDIT-START: æ·»åŠ ç„¡ç›¡æ¨¡å¼UI -->

<!-- ç„¡ç›¡æ¨¡å¼æ¨¡æ…‹è¦–çª— -->
<div class="modal" id="endless-mode-modal">
    <div class="modal-content" style="max-width: 700px;">
        <h2>ğŸ—¼ ç„¡ç›¡æŒ‘æˆ°å¡”</h2>
        
        <!-- è§£é–æç¤º -->
        <div id="endless-locked-hint" style="display: none; background: rgba(255, 152, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 152, 0, 0.4); margin-bottom: 15px; text-align: center;">
            <p style="color: #ff9800; margin: 0;">ğŸ”’ éœ€è¦é”åˆ° Lv.30 æ‰èƒ½è§£é–ç„¡ç›¡æ¨¡å¼</p>
        </div>
        
        <!-- çµ±è¨ˆä¿¡æ¯ -->
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 20px;">
            <div style="background: rgba(0, 217, 255, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); text-align: center;">
                <div style="color: #7a8fb8; font-size: 0.9rem; margin-bottom: 5px;">æ­·å²æœ€é«˜å±¤æ•¸</div>
                <div id="endless-highest-floor" style="color: #00d9ff; font-size: 1.8rem; font-weight: bold;">0</div>
            </div>
            <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); text-align: center;">
                <div style="color: #7a8fb8; font-size: 0.9rem; margin-bottom: 5px;">å¹³å‡é€šé—œå±¤æ•¸</div>
                <div id="endless-average-floor" style="color: #ffd700; font-size: 1.8rem; font-weight: bold;">0</div>
            </div>
        </div>
        
        <!-- ç•¶å‰ç‹€æ…‹ -->
        <div id="endless-current-status" style="background: rgba(156, 39, 176, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(156, 39, 176, 0.3); margin-bottom: 15px;">
            <h3 style="color: #9c27b0; margin: 0 0 10px 0;">ğŸ“Š ç•¶å‰ç‹€æ…‹</h3>
            <div style="color: #7a8fb8; line-height: 1.8;">
                <div>æª¢æŸ¥é»: ç¬¬ <span id="endless-checkpoint" style="color: #00d9ff;">1</span> å±¤</div>
                <div>æ°¸ä¹…Buffæ•¸é‡: <span id="endless-buff-count" style="color: #00ff88;">0</span></div>
                <div>ç¸½æŒ‘æˆ°æ¬¡æ•¸: <span id="endless-total-runs" style="color: #ffd700;">0</span></div>
            </div>
        </div>
        
        <!-- Buffåˆ—è¡¨ -->
        <div id="endless-buffs-display" style="background: rgba(0, 255, 136, 0.08); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 255, 136, 0.3); margin-bottom: 15px; display: none;">
            <h3 style="color: #00ff88; margin: 0 0 10px 0;">âœ¨ ç•¶å‰æ°¸ä¹…Buff</h3>
            <div id="endless-buffs-list" style="color: #7a8fb8; line-height: 1.8;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
        </div>
        
        <!-- èªªæ˜ -->
        <div style="background: rgba(122, 143, 184, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(122, 143, 184, 0.3); margin-bottom: 15px;">
            <h3 style="color: #7a8fb8; margin: 0 0 10px 0;">ğŸ“– è¦å‰‡èªªæ˜</h3>
            <ul style="color: #888; font-size: 0.9rem; line-height: 1.8; margin: 0; padding-left: 20px;">
                <li>æ¯å±¤æ•µäººå±¬æ€§ +5%, HPé¡å¤– +3%</li>
                <li>æ¯10å±¤æœ‰ä¸€å€‹Boss (å±¬æ€§Ã—1.3, HPÃ—2.5)</li>
                <li>æ¯10å±¤è¨­ç½®æª¢æŸ¥é»,æ­»äº¡å¯å¾æª¢æŸ¥é»ç¹¼çºŒ</li>
                <li>æ¯20å±¤é¸æ“‡ä¸€å€‹æ°¸ä¹…Buff,å¯ç–ŠåŠ </li>
                <li>æ¯50å±¤ç²å¾—ç‰¹æ®Šçå‹µ(å²è©©è£å‚™/ç¢ç‰‡/é‡‘å¹£)</li>
                <li>æ¶ˆè€— 10 AP é–‹å§‹æŒ‘æˆ°</li>
            </ul>
        </div>
        
        <!-- æŒ‰éˆ• -->
        <div style="display: flex; gap: 10px;">
            <button id="endless-start-btn" onclick="startEndlessMode(false)" style="flex: 1; background: linear-gradient(135deg, #00d9ff 0%, #00a8cc 100%); padding: 12px; font-size: 1.1rem;">
                ğŸš€ é–‹å§‹æŒ‘æˆ° (10 AP)
            </button>
            <button id="endless-continue-btn" onclick="startEndlessMode(true)" style="flex: 1; background: linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%); padding: 12px; font-size: 1.1rem; display: none;">
                ğŸ“ å¾æª¢æŸ¥é»ç¹¼çºŒ
            </button>
            <button onclick="closeEndlessModal()" style="flex: 0.5;">é—œé–‰</button>
        </div>
    </div>
</div>

<!-- MANUS-EDIT-END -->

    <!-- éš¨å¾ç®¡ç†æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="companion-modal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2>ğŸ¾ éš¨å¾ç®¡ç†</h2>
            
            <!-- ç•¶å‰è£å‚™çš„éš¨å¾å’Œè£å‚™ -->
            <div id="active-companion-display" style="background: rgba(0, 255, 136, 0.08); padding: 15px; border-radius: 8px; border: 2px solid rgba(0, 255, 136, 0.3); margin-bottom: 20px;">
                <h3 style="color: #00ff88; margin: 0 0 10px 0;">âœ… ç•¶å‰è£å‚™</h3>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <!-- éš¨å¾æ§½ -->
                    <div style="flex: 1; min-width: 300px;">
                        <div style="color: #4ade80; font-size: 0.9rem; margin-bottom: 5px;">ğŸ¤– éš¨å¾</div>
                        <div id="active-companion-info" style="color: #7a8fb8;">
                            ç„¡
                        </div>
                    </div>
                    <!-- è£å‚™æ§½ -->
                    <div style="flex: 1; min-width: 300px;">
                        <div style="color: #4ade80; font-size: 0.9rem; margin-bottom: 5px;">ğŸ› ï¸ è£å‚™</div>
                        <div id="active-equipment-info" style="color: #7a8fb8;">
                            ç„¡
                        </div>
                    </div>
                </div>
                <!-- çµ„åˆæ•ˆæœ -->
                <div id="combo-effect-display" style="display: none; margin-top: 15px; background: rgba(0, 255, 136, 0.15); padding: 12px; border-radius: 8px; border: 2px solid rgba(0, 255, 136, 0.5);">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- ç¢ç‰‡é¡¯ç¤º -->
            <div style="background: rgba(100, 100, 100, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="margin-top: 0; color: #4EA5FF;">ğŸ’ è£å‚™ç¢ç‰‡</h3>
                <div style="text-align: center; font-size: 1.5rem; color: #ffd700;">
                    <span id="equipment-shards-display">0</span> ç¢ç‰‡
                </div>
                <div style="text-align: center; font-size: 0.8rem; color: #888; margin-top: 5px;">ç”¨æ–¼å‡ç´šè£å‚™ç­‰ç´š</div>
            </div>
            
            <!-- è£å‚™æ”¶è— -->
            <div style="margin-bottom: 15px;">
                <h3 style="color: #4EA5FF; margin: 0 0 10px 0;">ğŸ› ï¸ è£å‚™æ”¶è—</h3>
                <div id="equipment-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                    <!-- è£å‚™å¡ç‰‡å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- éš¨å¾åˆ—è¡¨ -->
            <div style="margin-bottom: 15px;">
                <h3 style="color: #4EA5FF; margin: 0 0 10px 0;">ğŸ“š éš¨å¾æ”¶è—</h3>
                <div id="companion-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                    <!-- éš¨å¾å¡ç‰‡å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="closeCompanionModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- å¯µç‰©ç®¡ç†æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="pet-modal">
        <div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">
            <h2>ğŸ² å¯µç‰©ç³»çµ±</h2>
            
            <!-- ç•¶å‰è£å‚™çš„å¯µç‰© -->
            <div id="equipped-pet-display" style="background: rgba(250, 112, 154, 0.1); padding: 15px; border-radius: 8px; border: 2px solid rgba(250, 112, 154, 0.3); margin-bottom: 20px;">
                <h3 style="color: #fa709a; margin: 0 0 10px 0;">âœ… ç•¶å‰è£å‚™çš„å¯µç‰©</h3>
                <div id="equipped-pet-info" style="color: #7a8fb8;">
                    ç„¡
                </div>
            </div>
            
            <!-- åˆ†é æ¨™ç±¤ -->
            <div style="display: flex; gap: 8px; margin-bottom: 15px; border-bottom: 2px solid rgba(250, 112, 154, 0.3); padding-bottom: 10px;">
                <button id="pet-tab-eggs" onclick="switchPetTab('eggs')" style="flex: 1; padding: 10px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold;">ğŸ¥š å¯µç‰©è›‹</button>
                <button id="pet-tab-collection" onclick="switchPetTab('collection')" style="flex: 1; padding: 10px; background: rgba(255, 255, 255, 0.1); border: none; border-radius: 8px; color: #7a8fb8; cursor: pointer;">ğŸ¾ å¯µç‰©æ”¶è—</button>
                <button id="pet-tab-materials" onclick="switchPetTab('materials')" style="flex: 1; padding: 10px; background: rgba(255, 255, 255, 0.1); border: none; border-radius: 8px; color: #7a8fb8; cursor: pointer;">ğŸ“ ææ–™</button>
            </div>
            
            <!-- å¯µç‰©è›‹é é¢ -->
            <div id="pet-eggs-content" style="display: block;">
                <div style="background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); margin-bottom: 15px;">
                    <p style="color: #ffd700; margin: 0; font-size: 0.9rem;">ğŸ’¡ åœ¨ç¬¬3å’Œç¬¬4å€åŸŸæ“Šæ®ºæ€ªç‰©æœ‰æ©Ÿç‡æ‰è½å¯µç‰©è›‹ï¼</p>
                </div>
                <div id="pet-eggs-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                    <!-- å¯µç‰©è›‹åˆ—è¡¨å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- å¯µç‰©æ”¶è—é é¢ -->
            <div id="pet-collection-content" style="display: none;">
                <div id="pet-collection-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 15px;">
                    <!-- å¯µç‰©åˆ—è¡¨å°‡ç”± JavaScript ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- ææ–™é é¢ -->
            <div id="pet-materials-content" style="display: none;">
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                    <!-- é€²åŒ–çŸ³ -->
                    <div style="background: rgba(138, 43, 226, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                        <div style="font-size: 1.2rem; margin-bottom: 8px;">ğŸ’ é€²åŒ–çŸ³</div>
                        <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 10px;">ç”¨æ–¼å¯µç‰©é€²åŒ–</div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #8a2be2;" id="evolution-stone-count">0</div>
                    </div>
                    
                    <!-- æ°¸æ†ä¹‹æº -->
                    <div style="background: rgba(224, 64, 251, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(224, 64, 251, 0.3);">
                        <div style="font-size: 1.2rem; margin-bottom: 8px;">â­ æ°¸æ†ä¹‹æº</div>
                        <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 10px;">ç”¨æ–¼å¯µç‰©è¦ºé†’</div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #e040fb;" id="eternal-source-count">0</div>
                    </div>
                    
                    <!-- é¾æ—ç¢ç‰‡ -->
                    <div style="background: rgba(255, 69, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 69, 0, 0.3);">
                        <div style="font-size: 1.2rem; margin-bottom: 8px;">ğŸ‰ é¾æ—ç¢ç‰‡</div>
                        <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 10px;">é¾æ—å¯µç‰©å°ˆç”¨</div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #ff4500;" id="dragon-shards-count">0</div>
                    </div>
                    
                    <!-- æ©Ÿæ¢°æ—ç¢ç‰‡ -->
                    <div style="background: rgba(70, 130, 180, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(70, 130, 180, 0.3);">
                        <div style="font-size: 1.2rem; margin-bottom: 8px;">ğŸ¤– æ©Ÿæ¢°æ—ç¢ç‰‡</div>
                        <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 10px;">æ©Ÿæ¢°æ—å¯µç‰©å°ˆç”¨</div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #4682b4;" id="mecha-shards-count">0</div>
                    </div>
                    
                    <!-- è™›ç©ºæ—ç¢ç‰‡ -->
                    <div style="background: rgba(75, 0, 130, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(75, 0, 130, 0.3);">
                        <div style="font-size: 1.2rem; margin-bottom: 8px;">ğŸ‘ï¸ è™›ç©ºæ—ç¢ç‰‡</div>
                        <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 10px;">è™›ç©ºæ—å¯µç‰©å°ˆç”¨</div>
                        <div style="font-size: 1.5rem; font-weight: bold; color: #4b0082;" id="void-shards-count">0</div>
                    </div>
                </div>
                
                <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); margin-top: 20px;">
                    <h4 style="color: #ffd700; margin: 0 0 10px 0;">ğŸ“ ææ–™ç²å¾—æ–¹å¼</h4>
                    <ul style="color: #7a8fb8; margin: 0; padding-left: 20px; font-size: 0.9rem;">
                        <li>ğŸ’ é€²åŒ–çŸ³ï¼šæ“Šæ®º Boss æœ‰æ©Ÿç‡æ‰è½</li>
                        <li>â­ æ°¸æ†ä¹‹æºï¼šç¬¬4å€åŸŸ Boss æœ‰æ©Ÿç‡æ‰è½</li>
                        <li>ğŸ¾ å¯µç‰©ç¢ç‰‡ï¼šåˆ†è§£é‡è¤‡å¯µç‰©æˆ–å¯µç‰©è›‹ç²å¾—</li>
                    </ul>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button onclick="closePetModal()" style="flex: 1;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- å¡ç‰Œç®¡ç†æ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="card-modal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2>ğŸ´ å¡ç‰Œç®¡ç†</h2>
            
            <!-- å¡æ§½é¡¯ç¤º -->
            <div style="background: rgba(138, 43, 226, 0.08); padding: 15px; border-radius: 8px; border: 2px solid rgba(138, 43, 226, 0.3); margin-bottom: 20px;">
                <h3 style="margin-top: 0; color: rgba(138, 43, 226, 1);">âœ¨ å·²è£å‚™çš„å¡ç‰Œ</h3>
                <div id="equipped-cards-display" style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- å¥—ç‰Œæ•ˆæœé¡¯ç¤º -->
            <div id="deck-effect-display" style="display: none; background: rgba(255, 215, 0, 0.1); padding: 12px; border-radius: 8px; border: 2px solid rgba(255, 215, 0, 0.5); margin-bottom: 20px;">
                <!-- å‹•æ…‹ç”Ÿæˆ -->
            </div>
            
            <!-- ç¢ç‰‡é¡¯ç¤º -->
            <div style="background: rgba(100, 100, 100, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 20px;">
                <h3 style="margin-top: 0;">ğŸ’ å¡ç‰Œç¢ç‰‡</h3>
                <div id="card-shards-display" style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- å¡ç‰Œæ”¶è— -->
            <div>
                <h3>ğŸƒ å¡ç‰Œæ”¶è—</h3>
                <div id="card-collection-display">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            
            <!-- å¡ç‰Œèåˆ -->
            <div style="margin-top: 20px; background: rgba(255, 140, 0, 0.08); padding: 15px; border-radius: 8px; border: 2px solid rgba(255, 140, 0, 0.3);">
                <h3 style="margin-top: 0; color: rgba(255, 140, 0, 1);">ğŸ”¥ å¡ç‰Œèåˆ</h3>
                <div style="color: #7a8fb8; font-size: 0.9rem; margin-bottom: 15px;">
                    å°‡ 3 å¼µç›¸åŒç³»åˆ—ã€ç›¸åŒå“éšçš„æ»¿ç´š (Lv.10) å¡ç‰Œèåˆæˆ 1 å¼µæ›´é«˜å“éšçš„å¡ç‰Œï¼
                </div>
                <div id="fusion-groups-display">
                    <!-- å‹•æ…‹ç”Ÿæˆ -->
                </div>
            </div>
            
            <button onclick="closeCardModal()" style="width: 100%; padding: 12px; margin-top: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; font-weight: bold;">âœ”ï¸ é—œé–‰</button>
        </div>
    </div>

    <!-- é›¢ç·šæ”¶ç›Šæ¨¡æ…‹è¦–çª— -->
    <div class="modal" id="offline-rewards-modal">
        <div class="modal-content" style="max-width: 600px;">
            <div id="offline-rewards-content">
                <!-- é›¢ç·šæ”¶ç›Šå…§å®¹å°‡ç”± JavaScript ç”Ÿæˆ -->
            </div>
        </div>
    </div>

<!-- è‡ªå‹•è£å‚™è¨­å®šé¢æ¿ Modal -->
<div id="auto-equip-modal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <h2 style="margin-bottom: 20px;">âš™ï¸ è‡ªå‹•è£å‚™èˆ‡åˆ†è§£è¨­å®š</h2>
        
        <!-- è‡ªå‹•è£å‚™è¨­å®š -->
        <div style="background: rgba(102, 126, 234, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin: 0 0 10px 0; color: #667eea;">ğŸ¯ è‡ªå‹•è£å‚™</h3>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <span>å•Ÿç”¨è‡ªå‹•è£å‚™æ›´å¥½çš„è£å‚™</span>
                <label class="switch">
                    <input type="checkbox" id="auto-equip-toggle" onchange="toggleAutoEquip()">
                    <span class="slider round"></span>
                </label>
            </div>
            <div style="color: #7a8fb8; font-size: 0.85rem; margin-top: 5px;">
                ç²å¾—æ–°è£å‚™æ™‚ï¼Œå¦‚æœæ¯”ç•¶å‰è£å‚™æ›´å¥½ï¼Œè‡ªå‹•è£å‚™
            </div>
        </div>
        
        <!-- è‡ªå‹•åˆ†è§£è¨­å®š -->
        <div style="background: rgba(245, 87, 108, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin: 0 0 10px 0; color: #f5576c;">ğŸ”§ è‡ªå‹•åˆ†è§£</h3>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <span>å•Ÿç”¨è‡ªå‹•åˆ†è§£ä½å“è³ªè£å‚™</span>
                <label class="switch">
                    <input type="checkbox" id="auto-salvage-toggle" onchange="toggleAutoSalvage()">
                    <span class="slider round"></span>
                </label>
            </div>
            
            <!-- åˆ†è§£å“è³ªé¸æ“‡ -->
            <div style="margin-top: 15px;">
                <div style="margin-bottom: 8px; font-weight: bold;">è‡ªå‹•åˆ†è§£çš„å“è³ªï¼š</div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-common" value="common" onchange="updateSalvageQuality()" checked style="margin-right: 8px;">
                        <span style="color: #9ca3af;">âšª ç ´èˆŠ</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-uncommon" value="uncommon" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #10b981;">ğŸŸ¢ å„ªè³ª</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-fine" value="fine" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #3b82f6;">ğŸ”µ ç²¾è‰¯</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-rare" value="rare" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #a855f7;">ğŸŸ£ ç¨€æœ‰</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-epic" value="epic" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #f97316;">ğŸŸ  å²è©©</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-legendary" value="legendary" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #ef4444;">ğŸ”´ å‚³èªª</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-mythic" value="mythic" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #fbbf24;">ğŸŸ¡ ç¥è©±</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-eternal" value="eternal" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #fbbf24;">â­ æ°¸æ†</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="salvage-set" value="set" onchange="updateSalvageQuality()" style="margin-right: 8px;">
                        <span style="color: #06b6d4;">ğŸ”µ å¥—è£</span>
                    </label>
                </div>
            </div>
            
            <!-- ä¿è­·é¸é … -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1);">
                <div style="margin-bottom: 8px; font-weight: bold;">ä¿è­·è¦å‰‡ï¼š</div>
                <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                    <input type="checkbox" id="protect-set" onchange="toggleProtectSet()" checked style="margin-right: 8px;">
                    <span>ğŸ›¡ï¸ ä¿è­·å¥—è£è£å‚™</span>
                </label>
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="consider-set" onchange="toggleConsiderSet()" style="margin-right: 8px;">
                    <span>â­ è©•åˆ†æ™‚è€ƒæ…®å¥—è£æ•ˆæœ</span>
                </label>
            </div>
            
            <div style="color: #7a8fb8; font-size: 0.85rem; margin-top: 10px;">
                ğŸ’¡ ç³»çµ±æœƒè‡ªå‹•ä¿ç•™æ¯å€‹éƒ¨ä½æœ€å¥½çš„è£å‚™å’Œå·²è£å‚™çš„è£å‚™
            </div>
        </div>
        
        <!-- çµ±è¨ˆä¿¡æ¯ -->
        <div style="background: rgba(67, 233, 123, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin: 0 0 10px 0; color: #43e97b;">ğŸ“Š çµ±è¨ˆ</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                <div>
                    <span style="color: #7a8fb8;">è‡ªå‹•è£å‚™æ¬¡æ•¸ï¼š</span>
                    <span id="auto-equip-count" style="color: #43e97b; font-weight: bold;">0</span>
                </div>
                <div>
                    <span style="color: #7a8fb8;">è‡ªå‹•åˆ†è§£æ¬¡æ•¸ï¼š</span>
                    <span id="auto-salvage-count" style="color: #f5576c; font-weight: bold;">0</span>
                </div>
                <div style="grid-column: 1 / -1;">
                    <span style="color: #7a8fb8;">ç²å¾—å¼·åŒ–çŸ³ï¼š</span>
                    <span id="materials-gained" style="color: #ffd700; font-weight: bold;">0</span>
                </div>
            </div>
        </div>
        
        <!-- æ‰‹å‹•æ“ä½œ -->
        <div style="background: rgba(255, 154, 86, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <h3 style="margin: 0 0 10px 0; color: #ff9a56;">ğŸ”¨ æ‰¹é‡æ“ä½œ</h3>
            <button onclick="manualSalvageSelected()" style="width: 100%; background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%); padding: 12px; font-size: 1rem; font-weight: bold;">ğŸ› ï¸ ä¸€éµåˆ†è§£ï¼ˆæ ¹æ“šå‹¾é¸å“éšï¼‰</button>
            <div style="color: #7a8fb8; font-size: 0.85rem; margin-top: 8px; text-align: center;">
                åˆ†è§£æ‰€æœ‰ç¬¦åˆä¸Šæ–¹å‹¾é¸å“è³ªçš„è£å‚™
            </div>
        </div>
        
        <div style="display: flex; gap: 10px;">
            <button onclick="closeAutoEquipSettings()" style="flex: 1;">é—œé–‰</button>
        </div>
    </div>
</div>

<style>
/* Toggle Switch æ¨£å¼ */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #2c3e50;
    transition: .4s;
}

.slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
}

input:checked + .slider {
    background-color: #43e97b;
}

input:checked + .slider:before {
    transform: translateX(26px);
}

.slider.round {
    border-radius: 24px;
}

.slider.round:before {
    border-radius: 50%;
}
</style>
    </div>

    <script>
        // ========== éŠæˆ²è³‡æ–™çµæ§‹ ==========
        const CLASSES = {
            'ç³»çµ±æ¶æ§‹å¸«': { hp: 150, atk: 15, def: 10, crit: 6, critDmg: 155, bonusHp: 10, bonusDef: 9 },
            'æš´åŠ›æ¸¬è©¦å“¡': { hp: 120, atk: 20, def: 6, crit: 14, critDmg: 195, bonusAtk: 7, bonusCritDmg: 12 },
            'æ»²é€å·¥ç¨‹å¸«': { hp: 110, atk: 17, def: 6, crit: 18, critDmg: 180, bonusAtk: 6, bonusCrit: 5 },
            'æ•¸æ“šç§‘å­¸å®¶': { hp: 130, atk: 16, def: 8, crit: 12, critDmg: 170, bonusAtk: 6, bonusCritDmg: 10 },
            'é‹ç¶­å·¥ç¨‹å¸«': { hp: 180, atk: 16, def: 12, crit: 6, critDmg: 155, bonusHp: 10, bonusDef: 9 },
            'å‰ç«¯é–‹ç™¼è€…': { hp: 125, atk: 18, def: 7, crit: 14, critDmg: 180, bonusAtk: 6, bonusCrit: 4 },
            'å€å¡Šéˆå·¥ç¨‹å¸«': { hp: 140, atk: 15, def: 9, crit: 10, critDmg: 175, bonusDef: 8, bonusHp: 8 },
            'AIè¨“ç·´å¸«': { hp: 115, atk: 19, def: 6, crit: 16, critDmg: 185, bonusCrit: 5, bonusCritDmg: 12 },
            'é›²ç«¯æ¶æ§‹å¸«': { hp: 160, atk: 16, def: 11, crit: 7, critDmg: 160, bonusHp: 9, bonusDef: 8 }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
// æ¯æ—¥ä»»å‹™å’Œç¨±è™Ÿç³»çµ±

        const ITERATION_TALENTS = {
            combat: {
                name: 'âš”ï¸ æˆ°é¬¥å¤©è³¦',
                talents: {
                    power: {
                        name: 'åŠ›é‡å¼·åŒ–',
                        desc: 'æ°¸ä¹…æå‡æ”»æ“ŠåŠ›',
                        maxLevel: 5,
                        cost: [1, 2, 3, 4, 5],
                        effect: (level) => ({ atk: level * 3 })
                    },
                    critical: {
                        name: 'æš´æ“Šç²¾é€š',
                        desc: 'æ°¸ä¹…æå‡æš´æ“Šç‡',
                        maxLevel: 5,
                        cost: [1, 2, 3, 4, 5],
                        effect: (level) => ({ crit: level * 2 })
                    },
                    critDamage: {
                        name: 'è‡´å‘½ä¸€æ“Š',
                        desc: 'æ°¸ä¹…æå‡æš´æ“Šå‚·å®³',
                        maxLevel: 5,
                        cost: [2, 3, 4, 5, 6],
                        effect: (level) => ({ critDmg: level * 5 })
                    },
                    bossDamage: {
                        name: 'Bossçµæ‰‹',
                        desc: 'å°Bossé€ æˆé¡å¤–å‚·å®³',
                        maxLevel: 3,
                        cost: [3, 5, 7],
                        effect: (level) => ({ bossDmg: level * 5 })
                    },
                    lifeSteal: {
                        name: 'ç”Ÿå‘½æ±²å–',
                        desc: 'æ°¸ä¹…æå‡å¸è¡€',
                        maxLevel: 3,
                        cost: [2, 4, 6],
                        effect: (level) => ({ lifeSteal: level * 2 })
                    }
                }
            },
            defense: {
                name: 'ğŸ›¡ï¸ é˜²ç¦¦å¤©è³¦',
                talents: {
                    vitality: {
                        name: 'ç”Ÿå‘½å¼·åŒ–',
                        desc: 'æ°¸ä¹…æå‡ç”Ÿå‘½å€¼',
                        maxLevel: 5,
                        cost: [1, 2, 3, 4, 5],
                        effect: (level) => ({ hp: level * 5 })
                    },
                    armor: {
                        name: 'è£ç”²ç²¾é€š',
                        desc: 'æ°¸ä¹…æå‡é˜²ç¦¦åŠ›',
                        maxLevel: 5,
                        cost: [1, 2, 3, 4, 5],
                        effect: (level) => ({ def: level * 3 })
                    },
                    damageReduction: {
                        name: 'å‚·å®³æ¸›å…',
                        desc: 'æ°¸ä¹…æå‡å‚·å®³æ¸›å…',
                        maxLevel: 3,
                        cost: [2, 4, 6],
                        effect: (level) => ({ dmgRed: level * 2 })
                    },
                    maxAP: {
                        name: 'é«”åŠ›å¤§å¸«',
                        desc: 'æ°¸ä¹…æå‡æœ€å¤§é«”åŠ›',
                        maxLevel: 3,
                        cost: [3, 5, 7],
                        effect: (level) => ({ maxAp: level * 5 })
                    }
                }
            },
            resource: {
                name: 'ğŸ’° è³‡æºå¤©è³¦',
                talents: {
                    goldBonus: {
                        name: 'é»é‡‘è¡“',
                        desc: 'æ°¸ä¹…æå‡é‡‘å¹£ç²å¾—',
                        maxLevel: 5,
                        cost: [1, 2, 3, 4, 5],
                        effect: (level) => ({ goldBonus: level * 5 })
                    },
                    expBonus: {
                        name: 'å¿«é€Ÿæˆé•·',
                        desc: 'æ°¸ä¹…æå‡ç¶“é©—ç²å¾—',
                        maxLevel: 5,
                        cost: [1, 2, 3, 4, 5],
                        effect: (level) => ({ expBonus: level * 5 })
                    },
                    dropBonus: {
                        name: 'å¯¶ç‰©ç²å¾—è€…',
                        desc: 'æ°¸ä¹…æå‡æ‰è½ç‡',
                        maxLevel: 3,
                        cost: [2, 4, 6],
                        effect: (level) => ({ dropBonus: level * 3 })
                    },
                    shardBonus: {
                        name: 'ç¢ç‰‡å¤§å¸«',
                        desc: 'æ°¸ä¹…æå‡ç¢ç‰‡ç²å¾—',
                        maxLevel: 3,
                        cost: [3, 5, 7],
                        effect: (level) => ({ shardBonus: level * 5 })
                    },
                    startGold: {
                        name: 'èµ·å§‹è³‡é‡‘',
                        desc: 'è¿­ä»£å¾Œèµ·å§‹é‡‘å¹£',
                        maxLevel: 3,
                        cost: [2, 4, 6],
                        effect: (level) => ({ startGold: level * 500 })
                    }
                }
            },
            special: {
                name: 'âœ¨ ç‰¹æ®Šå¤©è³¦',
                talents: {
                    bagSize: {
                        name: 'ç©ºé–“æ“´å±•',
                        desc: 'æ°¸ä¹…æå‡èƒŒåŒ…å®¹é‡',
                        maxLevel: 3,
                        cost: [3, 5, 7],
                        effect: (level) => ({ bagSize: level * 5 })
                    }
                }
            }
        };
        
        // æ¯æ—¥ä»»å‹™å®šç¾©
        const DAILY_QUEST_POOL = [
    // æˆ°é¬¥é¡ä»»å‹™ï¼ˆ40%ï¼‰
    {
        id: 'kill_5',
        name: 'æ–°æ‰‹çµäºº',
        desc: 'æ“Šæ•—5å€‹æ•µäºº',
        type: 'kill',
        target: 5,
        difficulty: 'easy',
        rewards: { gold: 100, shards: 2, exp: 0 }
    },
    {
        id: 'kill_10',
        name: 'è³‡æ·±çµäºº',
        desc: 'æ“Šæ•—10å€‹æ•µäºº',
        type: 'kill',
        target: 10,
        difficulty: 'normal',
        rewards: { gold: 200, shards: 3, exp: 0 }
    },
    {
        id: 'kill_20',
        name: 'å¤§å¸«çµäºº',
        desc: 'æ“Šæ•—20å€‹æ•µäºº',
        type: 'kill',
        target: 20,
        difficulty: 'hard',
        rewards: { gold: 500, shards: 5, exp: 0 }
    },
    {
        id: 'kill_elite_3',
        name: 'èè‹±æ®ºæ‰‹',
        desc: 'æ“Šæ•—3å€‹èè‹±æ€ªç‰©',
        type: 'kill_elite',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 300, shards: 4, exp: 0 }
    },
    {
        id: 'kill_boss_1',
        name: 'BossæŒ‘æˆ°è€…',
        desc: 'æ“Šæ•—1å€‹Boss',
        type: 'kill_boss',
        target: 1,
        difficulty: 'hard',
        rewards: { gold: 600, shards: 8, exp: 0 }
    },
    {
        id: 'win_streak_10',
        name: 'é€£å‹ç´€éŒ„',
        desc: 'é€£çºŒå‹åˆ©10å ´',
        type: 'win_streak',
        target: 10,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'perfect_battle_3',
        name: 'å®Œç¾æˆ°é¬¥',
        desc: 'ä»¥æ»¿è¡€æ“Šæ•—æ•µäºº3æ¬¡',
        type: 'perfect_battle',
        target: 3,
        difficulty: 'hard',
        rewards: { gold: 400, shards: 5, exp: 0 }
    },
    
    // æ”¶é›†é¡ä»»å‹™ï¼ˆ30%ï¼‰
    {
        id: 'collect_equipment_5',
        name: 'è£å‚™æ”¶é›†è€…',
        desc: 'ç²å¾—5ä»¶è£å‚™',
        type: 'collect_equipment',
        target: 5,
        difficulty: 'easy',
        rewards: { gold: 150, shards: 2, exp: 0 }
    },
    {
        id: 'collect_rare_1',
        name: 'ç¨€æœ‰çµäºº',
        desc: 'ç²å¾—1ä»¶ç¨€æœ‰ä»¥ä¸Šè£å‚™',
        type: 'collect_rare',
        target: 1,
        difficulty: 'normal',
        rewards: { gold: 300, shards: 4, exp: 0 }
    },
    {
        id: 'collect_legendary_1',
        name: 'å‚³èªªè¿½å°‹è€…',
        desc: 'ç²å¾—1ä»¶å‚³èªªè£å‚™',
        type: 'collect_legendary',
        target: 1,
        difficulty: 'hard',
        rewards: { gold: 800, shards: 35, exp: 0 }
    },
    {
        id: 'collect_shards_20',
        name: 'ç¢ç‰‡æ”¶é›†',
        desc: 'ç²å¾—20ç¢ç‰‡',
        type: 'collect_shards',
        target: 20,
        difficulty: 'normal',
        rewards: { gold: 200, shards: 0, exp: 100 }
    },
    {
        id: 'collect_gold_1000',
        name: 'é‡‘å¹£å¤§äº¨',
        desc: 'ç²å¾—1000é‡‘å¹£',
        type: 'collect_gold',
        target: 1000,
        difficulty: 'normal',
        rewards: { gold: 0, shards: 5, exp: 200 }
    },
    
    // æ¢ç´¢é¡ä»»å‹™ï¼ˆ20%ï¼‰
    {
        id: 'explore_battles_10',
        name: 'å€åŸŸæ¢ç´¢è€…',
        desc: 'åœ¨ä»»æ„å€åŸŸæˆ°é¬¥10æ¬¡',
        type: 'battles',
        target: 10,
        difficulty: 'easy',
        rewards: { gold: 100, shards: 2, exp: 0 }
    },
    {
        id: 'explore_battles_20',
        name: 'æ·±åº¦æ¢ç´¢',
        desc: 'åœ¨åŒä¸€å€åŸŸæˆ°é¬¥20æ¬¡',
        type: 'battles_same_region',
        target: 20,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'explore_boss',
        name: 'å€åŸŸå¾æœè€…',
        desc: 'æ“Šæ•—ç•¶å‰å€åŸŸçš„Boss',
        type: 'region_boss',
        target: 1,
        difficulty: 'hard',
        rewards: { gold: 500, shards: 6, exp: 0 }
    },
    {
        id: 'switch_region_3',
        name: 'æ—…è¡Œè€…',
        desc: 'åˆ‡æ›3å€‹ä¸åŒå€åŸŸ',
        type: 'switch_region',
        target: 3,
        difficulty: 'easy',
        rewards: { gold: 150, shards: 2, exp: 0 }
    },
    
    // æˆé•·é¡ä»»å‹™ï¼ˆ10%ï¼‰
    {
        id: 'gain_exp_500',
        name: 'ç¶“é©—ç´¯ç©',
        desc: 'ç²å¾—500ç¶“é©—',
        type: 'gain_exp',
        target: 500,
        difficulty: 'easy',
        rewards: { gold: 200, shards: 2, exp: 0 }
    },
    {
        id: 'gain_exp_1000',
        name: 'å¿«é€Ÿæˆé•·',
        desc: 'ç²å¾—1000ç¶“é©—',
        type: 'gain_exp',
        target: 1000,
        difficulty: 'normal',
        rewards: { gold: 400, shards: 4, exp: 0 }
    },
    {
        id: 'enhance_3',
        name: 'è£å‚™å¼·åŒ–',
        desc: 'å¼·åŒ–è£å‚™3æ¬¡',
        type: 'enhance',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 300, shards: 3, exp: 0 }
    },
    {
        id: 'reforge_2',
        name: 'å±¬æ€§é‡é‘„',
        desc: 'é‡é‘„è£å‚™2æ¬¡',
        type: 'reforge',
        target: 2,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'shop_5',
        name: 'å•†åº—è³¼ç‰©',
        desc: 'åœ¨å•†åº—è³¼è²·5æ¬¡',
        type: 'shop_purchase',
        target: 5,
        difficulty: 'easy',
        rewards: { gold: 150, shards: 2, exp: 0 }
    },
    
    // å¡ç‰Œç³»çµ±ä»»å‹™ï¼ˆ8å€‹ï¼‰
    {
        id: 'fuse_card_3',
        name: 'å¡ç‰Œèåˆå¸«',
        desc: 'èåˆ3å¼µå¡ç‰Œ',
        type: 'fuse_card',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 300, shards: 4, exp: 0 }
    },
    {
        id: 'fuse_card_5',
        name: 'èåˆå¤§å¸«',
        desc: 'èåˆ5å¼µå¡ç‰Œ',
        type: 'fuse_card',
        target: 5,
        difficulty: 'hard',
        rewards: { gold: 500, shards: 6, exp: 0 }
    },
    {
        id: 'salvage_card_5',
        name: 'å¡ç‰Œå›æ”¶è€…',
        desc: 'å›æ”¶5å¼µå¡ç‰Œ',
        type: 'salvage_card',
        target: 5,
        difficulty: 'easy',
        rewards: { gold: 200, shards: 3, exp: 0 }
    },
    {
        id: 'salvage_card_10',
        name: 'å›æ”¶å°ˆå®¶',
        desc: 'å›æ”¶10å¼µå¡ç‰Œ',
        type: 'salvage_card',
        target: 10,
        difficulty: 'normal',
        rewards: { gold: 350, shards: 5, exp: 0 }
    },
    {
        id: 'collect_rare_card',
        name: 'ç¨€æœ‰å¡ç‰Œçµäºº',
        desc: 'ç²å¾—1å¼µç¨€æœ‰ä»¥ä¸Šå¡ç‰Œ',
        type: 'collect_rare_card',
        target: 1,
        difficulty: 'normal',
        rewards: { gold: 400, shards: 5, exp: 0 }
    },
    {
        id: 'level_up_card_3',
        name: 'å¡ç‰Œè¨“ç·´å¸«',
        desc: 'å¡ç‰Œå‡ç´š3æ¬¡',
        type: 'level_up_card',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'equip_card_5',
        name: 'å¡ç‰Œè£å‚™è€…',
        desc: 'è£å‚™å¡ç‰Œ5æ¬¡',
        type: 'equip_card',
        target: 5,
        difficulty: 'easy',
        rewards: { gold: 150, shards: 2, exp: 0 }
    },
    {
        id: 'collect_card_3',
        name: 'å¡ç‰Œæ”¶é›†è€…',
        desc: 'ç²å¾—3å¼µå¡ç‰Œ',
        type: 'collect_card',
        target: 3,
        difficulty: 'easy',
        rewards: { gold: 200, shards: 2, exp: 0 }
    },
    
    // éš¨å¾ç³»çµ±ä»»å‹™ï¼ˆ6å€‹ï¼‰
    {
        id: 'collect_companion_equipment_3',
        name: 'éš¨å¾è£å‚™æ”¶é›†è€…',
        desc: 'ç²å¾—3ä»¶éš¨å¾è£å‚™',
        type: 'collect_companion_equipment',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 300, shards: 4, exp: 0 }
    },
    {
        id: 'upgrade_companion_equipment_3',
        name: 'è£å‚™å¼·åŒ–è€…',
        desc: 'å‡ç´šéš¨å¾è£å‚™3æ¬¡',
        type: 'upgrade_companion_equipment',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'trigger_combo_5',
        name: 'çµ„åˆå¤§å¸«',
        desc: 'è§¸ç™¼çµ„åˆæ•ˆæœ5æ¬¡',
        type: 'trigger_combo',
        target: 5,
        difficulty: 'hard',
        rewards: { gold: 400, shards: 5, exp: 0 }
    },
    {
        id: 'battle_with_companion_10',
        name: 'éš¨å¾æ­æª”',
        desc: 'èˆ‡éš¨å¾ä¸€èµ·æˆ°é¬¥10æ¬¡',
        type: 'battle_with_companion',
        target: 10,
        difficulty: 'easy',
        rewards: { gold: 200, shards: 2, exp: 0 }
    },
    {
        id: 'collect_companion_shard_20',
        name: 'éš¨å¾ç¢ç‰‡æ”¶é›†è€…',
        desc: 'ç²å¾—20å€‹éš¨å¾ç¢ç‰‡',
        type: 'collect_companion_shard',
        target: 20,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'summon_companion_1',
        name: 'éš¨å¾å¬å–šè€…',
        desc: 'å¬å–š1å€‹éš¨å¾',
        type: 'summon_companion',
        target: 1,
        difficulty: 'hard',
        rewards: { gold: 500, shards: 6, exp: 0 }
    },
    
    // å¯µç‰©ç³»çµ±ä»»å‹™ï¼ˆ5å€‹ï¼‰
    {
        id: 'feed_pet_5',
        name: 'å¯µç‰©é£¼é¤Šå“¡',
        desc: 'é¤µé¤Šå¯µç‰©5æ¬¡',
        type: 'feed_pet',
        target: 5,
        difficulty: 'easy',
        rewards: { gold: 150, shards: 2, exp: 0 }
    },
    {
        id: 'level_up_pet_2',
        name: 'å¯µç‰©è¨“ç·´å¸«',
        desc: 'å¯µç‰©å‡ç´š2æ¬¡',
        type: 'level_up_pet',
        target: 2,
        difficulty: 'normal',
        rewards: { gold: 300, shards: 4, exp: 0 }
    },
    {
        id: 'collect_pet_material_10',
        name: 'ææ–™æ”¶é›†è€…',
        desc: 'æ”¶é›†10å€‹å¯µç‰©ææ–™',
        type: 'collect_pet_material',
        target: 10,
        difficulty: 'normal',
        rewards: { gold: 250, shards: 3, exp: 0 }
    },
    {
        id: 'evolve_pet_1',
        name: 'å¯µç‰©é€²åŒ–è€…',
        desc: 'é€²åŒ–å¯µç‰©1æ¬¡',
        type: 'evolve_pet',
        target: 1,
        difficulty: 'hard',
        rewards: { gold: 500, shards: 6, exp: 0 }
    },
    {
        id: 'battle_with_pet_10',
        name: 'å¯µç‰©æˆ°é¬¥å¤¥ä¼´',
        desc: 'èˆ‡å¯µç‰©ä¸€èµ·æˆ°é¬¥10æ¬¡',
        type: 'battle_with_pet',
        target: 10,
        difficulty: 'easy',
        rewards: { gold: 200, shards: 2, exp: 0 }
    },
    
    // å‰¯æœ¬ç³»çµ±ä»»å‹™ï¼ˆ4å€‹ï¼‰
    {
        id: 'complete_dungeon_3',
        name: 'å‰¯æœ¬æŒ‘æˆ°è€…',
        desc: 'å®Œæˆ3æ¬¡å‰¯æœ¬',
        type: 'complete_dungeon',
        target: 3,
        difficulty: 'easy',
        rewards: { gold: 300, shards: 4, exp: 0 }
    },
    {
        id: 'complete_dungeon_5',
        name: 'å‰¯æœ¬å¾æœè€…',
        desc: 'å®Œæˆ5æ¬¡å‰¯æœ¬',
        type: 'complete_dungeon',
        target: 5,
        difficulty: 'normal',
        rewards: { gold: 500, shards: 6, exp: 0 }
    },
    {
        id: 'complete_hard_dungeon_2',
        name: 'å›°é›£æŒ‘æˆ°è€…',
        desc: 'å®Œæˆ2æ¬¡å›°é›£ä»¥ä¸Šå‰¯æœ¬',
        type: 'complete_hard_dungeon',
        target: 2,
        difficulty: 'hard',
        rewards: { gold: 500, shards: 6, exp: 0 }
    },
    {
        id: 'complete_different_dungeons_3',
        name: 'å‰¯æœ¬æ¢ç´¢è€…',
        desc: 'å®Œæˆ3ç¨®ä¸åŒé¡å‹å‰¯æœ¬',
        type: 'complete_different_dungeons',
        target: 3,
        difficulty: 'normal',
        rewards: { gold: 400, shards: 5, exp: 0 }
    },
    
    // å…¶ä»–ç³»çµ±ä»»å‹™ï¼ˆ3å€‹ï¼‰
    {
        id: 'salvage_equipment_10',
        name: 'åˆ†è§£å°ˆå®¶',
        desc: 'åˆ†è§£10ä»¶è£å‚™',
        type: 'salvage_equipment',
        target: 10,
        difficulty: 'easy',
        rewards: { gold: 200, shards: 3, exp: 0 }
    },
    {
        id: 'endless_10_floors',
        name: 'ç„¡ç›¡æŒ‘æˆ°è€…',
        desc: 'åœ¨ç„¡ç›¡æ¨¡å¼é”åˆ°ç¬¬10å±¤',
        type: 'endless_floors',
        target: 10,
        difficulty: 'hard',
        rewards: { gold: 600, shards: 8, exp: 0 }
    },
    {
        id: 'endless_20_floors',
        name: 'ç„¡ç›¡å‹‡è€…',
        desc: 'åœ¨ç„¡ç›¡æ¨¡å¼é”åˆ°ç¬¬20å±¤',
        type: 'endless_floors',
        target: 20,
        difficulty: 'hard',
        rewards: { gold: 1000, shards: 12, exp: 0 }
    }
];

// ç¨±è™Ÿå®šç¾©
const TITLES_DATA = {
    // æˆ°é¬¥ç¨±è™Ÿï¼ˆ15å€‹ï¼‰
    'newbie_adventurer': {
        name: 'ğŸ—¡ï¸ æ–°æ‰‹å†’éšªè€…',
        desc: 'æ“Šæ•— 10 å€‹æ•µäºº',
        howToGet: 'åœ¨ä»»æ„å€åŸŸæˆ°é¬¥ä¸¦æ“Šæ•—æ•µäººï¼Œç´¯è¨ˆé”åˆ° 10 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'common',
        condition: { type: 'kills', value: 10 },
        bonus: { atk: 1 }
    },
    'veteran_warrior': {
        name: 'âš”ï¸ è³‡æ·±æˆ°å£«',
        desc: 'æ“Šæ•—100å€‹æ•µäºº',
        howToGet: 'åœ¨ä»»æ„å€åŸŸæˆ°é¬¥ä¸¦æ“Šæ•—æ•µäººï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'kills', value: 100 },
        bonus: { atk: 2 }
    },
    'battle_master': {
        name: 'ğŸ”¥ æˆ°é¬¥å¤§å¸«',
        desc: 'æ“Šæ•—500å€‹æ•µäºº',
        howToGet: 'åœ¨ä»»æ„å€åŸŸæˆ°é¬¥ä¸¦æ“Šæ•—æ•µäººï¼Œç´¯è¨ˆé”åˆ° 500 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'kills', value: 500 },
        bonus: { atk: 3, crit: 1 }
    },
    'legendary_hunter': {
        name: 'âš¡ å‚³èªªçµäºº',
        desc: 'æ“Šæ•—1000å€‹æ•µäºº',
        howToGet: 'åœ¨ä»»æ„å€åŸŸæˆ°é¬¥ä¸¦æ“Šæ•—æ•µäººï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'legendary',
        condition: { type: 'kills', value: 1000 },
        bonus: { atk: 5, crit: 2 }
    },
    'elite_slayer': {
        name: 'ğŸ‘‘ èè‹±æ®ºæ‰‹',
        desc: 'æ“Šæ•—50å€‹èè‹±æ€ªç‰©',
        howToGet: 'æ“Šæ•—èè‹±æ€ªç‰©ï¼ˆå€åŸŸå…§çš„å¼·åŠ›æ•µäººï¼‰ï¼Œç´¯è¨ˆé”åˆ° 50 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'elite_kills', value: 50 },
        bonus: { bossDmg: 5 }
    },
    'boss_terminator': {
        name: 'ğŸ’€ Bossçµ‚çµè€…',
        desc: 'æ“Šæ•—20å€‹Boss',
        howToGet: 'æŒ‘æˆ°ä¸¦æ“Šæ•—å„å€åŸŸçš„ Bossï¼Œç´¯è¨ˆé”åˆ° 20 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'boss_kills', value: 20 },
        bonus: { bossDmg: 10 }
    },
    'perfect_warrior': {
        name: 'ğŸŒŸ å®Œç¾æˆ°å£«',
        desc: '100æ¬¡å®Œç¾æˆ°é¬¥',
        howToGet: 'ä»¥æ»¿è¡€ç‹€æ…‹å®Œæˆæˆ°é¬¥ï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'perfect_battles', value: 100 },
        bonus: { atk: 3, def: 3 }
    },
    'sniper': {
        name: 'ğŸ¯ ç‹™æ“Šæ‰‹',
        desc: 'æš´æ“Š1000æ¬¡',
        howToGet: 'è§¸ç™¼æš´æ“Šæ”»æ“Šï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'crits', value: 1000 },
        bonus: { crit: 2 }
    },
    'crit_master': {
        name: 'ğŸ’¥ æš´æ“Šå¤§å¸«',
        desc: 'è§¸ç™¼100æ¬¡é«˜å‚·æš´æ“Š',
        howToGet: 'è§¸ç™¼é«˜å‚·å®³æš´æ“Šï¼ˆæš´æ“Šå‚·å®³ > 200%ï¼‰ï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'high_crits', value: 100 },
        bonus: { critDmg: 10 }
    },
    'unyielding': {
        name: 'ğŸ›¡ï¸ ä¸å±ˆä¹‹å¿—',
        desc: 'ç”Ÿå‘½ä½æ–¼10%å­˜æ´»100æ¬¡',
        howToGet: 'åœ¨ç”Ÿå‘½å€¼ä½æ–¼ 10% æ™‚å­˜æ´»ä¸¦ç²å‹ï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'low_hp_survive', value: 100 },
        bonus: { hp: 5 }
    },
    'win_streak_king': {
        name: 'âš¡ é€£å‹ç‹è€…',
        desc: 'é€£å‹50å ´',
        howToGet: 'é€£çºŒç²å‹ä¸æ•—ï¼Œé”åˆ° 50 é€£å‹å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'max_win_streak', value: 50 },
        bonus: { atk: 2, def: 2 }
    },
    'one_shot': {
        name: 'ğŸ”ª ä¸€æ“Šå¿…æ®º',
        desc: 'ä¸€æ“Šæ“Šæ®ºæ•µäºº100æ¬¡',
        howToGet: 'ä¸€æ“Šæ“Šæ®ºæ•µäººï¼ˆå–®æ¬¡æ”»æ“Šé€ æˆæ•µäººå…¨éƒ¨ç”Ÿå‘½å€¼å‚·å®³ï¼‰ï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'one_shots', value: 100 },
        bonus: { atk: 3 }
    },
    'vampire': {
        name: 'ğŸ©¸ å¸è¡€é¬¼',
        desc: 'å¸è¡€å›å¾©10000 HP',
        howToGet: 'é€éå¸è¡€æ•ˆæœå›å¾©ç”Ÿå‘½å€¼ï¼Œç´¯è¨ˆå›å¾© 10000 HP å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'lifesteal_heal', value: 10000 },
        bonus: { lifeSteal: 2 }
    },
    'iron_wall': {
        name: 'ğŸ§± éµå£',
        desc: 'æ¸›å‚·10000é»',
        howToGet: 'é€éæ¸›å‚·æ•ˆæœæ¸›å°‘å‚·å®³ï¼Œç´¯è¨ˆæ¸›å‚· 10000 é»å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'damage_reduced', value: 10000 },
        bonus: { dmgRed: 2 }
    },
    'storm_force': {
        name: 'ğŸŒªï¸ é¢¨æš´ä¹‹åŠ›',
        desc: 'å–®å ´æˆ°é¬¥é€ æˆ5000å‚·å®³',
        howToGet: 'åœ¨å–®å ´æˆ°é¬¥ä¸­é€ æˆ 5000 é»ç¸½å‚·å®³å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'max_battle_damage', value: 5000 },
        bonus: { atk: 4 }
    },
    
    // æ”¶é›†ç¨±è™Ÿï¼ˆ12å€‹ï¼‰
    'equipment_collector': {
        name: 'ğŸ“¦ è£å‚™æ”¶é›†è€…',
        desc: 'ç²å¾—100ä»¶è£å‚™',
        howToGet: 'é€éæˆ°é¬¥ã€å•†åº—ã€å‰¯æœ¬ç­‰æ–¹å¼ç²å¾—è£å‚™ï¼Œç´¯è¨ˆé”åˆ° 100 ä»¶å³å¯è§£é–',
        category: 'collection',
        rarity: 'common',
        condition: { type: 'items', value: 100 },
        bonus: { dropRate: 2 }
    },
    'rare_hunter': {
        name: 'ğŸ’ ç¨€æœ‰çµäºº',
        desc: 'ç²å¾—50ä»¶ç¨€æœ‰è£å‚™',
        howToGet: 'ç²å¾—ç¨€æœ‰å“è³ªï¼ˆè—è‰²ï¼‰çš„è£å‚™ï¼Œç´¯è¨ˆé”åˆ° 50 ä»¶å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'rare_items', value: 50 },
        bonus: { dropRate: 3 }
    },
    'epic_collector': {
        name: 'â­ å²è©©æ”¶è—å®¶',
        desc: 'ç²å¾—20ä»¶å²è©©è£å‚™',
        howToGet: 'ç²å¾—å²è©©å“è³ªï¼ˆç´«è‰²ï¼‰çš„è£å‚™ï¼Œç´¯è¨ˆé”åˆ° 20 ä»¶å³å¯è§£é–',
        category: 'collection',
        rarity: 'epic',
        condition: { type: 'epic_items', value: 20 },
        bonus: { dropRate: 5 }
    },
    'legendary_seeker': {
        name: 'ğŸŒŸ å‚³èªªè¿½å°‹è€…',
        desc: 'ç²å¾—10ä»¶å‚³èªªè£å‚™',
        howToGet: 'ç²å¾—å‚³èªªå“è³ªï¼ˆé‡‘è‰²ï¼‰çš„è£å‚™ï¼Œç´¯è¨ˆé”åˆ° 10 ä»¶å³å¯è§£é–',
        category: 'collection',
        rarity: 'legendary',
        condition: { type: 'legendaryItems', value: 10 },
        bonus: { dropRate: 8 }
    },
    'shard_tycoon': {
        name: 'ğŸ”· ç¢ç‰‡å¤§äº¨',
        desc: 'ç´¯ç©ç²å¾—10000ç¢ç‰‡',
        howToGet: 'é€éåˆ†è§£è£å‚™ã€å‰¯æœ¬çå‹µç­‰æ–¹å¼ç²å¾—ç¢ç‰‡ï¼Œç´¯è¨ˆé”åˆ° 10000 å€‹å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'total_shards', value: 10000 },
        bonus: { shardBonus: 5 }
    },
    'gold_hunter': {
        name: 'ğŸ’° é»ƒé‡‘çµäºº',
        desc: 'ç´¯ç©ç²å¾—100000é‡‘å¹£',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€é›¢ç·šæ”¶ç›Šç­‰æ–¹å¼ç²å¾—é‡‘å¹£ï¼Œç´¯è¨ˆé”åˆ° 100000 é‡‘å¹£å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'total_gold', value: 100000 },
        bonus: { goldBonus: 5 }
    },
    'exp_master': {
        name: 'ğŸ“š ç¶“é©—å¤§å¸«',
        desc: 'ç´¯ç©ç²å¾—50000ç¶“é©—',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€ä»»å‹™ç­‰æ–¹å¼ç²å¾—ç¶“é©—ï¼Œç´¯è¨ˆé”åˆ° 50000 ç¶“é©—å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'total_exp', value: 50000 },
        bonus: { expBonus: 5 }
    },
    'bag_expert': {
        name: 'ğŸ’ èƒŒåŒ…é”äºº',
        desc: 'èƒŒåŒ…æ»¿100æ¬¡',
        howToGet: 'èƒŒåŒ…æ»¿è¼‰ï¼ˆè£å‚™æ•¸é‡é”åˆ°ä¸Šé™ï¼‰ï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'collection',
        rarity: 'common',
        condition: { type: 'bag_full', value: 100 },
        bonus: { bagSize: 5 }
    },
    'salvage_expert': {
        name: 'âš™ï¸ åˆ†è§£å°ˆå®¶',
        desc: 'åˆ†è§£100ä»¶è£å‚™',
        howToGet: 'åˆ†è§£ä¸éœ€è¦çš„è£å‚™ä»¥ç²å¾—ç¢ç‰‡ï¼Œç´¯è¨ˆåˆ†è§£ 100 ä»¶å³å¯è§£é–',
        category: 'collection',
        rarity: 'common',
        condition: { type: 'salvaged', value: 100 },
        bonus: { salvageBonus: 10 }
    },
    'enhance_master': {
        name: 'âš¡ å¼·åŒ–å¤§å¸«',
        desc: 'å¼·åŒ–æˆåŠŸ100æ¬¡',
        howToGet: 'å¼·åŒ–è£å‚™ä¸¦æˆåŠŸï¼Œç´¯è¨ˆæˆåŠŸ 100 æ¬¡å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'enhances', value: 100 },
        bonus: { enhanceRate: 5 }
    },
    'reforge_expert': {
        name: 'ğŸ”„ é‡é‘„å°ˆå®¶',
        desc: 'é‡é‘„50æ¬¡',
        howToGet: 'ä½¿ç”¨ç¢ç‰‡é‡é‘„è£å‚™å±¬æ€§ï¼Œç´¯è¨ˆé‡é‘„ 50 æ¬¡å³å¯è§£é–',
        category: 'collection',
        rarity: 'common',
        condition: { type: 'reforges', value: 50 },
        bonus: { reforgeCost: -10 }
    },
    'set_collector': {
        name: 'ğŸ å¥—è£æ”¶è—å®¶',
        desc: 'æ”¶é›†5å¥—å®Œæ•´å¥—è£',
        howToGet: 'æ”¶é›†ä¸¦è£å‚™å®Œæ•´çš„å¥—è£ï¼ˆåŒç³»åˆ—è£å‚™ï¼‰ï¼Œç´¯è¨ˆæ”¶é›† 5 å¥—å³å¯è§£é–',
        category: 'collection',
        rarity: 'epic',
        condition: { type: 'complete_sets', value: 5 },
        bonus: { setBonus: 10 }
    },
    
    // æ¢ç´¢ç¨±è™Ÿï¼ˆ10å€‹ï¼‰
    'explorer': {
        name: 'ğŸ—ºï¸ æ¢ç´¢è€…',
        desc: 'æ¢ç´¢æ‰€æœ‰å€åŸŸ',
        howToGet: 'æ¢ç´¢ä¸¦è§£é–æ‰€æœ‰å€åŸŸï¼ˆå…± 10 å€‹å€åŸŸï¼‰ï¼Œå…¨éƒ¨æ¢ç´¢å®Œç•¢å³å¯è§£é–',
        category: 'exploration',
        rarity: 'common',
        condition: { type: 'regions_explored', value: 10 },
        bonus: { expBonus: 2 }
    },
    'conqueror': {
        name: 'ğŸ”ï¸ å¾æœè€…',
        desc: 'æ“Šæ•—æ‰€æœ‰å€åŸŸBoss',
        howToGet: 'æ“Šæ•—æ‰€æœ‰å€åŸŸçš„ Bossï¼ˆå…± 10 å€‹ Bossï¼‰ï¼Œå…¨éƒ¨æ“Šæ•—å³å¯è§£é–',
        category: 'exploration',
        rarity: 'rare',
        condition: { type: 'all_bosses_defeated', value: 1 },
        bonus: { bossDmg: 5 }
    },
    'traveler': {
        name: 'ğŸŒ æ—…è¡Œå®¶',
        desc: 'åˆ‡æ›å€åŸŸ100æ¬¡',
        howToGet: 'åœ¨ä¸åŒå€åŸŸä¹‹é–“åˆ‡æ›ï¼Œç´¯è¨ˆåˆ‡æ› 100 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'common',
        condition: { type: 'region_switches', value: 100 },
        bonus: { goldBonus: 3 }
    },
    'specialist': {
        name: 'ğŸ¯ å°ˆç²¾è€…',
        desc: 'åœ¨åŒä¸€å€åŸŸæˆ°é¬¥100æ¬¡',
        howToGet: 'åœ¨åŒä¸€å€åŸŸå…§æŒçºŒæˆ°é¬¥ï¼Œç´¯è¨ˆæˆ°é¬¥ 100 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'common',
        condition: { type: 'same_region_battles', value: 100 },
        bonus: { atk: 2 }
    },
    'region_lord': {
        name: 'ğŸ‘‘ å€åŸŸéœ¸ä¸»',
        desc: 'åœ¨åŒä¸€å€åŸŸæ“Šæ•—Boss 10æ¬¡',
        howToGet: 'åœ¨åŒä¸€å€åŸŸå…§é‡è¤‡æ“Šæ•— Bossï¼Œç´¯è¨ˆæ“Šæ•— 10 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'rare',
        condition: { type: 'same_boss_kills', value: 10 },
        bonus: { bossDmg: 8 }
    },
    'abyss_explorer': {
        name: 'ğŸ”¥ æ·±æ·µæ¢ç´¢è€…',
        desc: 'åˆ°é”æœ€æ·±å±¤å€åŸŸ',
        howToGet: 'åˆ°é”æœ€æ·±å±¤å€åŸŸï¼ˆç¬¬ 10 å€åŸŸï¼šçµ‚ç„‰è™›ç©ºï¼‰ï¼Œåˆ°é”å³å¯è§£é–',
        category: 'exploration',
        rarity: 'epic',
        condition: { type: 'max_region', value: 9 },
        bonus: { atk: 3, def: 3, hp: 3 }
    },
    'speedster': {
        name: 'âš¡ é€Ÿåº¦ç‹‚äºº',
        desc: '10ç§’å…§å®Œæˆæˆ°é¬¥100æ¬¡',
        howToGet: 'åœ¨ 10 ç§’å…§å¿«é€Ÿå®Œæˆæˆ°é¬¥ï¼Œç´¯è¨ˆé”åˆ° 100 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'rare',
        condition: { type: 'fast_battles', value: 100 },
        bonus: { atk: 3 }
    },
    'defense_expert': {
        name: 'ğŸ›¡ï¸ é˜²ç¦¦å°ˆå®¶',
        desc: 'å—åˆ°0å‚·å®³å®Œæˆæˆ°é¬¥50æ¬¡',
        howToGet: 'åœ¨æˆ°é¬¥ä¸­å—åˆ° 0 å‚·å®³ï¼ˆå®Œç¾é˜²ç¦¦ï¼‰ï¼Œç´¯è¨ˆé”åˆ° 50 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'epic',
        condition: { type: 'no_damage_battles', value: 50 },
        bonus: { def: 5 }
    },
    'endurance_warrior': {
        name: 'ğŸ’ª æŒä¹…æˆ°å£«',
        desc: 'æˆ°é¬¥è¶…é5åˆ†é˜10æ¬¡',
        howToGet: 'æˆ°é¬¥æ™‚é–“è¶…é 5 åˆ†é˜çš„æŒä¹…æˆ°ï¼Œç´¯è¨ˆé”åˆ° 10 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'common',
        condition: { type: 'long_battles', value: 10 },
        bonus: { hp: 3 }
    },
    'lucky_one': {
        name: 'ğŸ² å¹¸é‹å…’',
        desc: 'é€£çºŒæ‰è½ç¨€æœ‰è£å‚™5æ¬¡',
        howToGet: 'é€£çºŒæ‰è½ç¨€æœ‰ä»¥ä¸Šå“è³ªçš„è£å‚™ï¼Œé€£çºŒ 5 æ¬¡å³å¯è§£é–',
        category: 'exploration',
        rarity: 'rare',
        condition: { type: 'rare_drop_streak', value: 5 },
        bonus: { dropRate: 5 }
    },
    
    // æˆå°±ç¨±è™Ÿï¼ˆ10å€‹ï¼‰
    'fast_growth': {
        name: 'ğŸ“ˆ å¿«é€Ÿæˆé•·',
        desc: '1å°æ™‚å…§å‡10ç´š',
        howToGet: 'åœ¨ 1 å°æ™‚å…§å¿«é€Ÿå‡ç´š 10 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'common',
        condition: { type: 'fast_level', value: 10 },
        bonus: { expBonus: 3 }
    },
    'rocket_leveler': {
        name: 'ğŸš€ ç«ç®­å‡ç´š',
        desc: 'é”åˆ°50ç´š',
        howToGet: 'è§’è‰²ç­‰ç´šé”åˆ° 50 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'rare',
        condition: { type: 'level', value: 50 },
        bonus: { expBonus: 5 }
    },
    'max_level_warrior': {
        name: 'â­ æ»¿ç´šæˆ°å£«',
        desc: 'é”åˆ°100ç´š',
        howToGet: 'è§’è‰²ç­‰ç´šé”åˆ°æ»¿ç´š 100 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'epic',
        condition: { type: 'level', value: 100 },
        bonus: { atk: 3, def: 3, hp: 3 }
    },
    'reborn': {
        name: 'ğŸ”„ é‡ç”Ÿè€…',
        desc: 'å®Œæˆ1æ¬¡è¿­ä»£',
        howToGet: 'é”åˆ° Lv.100 ä¸¦å®Œæˆæ‰€æœ‰å€åŸŸ Boss å¾Œé€²è¡Œç¬¬ 1 æ¬¡è¿­ä»£å³å¯è§£é–',
        category: 'achievement',
        rarity: 'rare',
        condition: { type: 'iterations', value: 1 },
        bonus: { iterationIP: 5 }
    },
    'veteran_iterator': {
        name: 'ğŸ”„ğŸ”„ è³‡æ·±è¿­ä»£è€…',
        desc: 'å®Œæˆ5æ¬¡è¿­ä»£',
        howToGet: 'å®Œæˆ 5 æ¬¡è¿­ä»£å³å¯è§£é–',
        category: 'achievement',
        rarity: 'epic',
        condition: { type: 'iterations', value: 5 },
        bonus: { iterationIP: 10 }
    },
    'iteration_master': {
        name: 'ğŸ”„ğŸ”„ğŸ”„ è¿­ä»£å¤§å¸«',
        desc: 'å®Œæˆ10æ¬¡è¿­ä»£',
        howToGet: 'å®Œæˆ 10 æ¬¡è¿­ä»£å³å¯è§£é–',
        category: 'achievement',
        rarity: 'legendary',
        condition: { type: 'iterations', value: 10 },
        bonus: { iterationIP: 15 }
    },
    'talent_apprentice': {
        name: 'âœ¨ å¤©è³¦å­¸å¾’',
        desc: 'è§£é–10å€‹å¤©è³¦',
        howToGet: 'ä½¿ç”¨è¿­ä»£é»æ•¸è§£é– 10 å€‹å¤©è³¦å³å¯è§£é–',
        category: 'achievement',
        rarity: 'common',
        condition: { type: 'talents_unlocked', value: 10 },
        bonus: { talentBonus: 5 }
    },
    'talent_expert': {
        name: 'âœ¨âœ¨ å¤©è³¦å°ˆå®¶',
        desc: 'è§£é–å…¨éƒ¨å¤©è³¦',
        howToGet: 'è§£é–æ‰€æœ‰å¤©è³¦ï¼ˆå…± 20 å€‹ï¼‰å³å¯è§£é–',
        category: 'achievement',
        rarity: 'epic',
        condition: { type: 'talents_unlocked', value: 20 },
        bonus: { talentBonus: 10 }
    },
    'quest_master': {
        name: 'ğŸ“‹ ä»»å‹™é”äºº',
        desc: 'å®Œæˆ100å€‹æ¯æ—¥ä»»å‹™',
        howToGet: 'å®Œæˆæ¯æ—¥ä»»å‹™ï¼Œç´¯è¨ˆå®Œæˆ 100 å€‹å³å¯è§£é–',
        category: 'achievement',
        rarity: 'rare',
        condition: { type: 'quests_completed', value: 100 },
        bonus: { questReward: 10 }
    },
    'achievement_hunter': {
        name: 'ğŸ† æˆå°±çµäºº',
        desc: 'ç²å¾—50å€‹ç¨±è™Ÿ',
        howToGet: 'è§£é–å„ç¨®ç¨±è™Ÿï¼Œç´¯è¨ˆè§£é– 50 å€‹ç¨±è™Ÿå³å¯è§£é–',
        category: 'achievement',
        rarity: 'legendary',
        condition: { type: 'titles_unlocked', value: 50 },
        bonus: { atk: 5, def: 5, hp: 5 }
    },
    
    // ç‰¹æ®Šç¨±è™Ÿï¼ˆ8å€‹ï¼‰
    'anniversary': {
        name: 'ğŸ‚ é€±å¹´æ…¶å…¸',
        desc: 'éŠç©æ»¿1å¹´',
        howToGet: 'æŒçºŒéŠç©æ»¿ 365 å¤©ï¼ˆ1 å¹´ï¼‰å³å¯è§£é–',
        category: 'special',
        rarity: 'legendary',
        condition: { type: 'play_days', value: 365 },
        bonus: { atk: 5, def: 5, hp: 5 }
    },
    'christmas': {
        name: 'ğŸ„ è–èª•å¿«æ¨‚',
        desc: 'è–èª•ç¯€ç™»å…¥',
        howToGet: 'åœ¨è–èª•ç¯€æœŸé–“ï¼ˆ12/24-12/26ï¼‰ç™»å…¥éŠæˆ²å³å¯è§£é–',
        category: 'special',
        rarity: 'rare',
        condition: { type: 'event', value: 'christmas' },
        bonus: { goldBonus: 10 }
    },
    'new_year': {
        name: 'ğŸ† æ–°å¹´å¿«æ¨‚',
        desc: 'æ–°å¹´ç™»å…¥',
        howToGet: 'åœ¨æ–°å¹´æœŸé–“ï¼ˆ1/1ï¼‰ç™»å…¥éŠæˆ²å³å¯è§£é–',
        category: 'special',
        rarity: 'rare',
        condition: { type: 'event', value: 'new_year' },
        bonus: { expBonus: 10 }
    },
    'valentine': {
        name: 'ğŸ’ æƒ…äººç¯€',
        desc: 'æƒ…äººç¯€ç™»å…¥',
        howToGet: 'åœ¨æƒ…äººç¯€æœŸé–“ï¼ˆ2/14ï¼‰ç™»å…¥éŠæˆ²å³å¯è§£é–',
        category: 'special',
        rarity: 'rare',
        condition: { type: 'event', value: 'valentine' },
        bonus: { dropRate: 10 }
    },
    'lunar_new_year': {
        name: 'ğŸŒ¸ æ˜¥ç¯€å¿«æ¨‚',
        desc: 'æ˜¥ç¯€ç™»å…¥',
        howToGet: 'åœ¨è¾²æ›†æ–°å¹´æœŸé–“ç™»å…¥éŠæˆ²å³å¯è§£é–',
        category: 'special',
        rarity: 'rare',
        condition: { type: 'event', value: 'lunar_new_year' },
        bonus: { shardBonus: 10 }
    },
    'halloween': {
        name: 'ğŸ‘» è¬è–ç¯€',
        desc: 'è¬è–ç¯€ç™»å…¥',
        howToGet: 'åœ¨è¬è–ç¯€æœŸé–“ï¼ˆ10/31ï¼‰ç™»å…¥éŠæˆ²å³å¯è§£é–',
        category: 'special',
        rarity: 'rare',
        condition: { type: 'event', value: 'halloween' },
        bonus: { bossDmg: 10 }
    },
    'first_day_player': {
        name: 'ğŸ® é¦–æ—¥ç©å®¶',
        desc: 'éŠæˆ²é¦–æ—¥ç™»å…¥',
        howToGet: 'åœ¨éŠæˆ²é¦–æ—¥ï¼ˆç™¼å¸ƒç•¶å¤©ï¼‰ç™»å…¥éŠæˆ²å³å¯è§£é–',
        category: 'special',
        rarity: 'legendary',
        condition: { type: 'first_day', value: 1 },
        bonus: { atk: 3, def: 3, hp: 3 }
    },
    'abyss_guardian': {
        name: 'ğŸŒŸ æ•¸ä½æ·±æ·µå®ˆè­·è€…',
        desc: 'éŠç©æ»¿100å°æ™‚',
        howToGet: 'ç´¯è¨ˆéŠç©æ™‚é–“é”åˆ° 100 å°æ™‚å³å¯è§£é–',
        category: 'special',
        rarity: 'legendary',
        condition: { type: 'play_hours', value: 100 },
        bonus: { atk: 10, def: 10, hp: 10 }
    },
    
    // v2.0 é·ç§»ç¨±è™Ÿå·²ç§»é™¤
    'iteration_vanguard': {
        name: 'âš¡ è¿­ä»£å…ˆé‹’',
        desc: 'é«˜ç­‰ç´šæ—©æœŸç©å®¶ï¼Œè¿­ä»£ç³»çµ±å…ˆé©…',
        howToGet: 'ä½¿ç”¨ Lv.50+ çš„èˆŠç‰ˆæœ¬å­˜æª”è¼‰å…¥ v2.0 ç‰ˆæœ¬ï¼Œç³»çµ±æœƒè‡ªå‹•é·ç§»ä¸¦è§£é–æ­¤ç¨±è™Ÿ',
        category: 'special',
        rarity: 'legendary',
        condition: { type: 'migration', value: 'v2_iteration_vanguard' },
        bonus: { atk: 5, def: 5, hp: 5, expBonus: 8, iterationIP: 10 }
    }    ,
    
    // æˆé•·ç³»åˆ—ç¨±è™Ÿï¼ˆ8å€‹ï¼‰
    'beginner': {
        name: 'ğŸŒ± åˆå­¸è€…',
        desc: 'é”åˆ° Lv.10',
        howToGet: 'è§’è‰²ç­‰ç´šé”åˆ° 10 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'common',
        condition: { type: 'level', value: 10 },
        bonus: { expBonus: 2 }
    },
    'advanced_player': {
        name: 'ğŸŒ¿ é€²éšè€…',
        desc: 'é”åˆ° Lv.20',
        howToGet: 'è§’è‰²ç­‰ç´šé”åˆ° 20 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'common',
        condition: { type: 'level', value: 20 },
        bonus: { expBonus: 3 }
    },
    'veteran_adventurer': {
        name: 'ğŸŒ³ è³‡æ·±å†’éšªè€…',
        desc: 'é”åˆ° Lv.30',
        howToGet: 'è§’è‰²ç­‰ç´šé”åˆ° 30 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'rare',
        condition: { type: 'level', value: 30 },
        bonus: { expBonus: 4, atk: 2 }
    },
    'elite_fighter': {
        name: 'ğŸ”ï¸ ç²¾è‹±æˆ°å£«',
        desc: 'é”åˆ° Lv.40',
        howToGet: 'è§’è‰²ç­‰ç´šé”åˆ° 40 ç´šå³å¯è§£é–',
        category: 'achievement',
        rarity: 'rare',
        condition: { type: 'level', value: 40 },
        bonus: { expBonus: 5, atk: 3, def: 2 }
    },
    'exp_master_pro': {
        name: 'ğŸ’« ç¶“é©—å¤§å¸«',
        desc: 'ç´¯è¨ˆç²å¾— 100,000 ç¶“é©—',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€ä»»å‹™ç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 100,000 ç¶“é©—å³å¯è§£é–',
        category: 'achievement',
        rarity: 'epic',
        condition: { type: 'total_exp', value: 100000 },
        bonus: { expBonus: 10 }
    },
    'exp_maniac': {
        name: 'âš¡ ç¶“é©—ç‹‚äºº',
        desc: 'ç´¯è¨ˆç²å¾— 500,000 ç¶“é©—',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€ä»»å‹™ç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 500,000 ç¶“é©—å³å¯è§£é–',
        category: 'achievement',
        rarity: 'epic',
        condition: { type: 'total_exp', value: 500000 },
        bonus: { expBonus: 15 }
    },
    'exp_god': {
        name: 'ğŸŒŸ ç¶“é©—ä¹‹ç¥',
        desc: 'ç´¯è¨ˆç²å¾— 1,000,000 ç¶“é©—',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€ä»»å‹™ç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 1,000,000 ç¶“é©—å³å¯è§£é–',
        category: 'achievement',
        rarity: 'legendary',
        condition: { type: 'total_exp', value: 1000000 },
        bonus: { expBonus: 20, atk: 5 }
    },
    'knowledge_seeker': {
        name: 'ğŸ“š çŸ¥è­˜è¿½æ±‚è€…',
        desc: 'åœ¨ 1 å°æ™‚å…§å‡ç´š 5 æ¬¡',
        howToGet: 'åœ¨ 1 å°æ™‚å…§å¿«é€Ÿå‡ç´š 5 æ¬¡å³å¯è§£é–',
        category: 'achievement',
        rarity: 'rare',
        condition: { type: 'fast_level', value: 5 },
        bonus: { expBonus: 5 }
    },
    
    // è²¡å¯Œç³»åˆ—ç¨±è™Ÿï¼ˆ10å€‹ï¼‰
    'small_fortune': {
        name: 'ğŸ’° å°å¯Œç¿',
        desc: 'ç´¯è¨ˆç²å¾— 50,000 é‡‘å¹£',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€é›¢ç·šæ”¶ç›Šç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 50,000 é‡‘å¹£å³å¯è§£é–',
        category: 'collection',
        rarity: 'common',
        condition: { type: 'total_gold', value: 50000 },
        bonus: { goldBonus: 3 }
    },
    'wealthy': {
        name: 'ğŸ’ å¯Œè±ª',
        desc: 'ç´¯è¨ˆç²å¾— 500,000 é‡‘å¹£',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€é›¢ç·šæ”¶ç›Šç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 500,000 é‡‘å¹£å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'total_gold', value: 500000 },
        bonus: { goldBonus: 5 }
    },
    'gold_tycoon_pro': {
        name: 'ğŸ‘‘ é‡‘å¹£å¤§äº¨',
        desc: 'ç´¯è¨ˆç²å¾— 1,000,000 é‡‘å¹£',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€é›¢ç·šæ”¶ç›Šç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 1,000,000 é‡‘å¹£å³å¯è§£é–',
        category: 'collection',
        rarity: 'epic',
        condition: { type: 'total_gold', value: 1000000 },
        bonus: { goldBonus: 8 }
    },
    'wealth_king': {
        name: 'ğŸ† è²¡å¯Œä¹‹ç‹',
        desc: 'ç´¯è¨ˆç²å¾— 5,000,000 é‡‘å¹£',
        howToGet: 'é€éæˆ°é¬¥ã€å‰¯æœ¬ã€é›¢ç·šæ”¶ç›Šç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 5,000,000 é‡‘å¹£å³å¯è§£é–',
        category: 'collection',
        rarity: 'legendary',
        condition: { type: 'total_gold', value: 5000000 },
        bonus: { goldBonus: 12, atk: 5 }
    },
    'shard_collector_pro': {
        name: 'ğŸ’  ç¢ç‰‡æ”¶è—å®¶',
        desc: 'ç´¯è¨ˆç²å¾— 5,000 ç¢ç‰‡',
        howToGet: 'é€éåˆ†è§£è£å‚™ã€å‰¯æœ¬çå‹µç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 5,000 ç¢ç‰‡å³å¯è§£é–',
        category: 'collection',
        rarity: 'common',
        condition: { type: 'total_shards', value: 5000 },
        bonus: { shardBonus: 3 }
    },
    'shard_expert_pro': {
        name: 'ğŸ’ ğŸ’  ç¢ç‰‡å°ˆå®¶',
        desc: 'ç´¯è¨ˆç²å¾— 20,000 ç¢ç‰‡',
        howToGet: 'é€éåˆ†è§£è£å‚™ã€å‰¯æœ¬çå‹µç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 20,000 ç¢ç‰‡å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'total_shards', value: 20000 },
        bonus: { shardBonus: 5 }
    },
    'shard_wealthy': {
        name: 'ğŸ’ ğŸ’ ğŸ’  ç¢ç‰‡å¯Œè±ª',
        desc: 'ç´¯è¨ˆç²å¾— 50,000 ç¢ç‰‡',
        howToGet: 'é€éåˆ†è§£è£å‚™ã€å‰¯æœ¬çå‹µç­‰æ–¹å¼ç´¯è¨ˆç²å¾— 50,000 ç¢ç‰‡å³å¯è§£é–',
        category: 'collection',
        rarity: 'epic',
        condition: { type: 'total_shards', value: 50000 },
        bonus: { shardBonus: 8 }
    },
    'lucky_guy': {
        name: 'ğŸ å¹¸é‹å…’',
        desc: 'å–®æ¬¡æˆ°é¬¥ç²å¾— 5,000+ é‡‘å¹£',
        howToGet: 'åœ¨å–®æ¬¡æˆ°é¬¥ä¸­ç²å¾— 5,000 é‡‘å¹£ä»¥ä¸Šå³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'single_battle_gold', value: 5000 },
        bonus: { goldBonus: 5, dropRate: 3 }
    },
    'super_lucky_star': {
        name: 'ğŸŒˆ è¶…ç´šå¹¸é‹æ˜Ÿ',
        desc: 'å–®æ¬¡æˆ°é¬¥ç²å¾— 10,000+ é‡‘å¹£',
        howToGet: 'åœ¨å–®æ¬¡æˆ°é¬¥ä¸­ç²å¾— 10,000 é‡‘å¹£ä»¥ä¸Šå³å¯è§£é–',
        category: 'collection',
        rarity: 'epic',
        condition: { type: 'single_battle_gold', value: 10000 },
        bonus: { goldBonus: 8, dropRate: 5 }
    },
    'business_master': {
        name: 'ğŸª å•†æ¥­å¤§å¸«',
        desc: 'åœ¨å•†åº—è³¼è²· 50 ä»¶ç‰©å“',
        howToGet: 'åœ¨å•†åº—ç´¯è¨ˆè³¼è²· 50 ä»¶ç‰©å“ï¼ˆè£å‚™æˆ–æ¶ˆè€—å“ï¼‰å³å¯è§£é–',
        category: 'collection',
        rarity: 'rare',
        condition: { type: 'shop_purchases', value: 50 },
        bonus: { goldBonus: 5 }
    },
    
    // æˆ°é¬¥ç²¾é€šç³»åˆ—ç¨±è™Ÿï¼ˆ6å€‹ï¼‰
    'combo_novice': {
        name: 'âš”ï¸ é€£æ“Šæ–°æ‰‹',
        desc: 'é”æˆ 10 é€£å‹',
        howToGet: 'é€£çºŒç²å‹ 10 æ¬¡ä¸æ•—å³å¯è§£é–',
        category: 'combat',
        rarity: 'common',
        condition: { type: 'max_win_streak', value: 10 },
        bonus: { atk: 2 }
    },
    'combo_expert': {
        name: 'âš”ï¸âš”ï¸ é€£æ“Šé«˜æ‰‹',
        desc: 'é”æˆ 20 é€£å‹',
        howToGet: 'é€£çºŒç²å‹ 20 æ¬¡ä¸æ•—å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'max_win_streak', value: 20 },
        bonus: { atk: 3, crit: 2 }
    },
    'combo_master': {
        name: 'âš”ï¸âš”ï¸âš”ï¸ é€£æ“Šå¤§å¸«',
        desc: 'é”æˆ 30 é€£å‹',
        howToGet: 'é€£çºŒç²å‹ 30 æ¬¡ä¸æ•—å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'max_win_streak', value: 30 },
        bonus: { atk: 5, crit: 3, critDmg: 5 }
    },
    'crit_lover': {
        name: 'ğŸ’¥ æš´æ“Šæ„›å¥½è€…',
        desc: 'è§¸ç™¼ 500 æ¬¡æš´æ“Š',
        howToGet: 'åœ¨æˆ°é¬¥ä¸­è§¸ç™¼æš´æ“Šæ”»æ“Šï¼Œç´¯è¨ˆé”åˆ° 500 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'common',
        condition: { type: 'crit_count', value: 500 },
        bonus: { crit: 2 }
    },
    'crit_expert_pro': {
        name: 'ğŸ’¥ğŸ’¥ æš´æ“Šå°ˆå®¶',
        desc: 'è§¸ç™¼ 2,000 æ¬¡æš´æ“Š',
        howToGet: 'åœ¨æˆ°é¬¥ä¸­è§¸ç™¼æš´æ“Šæ”»æ“Šï¼Œç´¯è¨ˆé”åˆ° 2,000 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'rare',
        condition: { type: 'crit_count', value: 2000 },
        bonus: { crit: 3, critDmg: 5 }
    },
    'crit_god': {
        name: 'ğŸ’¥ğŸ’¥ğŸ’¥ æš´æ“Šä¹‹ç¥',
        desc: 'è§¸ç™¼ 5,000 æ¬¡æš´æ“Š',
        howToGet: 'åœ¨æˆ°é¬¥ä¸­è§¸ç™¼æš´æ“Šæ”»æ“Šï¼Œç´¯è¨ˆé”åˆ° 5,000 æ¬¡å³å¯è§£é–',
        category: 'combat',
        rarity: 'epic',
        condition: { type: 'crit_count', value: 5000 },
        bonus: { crit: 5, critDmg: 10 }
    }
    ,
    
    // ==================== åœ–é‘‘ç³»çµ±ç¨±è™Ÿ ====================
    
    // æ€ªç‰©åœ–é‘‘ç¨±è™Ÿ - æ™®é€šæ€ªç‰© 1000 æ®ºï¼ˆç¤ºä¾‹ï¼‰
    'monster_master_å·¥åŠé¼ ': {
        name: 'ğŸ­ å·¥åŠé¼ æ®ºæ‰‹',
        desc: 'æ“Šæ®ºå·¥åŠé¼  1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºå·¥åŠé¼ ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'å·¥åŠé¼ ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é›»æµè¿½è¹¤è€…': {
        name: 'âš¡ é›»æµè¿½è¹¤è€…æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé›»æµè¿½è¹¤è€… 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºé›»æµè¿½è¹¤è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é›»æµè¿½è¹¤è€…', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æ€’ç„°ç‹‚å¾’': {
        name: 'ğŸ”¥ æ€’ç„°ç‹‚å¾’æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæ€’ç„°ç‹‚å¾’ 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºæ€’ç„°ç‹‚å¾’ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æ€’ç„°ç‹‚å¾’', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æ•¸æ“šå‘‘å™¬è€…': {
        name: 'ğŸ’¾ æ•¸æ“šå‘‘å™¬è€…æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæ•¸æ“šå‘‘å™¬è€… 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºæ•¸æ“šå‘‘å™¬è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æ•¸æ“šå‘‘å™¬è€…', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_è¿·ä½ å²èŠå§†': {
        name: 'ğŸŸ¢ è¿·ä½ å²èŠå§†æ®ºæ‰‹',
        desc: 'æ“Šæ®ºè¿·ä½ å²èŠå§† 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºè¿·ä½ å²èŠå§†ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'è¿·ä½ å²èŠå§†', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_ç¤¦æ´è™è ': {
        name: 'ğŸ¦‡ ç¤¦æ´è™è æ®ºæ‰‹',
        desc: 'æ“Šæ®ºç¤¦æ´è™è  1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºç¤¦æ´è™è ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'ç¤¦æ´è™è ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_è¦‹ç¿’å“¥å¸ƒæ—': {
        name: 'ğŸ‘º è¦‹ç¿’å“¥å¸ƒæ—æ®ºæ‰‹',
        desc: 'æ“Šæ®ºè¦‹ç¿’å“¥å¸ƒæ— 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºè¦‹ç¿’å“¥å¸ƒæ—ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'è¦‹ç¿’å“¥å¸ƒæ—', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æœ¨æ£å¼·ç›œ': {
        name: 'ğŸ¹ æœ¨æ£å¼·ç›œæ®ºæ‰‹',
        desc: 'æ“Šæ®ºæœ¨æ£å¼·ç›œ 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºæœ¨æ£å¼·ç›œï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æœ¨æ£å¼·ç›œ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æµå¯‡å¼“æ‰‹': {
        name: 'ğŸ¯ æµå¯‡å¼“æ‰‹æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæµå¯‡å¼“æ‰‹ 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºæµå¯‡å¼“æ‰‹ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æµå¯‡å¼“æ‰‹', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æµæµªé‡çŠ¬': {
        name: 'ğŸ• æµæµªé‡çŠ¬æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæµæµªé‡çŠ¬ 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºæµæµªé‡çŠ¬ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æµæµªé‡çŠ¬', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_éŠ…ç”²ç”²èŸ²': {
        name: 'ğŸª² éŠ…ç”²ç”²èŸ²æ®ºæ‰‹',
        desc: 'æ“Šæ®ºéŠ…ç”²ç”²èŸ² 1000 æ¬¡',
        howToGet: 'åœ¨å…¥é–€é–‹ç™¼å±¤æ“Šæ®ºéŠ…ç”²ç”²èŸ²ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'éŠ…ç”²ç”²èŸ²', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é‹¼æ®¼ç”²èŸ²': {
        name: 'ğŸª² é‹¼æ®¼ç”²èŸ²æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé‹¼æ®¼ç”²èŸ² 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºé‹¼æ®¼ç”²èŸ²ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é‹¼æ®¼ç”²èŸ²', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æ£®æ—ç°ç‹¼': {
        name: 'ğŸº æ£®æ—ç°ç‹¼æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæ£®æ—ç°ç‹¼ 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºæ£®æ—ç°ç‹¼ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æ£®æ—ç°ç‹¼', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_ç›œè³Šåˆºå®¢': {
        name: 'ğŸ¥· ç›œè³Šåˆºå®¢æ®ºæ‰‹',
        desc: 'æ“Šæ®ºç›œè³Šåˆºå®¢ 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºç›œè³Šåˆºå®¢ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'ç›œè³Šåˆºå®¢', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_ç«ç„°å­¸å¾’': {
        name: 'ğŸ”¥ ç«ç„°å­¸å¾’æ®ºæ‰‹',
        desc: 'æ“Šæ®ºç«ç„°å­¸å¾’ 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºç«ç„°å­¸å¾’ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'ç«ç„°å­¸å¾’', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_çŸ³åƒé¬¼': {
        name: 'ğŸ—¿ çŸ³åƒé¬¼æ®ºæ‰‹',
        desc: 'æ“Šæ®ºçŸ³åƒé¬¼ 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºçŸ³åƒé¬¼ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'çŸ³åƒé¬¼', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_éª·é«å…µ': {
        name: 'ğŸ’€ éª·é«å…µæ®ºæ‰‹',
        desc: 'æ“Šæ®ºéª·é«å…µ 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºéª·é«å…µï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'éª·é«å…µ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é‡ç›¾å“¥å¸ƒæ—': {
        name: 'ğŸ›¡ï¸ é‡ç›¾å“¥å¸ƒæ—æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé‡ç›¾å“¥å¸ƒæ— 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºé‡ç›¾å“¥å¸ƒæ—ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é‡ç›¾å“¥å¸ƒæ—', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_éœ§æ—å¼“æ‰‹': {
        name: 'ğŸ¹ éœ§æ—å¼“æ‰‹æ®ºæ‰‹',
        desc: 'æ“Šæ®ºéœ§æ—å¼“æ‰‹ 1000 æ¬¡',
        howToGet: 'åœ¨ç ”ç™¼æ ¸å¿ƒå±¤æ“Šæ®ºéœ§æ—å¼“æ‰‹ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'éœ§æ—å¼“æ‰‹', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é»‘é¬ƒæƒ¡ç‹¼': {
        name: 'ğŸº é»‘é¬ƒæƒ¡ç‹¼æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé»‘é¬ƒæƒ¡ç‹¼ 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºé»‘é¬ƒæƒ¡ç‹¼ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é»‘é¬ƒæƒ¡ç‹¼', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æš—å½±åˆºå®¢': {
        name: 'ğŸ¥· æš—å½±åˆºå®¢æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæš—å½±åˆºå®¢ 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºæš—å½±åˆºå®¢ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æš—å½±åˆºå®¢', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_å·«éª¨æ³•å¸«': {
        name: 'ğŸ§™ å·«éª¨æ³•å¸«æ®ºæ‰‹',
        desc: 'æ“Šæ®ºå·«éª¨æ³•å¸« 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºå·«éª¨æ³•å¸«ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'å·«éª¨æ³•å¸«', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æ·±ç©´å·¨è™è ': {
        name: 'ğŸ¦‡ æ·±ç©´å·¨è™è æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæ·±ç©´å·¨è™è  1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºæ·±ç©´å·¨è™è ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æ·±ç©´å·¨è™è ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_å²©ç”²é­”èŸ¹': {
        name: 'ğŸ¦€ å²©ç”²é­”èŸ¹æ®ºæ‰‹',
        desc: 'æ“Šæ®ºå²©ç”²é­”èŸ¹ 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºå²©ç”²é­”èŸ¹ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'å²©ç”²é­”èŸ¹', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_å¼©æ‰‹å¼·ç›œ': {
        name: 'ğŸ¯ å¼©æ‰‹å¼·ç›œæ®ºæ‰‹',
        desc: 'æ“Šæ®ºå¼©æ‰‹å¼·ç›œ 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºå¼©æ‰‹å¼·ç›œï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'å¼©æ‰‹å¼·ç›œ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æ³¥å²©å·¨äºº': {
        name: 'ğŸ§Œ æ³¥å²©å·¨äººæ®ºæ‰‹',
        desc: 'æ“Šæ®ºæ³¥å²©å·¨äºº 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºæ³¥å²©å·¨äººï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æ³¥å²©å·¨äºº', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_äº¡éˆå¼“æ‰‹': {
        name: 'ğŸ’€ äº¡éˆå¼“æ‰‹æ®ºæ‰‹',
        desc: 'æ“Šæ®ºäº¡éˆå¼“æ‰‹ 1000 æ¬¡',
        howToGet: 'åœ¨è³‡æ–™è£‚ç¸«æ“Šæ®ºäº¡éˆå¼“æ‰‹ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'äº¡éˆå¼“æ‰‹', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_åœ°ç„çµçŠ¬': {
        name: 'ğŸ•â€ğŸ¦¶ åœ°ç„çµçŠ¬æ®ºæ‰‹',
        desc: 'æ“Šæ®ºåœ°ç„çµçŠ¬ 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºåœ°ç„çµçŠ¬ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'åœ°ç„çµçŠ¬', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é­…å½±åˆºå®¢': {
        name: 'ğŸ‘» é­…å½±åˆºå®¢æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé­…å½±åˆºå®¢ 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºé­…å½±åˆºå®¢ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é­…å½±åˆºå®¢', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_å¹½å†¥éª·é«': {
        name: 'ğŸ’€ å¹½å†¥éª·é«æ®ºæ‰‹',
        desc: 'æ“Šæ®ºå¹½å†¥éª·é« 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºå¹½å†¥éª·é«ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'å¹½å†¥éª·é«', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_ç†”å²©å·¨äºº': {
        name: 'ğŸ”¥ ç†”å²©å·¨äººæ®ºæ‰‹',
        desc: 'æ“Šæ®ºç†”å²©å·¨äºº 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºç†”å²©å·¨äººï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'ç†”å²©å·¨äºº', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é›·éœ†é­”èœ¥': {
        name: 'âš¡ é›·éœ†é­”èœ¥æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé›·éœ†é­”èœ¥ 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºé›·éœ†é­”èœ¥ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é›·éœ†é­”èœ¥', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_é­…å½±å¼“æ‰‹': {
        name: 'ğŸ‘» é­…å½±å¼“æ‰‹æ®ºæ‰‹',
        desc: 'æ“Šæ®ºé­…å½±å¼“æ‰‹ 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºé­…å½±å¼“æ‰‹ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'é­…å½±å¼“æ‰‹', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_æš—é»‘è¡“å£«': {
        name: 'ğŸ§™â€â™‚ï¸ æš—é»‘è¡“å£«æ®ºæ‰‹',
        desc: 'æ“Šæ®ºæš—é»‘è¡“å£« 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºæš—é»‘è¡“å£«ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'æš—é»‘è¡“å£«', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    'monster_master_å¯’éœœé­”éˆ': {
        name: 'â„ï¸ å¯’éœœé­”éˆæ®ºæ‰‹',
        desc: 'æ“Šæ®ºå¯’éœœé­”éˆ 1000 æ¬¡',
        howToGet: 'åœ¨æ·±äº•è‡¨ç•Œå±¤æ“Šæ®ºå¯’éœœé­”éˆï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_monster',
        rarity: 'rare',
        condition: { type: 'monster_kills', monster: 'å¯’éœœé­”éˆ', value: 1000 },
        bonus: { atk: 3, monsterDmg: 5 }
    },
    
    // æ€ªç‰©åœ–é‘‘ç¨±è™Ÿ - ç²¾è‹±æ€ªç‰© 1000 æ®º
    'elite_master_é¢¨æš´è¡Œè€…': {
        name: 'ğŸŒªï¸ é¢¨æš´è¡Œè€…çµäºº',
        desc: 'æ“Šæ®ºé¢¨æš´è¡Œè€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©é¢¨æš´è¡Œè€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'é¢¨æš´è¡Œè€…', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_é›»æµè¿½è¹¤è€…': {
        name: 'âš¡ é›»æµè¿½è¹¤è€…çµäºº',
        desc: 'æ“Šæ®ºé›»æµè¿½è¹¤è€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©é›»æµè¿½è¹¤è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'é›»æµè¿½è¹¤è€…', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ™¶çŸ³å®ˆè­·è€…': {
        name: 'ğŸ’ æ™¶çŸ³å®ˆè­·è€…çµäºº',
        desc: 'æ“Šæ®ºæ™¶çŸ³å®ˆè­·è€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ™¶çŸ³å®ˆè­·è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ™¶çŸ³å®ˆè­·è€…', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ€’ç„°ç‹‚å¾’': {
        name: 'ğŸ”¥ æ€’ç„°ç‹‚å¾’çµäºº',
        desc: 'æ“Šæ®ºæ€’ç„°ç‹‚å¾’ 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ€’ç„°ç‹‚å¾’ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ€’ç„°ç‹‚å¾’', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ˜Ÿå…‰å“¨å…µ': {
        name: 'ğŸŒŸ æ˜Ÿå…‰å“¨å…µçµäºº',
        desc: 'æ“Šæ®ºæ˜Ÿå…‰å“¨å…µ 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ˜Ÿå…‰å“¨å…µï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ˜Ÿå…‰å“¨å…µ', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_çƒˆç„°å›ä¸»': {
        name: 'ğŸ”¥ çƒˆç„°å›ä¸»çµäºº',
        desc: 'æ“Šæ®ºçƒˆç„°å›ä¸» 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©çƒˆç„°å›ä¸»ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'çƒˆç„°å›ä¸»', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æš—å½±åŠè–': {
        name: 'âš”ï¸ æš—å½±åŠè–çµäºº',
        desc: 'æ“Šæ®ºæš—å½±åŠè– 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æš—å½±åŠè–ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æš—å½±åŠè–', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ³°å¦çŸ³è¡›': {
        name: 'ğŸ—¿ æ³°å¦çŸ³è¡›çµäºº',
        desc: 'æ“Šæ®ºæ³°å¦çŸ³è¡› 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ³°å¦çŸ³è¡›ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ³°å¦çŸ³è¡›', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_è™›ç©ºè¡Œåˆ‘è€…': {
        name: 'ğŸ‘» è™›ç©ºè¡Œåˆ‘è€…çµäºº',
        desc: 'æ“Šæ®ºè™›ç©ºè¡Œåˆ‘è€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©è™›ç©ºè¡Œåˆ‘è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'è™›ç©ºè¡Œåˆ‘è€…', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_é›·éœ†åŸ·æ³•è€…': {
        name: 'âš¡ é›·éœ†åŸ·æ³•è€…çµäºº',
        desc: 'æ“Šæ®ºé›·éœ†åŸ·æ³•è€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©é›·éœ†åŸ·æ³•è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'é›·éœ†åŸ·æ³•è€…', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ˜Ÿç•Œè¡“å£«': {
        name: 'ğŸŒŒ æ˜Ÿç•Œè¡“å£«çµäºº',
        desc: 'æ“Šæ®ºæ˜Ÿç•Œè¡“å£« 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ˜Ÿç•Œè¡“å£«ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ˜Ÿç•Œè¡“å£«', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æš—å¤œéœ¸ä¸»': {
        name: 'ğŸº æš—å¤œéœ¸ä¸»çµäºº',
        desc: 'æ“Šæ®ºæš—å¤œéœ¸ä¸» 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æš—å¤œéœ¸ä¸»ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æš—å¤œéœ¸ä¸»', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_ç…‰ç„æš´å›': {
        name: 'ğŸ”¥ ç…‰ç„æš´å›çµäºº',
        desc: 'æ“Šæ®ºç…‰ç„æš´å› 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©ç…‰ç„æš´å›ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'ç…‰ç„æš´å›', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_é–ƒé›»éœ¸ç‹': {
        name: 'âš¡ é–ƒé›»éœ¸ç‹çµäºº',
        desc: 'æ“Šæ®ºé–ƒé›»éœ¸ç‹ 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©é–ƒé›»éœ¸ç‹ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'é–ƒé›»éœ¸ç‹', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ­»ç¥ä½¿è€…': {
        name: 'ğŸ’€ æ­»ç¥ä½¿è€…çµäºº',
        desc: 'æ“Šæ®ºæ­»ç¥ä½¿è€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ­»ç¥ä½¿è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ­»ç¥ä½¿è€…', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    'elite_master_æ¥µå¯’é­”å›': {
        name: 'â„ï¸ æ¥µå¯’é­”å›çµäºº',
        desc: 'æ“Šæ®ºæ¥µå¯’é­”å› 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç²¾è‹±æ€ªç‰©æ¥µå¯’é­”å›ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_elite',
        rarity: 'epic',
        condition: { type: 'monster_kills', monster: 'æ¥µå¯’é­”å›', value: 1000 },
        bonus: { atk: 5, eliteDmg: 10 }
    },
    
    // æ€ªç‰©åœ–é‘‘ç¨±è™Ÿ - Boss 1000 æ®º
    'boss_master_ç ´ç¢å®ˆè¡›': {
        name: 'ğŸ¤– ç ´ç¢å®ˆè¡›å¾æœè€…',
        desc: 'æ“Šæ®ºç ´ç¢å®ˆè¡› 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºå…¥é–€é–‹ç™¼å±¤ Boss ç ´ç¢å®ˆè¡›ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_boss',
        rarity: 'legendary',
        condition: { type: 'monster_kills', monster: 'ç ´ç¢å®ˆè¡›', value: 1000 },
        bonus: { atk: 8, bossDmg: 15 }
    },
    'boss_master_æ•¸æ“šå®ˆé–€è€…': {
        name: 'âš”ï¸ æ•¸æ“šå®ˆé–€è€…å¾æœè€…',
        desc: 'æ“Šæ®ºæ•¸æ“šå®ˆé–€è€… 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºå…¥é–€é–‹ç™¼å±¤ Boss æ•¸æ“šå®ˆé–€è€…ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_boss',
        rarity: 'legendary',
        condition: { type: 'monster_kills', monster: 'æ•¸æ“šå®ˆé–€è€…', value: 1000 },
        bonus: { atk: 8, bossDmg: 15 }
    },
    'boss_master_æ ¸å¿ƒç›£å¯Ÿå®˜': {
        name: 'ğŸ‘ï¸ æ ¸å¿ƒç›£å¯Ÿå®˜å¾æœè€…',
        desc: 'æ“Šæ®ºæ ¸å¿ƒç›£å¯Ÿå®˜ 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºç ”ç™¼æ ¸å¿ƒå±¤ Boss æ ¸å¿ƒç›£å¯Ÿå®˜ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_boss',
        rarity: 'legendary',
        condition: { type: 'monster_kills', monster: 'æ ¸å¿ƒç›£å¯Ÿå®˜', value: 1000 },
        bonus: { atk: 8, bossDmg: 15 }
    },
    'boss_master_è£‚ç¸«ä¸»å­°': {
        name: 'ğŸ’€ è£‚ç¸«ä¸»å­°å¾æœè€…',
        desc: 'æ“Šæ®ºè£‚ç¸«ä¸»å­° 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºè³‡æ–™è£‚ç¸« Boss è£‚ç¸«ä¸»å­°ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_boss',
        rarity: 'legendary',
        condition: { type: 'monster_kills', monster: 'è£‚ç¸«ä¸»å­°', value: 1000 },
        bonus: { atk: 8, bossDmg: 15 }
    },
    'boss_master_æ·±æ·µéœ¸ä¸»': {
        name: 'ğŸ˜ˆ æ·±æ·µéœ¸ä¸»å¾æœè€…',
        desc: 'æ“Šæ®ºæ·±æ·µéœ¸ä¸» 1000 æ¬¡',
        howToGet: 'æ“Šæ®ºæ·±äº•è‡¨ç•Œå±¤ Boss æ·±æ·µéœ¸ä¸»ï¼Œç´¯è¨ˆé”åˆ° 1000 æ¬¡å³å¯è§£é–',
        category: 'codex_boss',
        rarity: 'legendary',
        condition: { type: 'monster_kills', monster: 'æ·±æ·µéœ¸ä¸»', value: 1000 },
        bonus: { atk: 8, bossDmg: 15 }
    },
    
    // è£å‚™åœ–é‘‘ç¨±è™Ÿ - å¥—è£æ”¶é›†
    'equipment_collector_half': {
        name: 'ğŸ“¦ è£å‚™æ”¶è—å®¶',
        desc: 'æ”¶é›† 16 ä»¶å¥—è£è£å‚™',
        howToGet: 'æ”¶é›†ä¸¦ç²å¾— 16 ä»¶å¥—è£è£å‚™ï¼ˆåŠæ•¸ï¼‰',
        category: 'codex_equipment',
        rarity: 'rare',
        condition: { type: 'equipment_collected', value: 16 },
        bonus: { setBonus: 5 }
    },
    'equipment_collector_full': {
        name: 'ğŸ è£å‚™å¤§å¸«',
        desc: 'æ”¶é›†å…¨éƒ¨ 32 ä»¶å¥—è£è£å‚™',
        howToGet: 'æ”¶é›†ä¸¦ç²å¾—æ‰€æœ‰ 32 ä»¶å¥—è£è£å‚™ï¼ˆ4 å€‹å€åŸŸ Ã— 2 å¥— Ã— 4 ä»¶ï¼‰',
        category: 'codex_equipment',
        rarity: 'legendary',
        condition: { type: 'equipment_collected', value: 32 },
        bonus: { setBonus: 10, atk: 5, def: 5 }
    },
    
    // è£å‚™åœ–é‘‘ç¨±è™Ÿ - å€åŸŸå¥—è£
    'region_set_master_å…¥é–€é–‹ç™¼å±¤': {
        name: 'âš”ï¸ å…¥é–€è£å‚™å°ˆå®¶',
        desc: 'æ”¶é›†å…¥é–€é–‹ç™¼å±¤çš„å…©å¥—å¥—è£',
        howToGet: 'æ”¶é›†å…¥é–€é–‹ç™¼å±¤çš„å•Ÿå‹•è€…å¥—è£å’Œæš´æ“Šçµæ®ºå¥—è£',
        category: 'codex_equipment',
        rarity: 'rare',
        condition: { type: 'region_sets', region: 'å…¥é–€é–‹ç™¼å±¤', value: 2 },
        bonus: { regionDmg: 5, setBonus: 5 }
    },
    'region_set_master_ç ”ç™¼æ ¸å¿ƒå±¤': {
        name: 'ğŸ”¬ ç ”ç™¼è£å‚™å°ˆå®¶',
        desc: 'æ”¶é›†ç ”ç™¼æ ¸å¿ƒå±¤çš„å…©å¥—å¥—è£',
        howToGet: 'æ”¶é›†ç ”ç™¼æ ¸å¿ƒå±¤çš„ç ”ç™¼è€…å¥—è£å’Œç”Ÿå‘½æ±²å–å¥—è£',
        category: 'codex_equipment',
        rarity: 'rare',
        condition: { type: 'region_sets', region: 'ç ”ç™¼æ ¸å¿ƒå±¤', value: 2 },
        bonus: { regionDmg: 5, setBonus: 5 }
    },
    'region_set_master_è³‡æ–™è£‚ç¸«': {
        name: 'ğŸ’¿ è³‡æ–™è£å‚™å°ˆå®¶',
        desc: 'æ”¶é›†è³‡æ–™è£‚ç¸«çš„å…©å¥—å¥—è£',
        howToGet: 'æ”¶é›†è³‡æ–™è£‚ç¸«çš„æ©Ÿæ«ƒé˜²ç¦¦å¥—è£å’Œéµå£é˜²ç¦¦å¥—è£',
        category: 'codex_equipment',
        rarity: 'rare',
        condition: { type: 'region_sets', region: 'è³‡æ–™è£‚ç¸«', value: 2 },
        bonus: { regionDmg: 5, setBonus: 5 }
    },
    'region_set_master_æ·±äº•è‡¨ç•Œå±¤': {
        name: 'ğŸ•³ï¸ æ·±äº•è£å‚™å°ˆå®¶',
        desc: 'æ”¶é›†æ·±äº•è‡¨ç•Œå±¤çš„å…©å¥—å¥—è£',
        howToGet: 'æ”¶é›†æ·±äº•è‡¨ç•Œå±¤çš„é‡å­åŒæ­¥å¥—è£å’Œç„¡è¦–ç©¿é€å¥—è£',
        category: 'codex_equipment',
        rarity: 'rare',
        condition: { type: 'region_sets', region: 'æ·±äº•è‡¨ç•Œå±¤', value: 2 },
        bonus: { regionDmg: 5, setBonus: 5 }
    },
    
    // éš¨å¾åœ–é‘‘ç¨±è™Ÿ
    'companion_collector_5': {
        name: 'ğŸ¤– éš¨å¾æ”¶é›†è€…',
        desc: 'æ”¶é›† 5 å€‹éš¨å¾',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 5 å€‹ä¸åŒçš„éš¨å¾',
        category: 'codex_companion',
        rarity: 'common',
        condition: { type: 'companions_collected', value: 5 },
        bonus: { companionBonus: 5 }
    },
    'companion_collector_10': {
        name: 'ğŸ¤– éš¨å¾æ„›å¥½è€…',
        desc: 'æ”¶é›† 10 å€‹éš¨å¾',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 10 å€‹ä¸åŒçš„éš¨å¾',
        category: 'codex_companion',
        rarity: 'rare',
        condition: { type: 'companions_collected', value: 10 },
        bonus: { companionBonus: 10 }
    },
    'companion_collector_15': {
        name: 'ğŸ¤– éš¨å¾å°ˆå®¶',
        desc: 'æ”¶é›† 15 å€‹éš¨å¾',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 15 å€‹ä¸åŒçš„éš¨å¾',
        category: 'codex_companion',
        rarity: 'epic',
        condition: { type: 'companions_collected', value: 15 },
        bonus: { companionBonus: 15 }
    },
    'companion_collector_20': {
        name: 'ğŸ¤– éš¨å¾å¤§å¸«',
        desc: 'æ”¶é›† 20 å€‹éš¨å¾',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 20 å€‹éš¨å¾',
        category: 'codex_companion',
        rarity: 'legendary',
        condition: { type: 'companions_collected', value: 20 },
        bonus: { companionBonus: 20, atk: 3, def: 3 }
    },
    
    // éš¨å¾é¡å‹ç¨±è™Ÿ
    'companion_type_master_attack': {
        name: 'âš”ï¸ æ”»æ“Šéš¨å¾å°ˆå®¶',
        desc: 'æ”¶é›†æ‰€æœ‰æ”»æ“Šå‹éš¨å¾',
        howToGet: 'æ”¶é›†æ‰€æœ‰æ”»æ“Šå‹éš¨å¾ï¼ˆå…± 4 å€‹ï¼‰',
        category: 'codex_companion',
        rarity: 'rare',
        condition: { type: 'companion_type', companionType: 'attack', value: 4 },
        bonus: { companionAttackBonus: 15 }
    },
    'companion_type_master_defense': {
        name: 'ğŸ›¡ï¸ é˜²ç¦¦éš¨å¾å°ˆå®¶',
        desc: 'æ”¶é›†æ‰€æœ‰é˜²ç¦¦å‹éš¨å¾',
        howToGet: 'æ”¶é›†æ‰€æœ‰é˜²ç¦¦å‹éš¨å¾ï¼ˆå…± 3 å€‹ï¼‰',
        category: 'codex_companion',
        rarity: 'rare',
        condition: { type: 'companion_type', companionType: 'defense', value: 3 },
        bonus: { companionDefenseBonus: 15 }
    },
    'companion_type_master_recovery': {
        name: 'ğŸ’š æ¢å¾©éš¨å¾å°ˆå®¶',
        desc: 'æ”¶é›†æ‰€æœ‰æ¢å¾©å‹éš¨å¾',
        howToGet: 'æ”¶é›†æ‰€æœ‰æ¢å¾©å‹éš¨å¾ï¼ˆå…± 3 å€‹ï¼‰',
        category: 'codex_companion',
        rarity: 'rare',
        condition: { type: 'companion_type', companionType: 'recovery', value: 3 },
        bonus: { companionRecoveryBonus: 15 }
    },
    'companion_type_master_balanced': {
        name: 'âš–ï¸ å¹³è¡¡éš¨å¾å°ˆå®¶',
        desc: 'æ”¶é›†æ‰€æœ‰å¹³è¡¡å‹éš¨å¾',
        howToGet: 'æ”¶é›†æ‰€æœ‰å¹³è¡¡å‹éš¨å¾ï¼ˆå…± 3 å€‹ï¼‰',
        category: 'codex_companion',
        rarity: 'rare',
        condition: { type: 'companion_type', companionType: 'balanced', value: 3 },
        bonus: { companionBalancedBonus: 15 }
    },
    
    // å¡ç‰Œåœ–é‘‘ç¨±è™Ÿ
    'card_collector_10': {
        name: 'ğŸ´ å¡ç‰Œæ”¶é›†è€…',
        desc: 'æ”¶é›† 10 å¼µå¡ç‰Œ',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 10 å¼µä¸åŒçš„å¡ç‰Œ',
        category: 'codex_card',
        rarity: 'common',
        condition: { type: 'cards_collected', value: 10 },
        bonus: { cardBonus: 5 }
    },
    'card_collector_20': {
        name: 'ğŸ´ å¡ç‰Œæ„›å¥½è€…',
        desc: 'æ”¶é›† 20 å¼µå¡ç‰Œ',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 20 å¼µä¸åŒçš„å¡ç‰Œ',
        category: 'codex_card',
        rarity: 'rare',
        condition: { type: 'cards_collected', value: 20 },
        bonus: { cardBonus: 10 }
    },
    'card_collector_30': {
        name: 'ğŸ´ å¡ç‰Œå°ˆå®¶',
        desc: 'æ”¶é›† 30 å¼µå¡ç‰Œ',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 30 å¼µä¸åŒçš„å¡ç‰Œ',
        category: 'codex_card',
        rarity: 'epic',
        condition: { type: 'cards_collected', value: 30 },
        bonus: { cardBonus: 15 }
    },
    'card_collector_40': {
        name: 'ğŸ´ å¡ç‰Œå¤§å¸«',
        desc: 'æ”¶é›† 40 å¼µå¡ç‰Œ',
        howToGet: 'ç²å¾—ä¸¦æ”¶é›† 40 å¼µå¡ç‰Œ',
        category: 'codex_card',
        rarity: 'legendary',
        condition: { type: 'cards_collected', value: 40 },
        bonus: { cardBonus: 20, atk: 3, def: 3 }
    }

};


        // æŠ€èƒ½ç³»çµ±
        const SKILLS = {
    // ========== æ”»æ“Šå‹æŠ€èƒ½ï¼ˆ9å€‹ï¼‰==========
    
    // ç³»çµ±æ¶æ§‹å¸« - å¹³è¡¡è¼¸å‡º
    'æ¨¡çµ„åŒ–æ‰“æ“Š': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 30, 
        damageMultiplier: 1.6, 
        desc: 'æ”»æ“Šæ™‚30%æ©Ÿç‡é€ æˆ160%å‚·å®³' 
    },
    
    // æš´åŠ›æ¸¬è©¦å“¡ - é«˜çˆ†ç™¼
    'å£“åŠ›æ¸¬è©¦': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 22, 
        damageMultiplier: 2.2, 
        desc: 'æ”»æ“Šæ™‚22%æ©Ÿç‡é€ æˆ220%å‚·å®³' 
    },
    
    // æ»¿é€å·¥ç¨‹å¸« - ç²¾æº–æ‰“æ“Š
    'æ¼æ´åˆ©ç”¨': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 26, 
        damageMultiplier: 1.9, 
        desc: 'æ”»æ“Šæ™‚26%æ©Ÿç‡é€ æˆ190%å‚·å®³' 
    },
    
    // æ•¸æ“šç§‘å­¸å®¶ - ç©©å®šè¼¸å‡º
    'æ•¸æ“šçˆ†ç ´': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 32, 
        damageMultiplier: 1.5, 
        desc: 'æ”»æ“Šæ™‚32%æ©Ÿç‡é€ æˆ150%å‚·å®³' 
    },
    
    // å‰ç«¯é–‹ç™¼è€… - å¿«é€Ÿæ”»æ“Š
    'å¿«é€Ÿè¿­ä»£': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 35, 
        damageMultiplier: 1.4, 
        desc: 'æ”»æ“Šæ™‚35%æ©Ÿç‡é€ æˆ140%å‚·å®³' 
    },
    
    // å€å¡Šéˆå·¥ç¨‹å¸« - éˆå¼æ”»æ“Š
    'å€å¡Šçˆ†ç ´': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 24, 
        damageMultiplier: 2.0, 
        desc: 'æ”»æ“Šæ™‚24%æ©Ÿç‡é€ æˆ200%å‚·å®³' 
    },
    
    // AIè¨“ç·´å¸« - æ¥µé™çˆ†ç™¼
    'ç¥ç¶“çˆ†ç™¼': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 18, 
        damageMultiplier: 2.5, 
        desc: 'æ”»æ“Šæ™‚18%æ©Ÿç‡é€ æˆ250%å‚·å®³' 
    },
    
    // é›²ç«¯æ¶æ§‹å¸« - å½ˆæ€§è¼¸å‡º
    'é›²ç«¯æ‰“æ“Š': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 28, 
        damageMultiplier: 1.7, 
        desc: 'æ”»æ“Šæ™‚28%æ©Ÿç‡é€ æˆ170%å‚·å®³' 
    },
    
    // é‹ç¶­å·¥ç¨‹å¸« - ç©©å®šå‚·å®³
    'ç³»çµ±è¡æ“Š': { 
        type: 'attack', 
        trigger: 'onAttack', 
        chance: 30, 
        damageMultiplier: 1.5, 
        desc: 'æ”»æ“Šæ™‚30%æ©Ÿç‡é€ æˆ150%å‚·å®³' 
    },

    // ========== åæ“Šå‹æŠ€èƒ½ï¼ˆ9å€‹ï¼‰==========
    
    // ç³»çµ±æ¶æ§‹å¸« - æ¶æ§‹ååˆ¶
    'æ¶æ§‹ååˆ¶': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 25, 
        damageMultiplier: 0.6, 
        desc: 'å—æ“Šæ™‚25%æ©Ÿç‡åæ“Š60%å‚·å®³' 
    },
    
    // æš´åŠ›æ¸¬è©¦å“¡ - æš´åŠ›åæ“Š
    'åå‘æ¸¬è©¦': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 22, 
        damageMultiplier: 1.6, 
        desc: 'å—æ“Šæ™‚22%æ©Ÿç‡åæ“Šé€ æˆ160%å‚·å®³' 
    },
    
    // æ»¿é€å·¥ç¨‹å¸« - ç²¾æº–åæ“Š
    'éŒ¯èª¤å›æº¯': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 20, 
        damageMultiplier: 0.8, 
        desc: 'å—æ“Šæ™‚20%æ©Ÿç‡åæ“Š80%å‚·å®³' 
    },
    
    // æ•¸æ“šç§‘å­¸å®¶ - æ•¸æ“šåé¥‹
    'æ•¸æ“šåé¥‹': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 30, 
        damageMultiplier: 1.2, 
        desc: 'å—æ“Šæ™‚30%æ©Ÿç‡åæ“Šé€ æˆ120%å‚·å®³' 
    },
    
    // é‹ç¶­å·¥ç¨‹å¸« - æ•…éšœè½‰ç§»
    'ç³»çµ±é‚„åŸ': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 35, 
        damageMultiplier: 0.4, 
        desc: 'å—æ“Šæ™‚35%æ©Ÿç‡åæ“Š40%å‚·å®³' 
    },
    
    // å‰ç«¯é–‹ç™¼è€… - éŸ¿æ‡‰åæ“Š
    'éŸ¿æ‡‰åæ“Š': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 26, 
        damageMultiplier: 1.4, 
        desc: 'å—æ“Šæ™‚26%æ©Ÿç‡åæ“Šé€ æˆ140%å‚·å®³' 
    },
    
    // å€å¡Šéˆå·¥ç¨‹å¸« - å…±è­˜åæ“Š
    'å…±è­˜åæ“Š': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 24, 
        damageMultiplier: 1.5, 
        desc: 'å—æ“Šæ™‚24%æ©Ÿç‡åæ“Šé€ æˆ150%å‚·å®³' 
    },
    
    // AIè¨“ç·´å¸« - å­¸ç¿’ååˆ¶
    'å­¸ç¿’ååˆ¶': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 20, 
        damageMultiplier: 1.7, 
        desc: 'å—æ“Šæ™‚20%æ©Ÿç‡åæ“Šé€ æˆ170%å‚·å®³' 
    },
    
    // é›²ç«¯æ¶æ§‹å¸« - å®¹ç½åæ“Š
    'å®¹ç½åæ“Š': { 
        type: 'counter', 
        trigger: 'onHitTaken', 
        chance: 28, 
        damageMultiplier: 1.3, 
        desc: 'å—æ“Šæ™‚28%æ©Ÿç‡åæ“Šé€ æˆ130%å‚·å®³' 
    },

    // ========== å¢ç›Šå‹æŠ€èƒ½ï¼ˆ9å€‹ï¼‰==========
    
    // ç³»çµ±æ¶æ§‹å¸« - æ¶æ§‹å„ªåŒ–ï¼ˆæ”»é˜²å¹³è¡¡ï¼‰
    'æ¶æ§‹å„ªåŒ–': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 28, 
        duration: 5, 
        effects: { atk: 10, def: 120 }, 
        desc: 'æ”»æ“Šæ™‚28%æ©Ÿç‡è§¸ç™¼ï¼šæ”»æ“Š+10%ã€è­·ç”²+120ï¼ŒæŒçºŒ5å›åˆ' 
    },
    
    // æš´åŠ›æ¸¬è©¦å“¡ - éè¼‰æ¨¡å¼ï¼ˆæ¥µé™æ”»æ“Šï¼‰
    'éè¼‰æ¨¡å¼': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 22, 
        duration: 4, 
        effects: { atk: 18, crit: 8 }, 
        desc: 'æ”»æ“Šæ™‚22%æ©Ÿç‡è§¸ç™¼ï¼šæ”»æ“Š+18%ã€æš´æ“Šç‡+8%ï¼ŒæŒçºŒ4å›åˆ' 
    },
    
    // æ»²é€å·¥ç¨‹å¸« - æ¬Šé™æå‡ï¼ˆæš´æ“Šå¼·åŒ–ï¼‰
    'æ¬Šé™æå‡': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 25, 
        duration: 5, 
        effects: { crit: 10, atk: 8 }, 
        desc: 'æ”»æ“Šæ™‚25%æ©Ÿç‡è§¸ç™¼ï¼šæš´æ“Šç‡+10%ã€æ”»æ“Š+8%ï¼ŒæŒçºŒ5å›åˆ' 
    },
    
    // æ•¸æ“šç§‘å­¸å®¶ - æ·±åº¦å­¸ç¿’ï¼ˆå…¨é¢æå‡ï¼‰
    'æ·±åº¦å­¸ç¿’': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 26, 
        duration: 6, 
        effects: { atk: 12, crit: 6 }, 
        desc: 'æ”»æ“Šæ™‚26%æ©Ÿç‡è§¸ç™¼ï¼šæ”»æ“Š+12%ã€æš´æ“Šç‡+6%ï¼ŒæŒçºŒ6å›åˆ' 
    },
    
    // é‹ç¶­å·¥ç¨‹å¸« - ç³»çµ±åŠ å›ºï¼ˆé˜²ç¦¦å¼·åŒ–ï¼‰
    'ç³»çµ±åŠ å›º': { 
        type: 'buff', 
        trigger: 'onHitTaken', 
        chance: 28, 
        duration: 5, 
        effects: { def: 200, damageReduction: 12 }, 
        desc: 'å—æ“Šæ™‚28%æ©Ÿç‡è§¸ç™¼ï¼šè­·ç”²+200ã€æ¸›å‚·+12%ï¼ŒæŒçºŒ5å›åˆ' 
    },
    
    // å‰ç«¯é–‹ç™¼è€… - è¦–è¦ºå¢å¼·ï¼ˆæ”»æ“Šæš´æ“Šï¼‰
    'è¦–è¦ºå¢å¼·': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 30, 
        duration: 4, 
        effects: { atk: 14, crit: 7 }, 
        desc: 'æ”»æ“Šæ™‚30%æ©Ÿç‡è§¸ç™¼ï¼šæ”»æ“Š+14%ã€æš´æ“Šç‡+7%ï¼ŒæŒçºŒ4å›åˆ' 
    },
    
    // å€å¡Šéˆå·¥ç¨‹å¸« - æ™ºèƒ½åˆç´„ï¼ˆæ”»é˜²å…¼å‚™ï¼‰
    'æ™ºèƒ½åˆç´„': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 24, 
        duration: 6, 
        effects: { atk: 10, def: 150 }, 
        desc: 'æ”»æ“Šæ™‚24%æ©Ÿç‡è§¸ç™¼ï¼šæ”»æ“Š+10%ã€è­·ç”²+150ï¼ŒæŒçºŒ6å›åˆ' 
    },
    
    // AIè¨“ç·´å¸« - æ¨¡å‹å„ªåŒ–ï¼ˆæš´æ“Šæ¥µé™ï¼‰
    'æ¨¡å‹å„ªåŒ–': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 20, 
        duration: 4, 
        effects: { crit: 12, atk: 10 }, 
        desc: 'æ”»æ“Šæ™‚20%æ©Ÿç‡è§¸ç™¼ï¼šæš´æ“Šç‡+12%ã€æ”»æ“Š+10%ï¼ŒæŒçºŒ4å›åˆ' 
    },
    
    // é›²ç«¯æ¶æ§‹å¸« - å½ˆæ€§æ“´å±•ï¼ˆå…¨é¢å¢ç›Šï¼‰
    'å½ˆæ€§æ“´å±•': { 
        type: 'buff', 
        trigger: 'onAttack', 
        chance: 26, 
        duration: 5, 
        effects: { atk: 12, def: 100 }, 
        desc: 'æ”»æ“Šæ™‚26%æ©Ÿç‡è§¸ç™¼ï¼šæ”»æ“Š+12%ã€è­·ç”²+100ï¼ŒæŒçºŒ5å›åˆ' 
    }
};

        // ========== ç°¡åŒ–ç‰ˆçµ±è¨ˆè¿½è¹¤ç³»çµ± ==========
        // æ­¤ç‰ˆæœ¬é¿å…äº†è¤‡é›œçš„æ•´åˆï¼Œåªåœ¨å¿…è¦è™•æ·»åŠ è¿½è¹¤
        
        // 1. æ“´å±• initStats å‡½æ•¸
        function initStatsExtended() {
            if (!gameState.stats) {
                gameState.stats = {};
            }
            
            // æˆ°é¬¥çµ±è¨ˆ
            if (gameState.stats.critCount === undefined) gameState.stats.critCount = 0;
            if (gameState.stats.winStreak === undefined) gameState.stats.winStreak = 0;
            if (gameState.stats.maxWinStreak === undefined) gameState.stats.maxWinStreak = 0;
            
            // è²¡å¯Œçµ±è¨ˆ
            if (gameState.stats.totalGoldEarned === undefined) gameState.stats.totalGoldEarned = 0;
            if (gameState.stats.totalShardsEarned === undefined) gameState.stats.totalShardsEarned = 0;
            if (gameState.stats.totalExpEarned === undefined) gameState.stats.totalExpEarned = 0;
            
            // å•†åº—çµ±è¨ˆ
            if (gameState.stats.shopPurchases === undefined) gameState.stats.shopPurchases = 0;
        }
        
        // 2. è¿½è¹¤é‡‘å¹£ç²å¾—
        function trackGoldGain(amount) {
            initStatsExtended();
            gameState.stats.totalGoldEarned += amount;
            
            // æª¢æŸ¥è²¡å¯Œç¨±è™Ÿ
            if (gameState.stats.totalGoldEarned >= 5000000) {
                unlockTitle('wealth_king');
            } else if (gameState.stats.totalGoldEarned >= 1000000) {
                unlockTitle('gold_tycoon_pro');
            } else if (gameState.stats.totalGoldEarned >= 500000) {
                unlockTitle('wealthy');
            } else if (gameState.stats.totalGoldEarned >= 50000) {
                unlockTitle('small_fortune');
            }
        }
        
        // 3. è¿½è¹¤ç¢ç‰‡ç²å¾—
        function trackShardsGain(amount) {
            initStatsExtended();
            gameState.stats.totalShardsEarned += amount;
            
            // æª¢æŸ¥ç¢ç‰‡ç¨±è™Ÿ
            if (gameState.stats.totalShardsEarned >= 50000) {
                unlockTitle('shard_wealthy');
            } else if (gameState.stats.totalShardsEarned >= 20000) {
                unlockTitle('shard_expert_pro');
            } else if (gameState.stats.totalShardsEarned >= 5000) {
                unlockTitle('shard_collector_pro');
            }
        }
        
        // 4. è¿½è¹¤ç¶“é©—ç²å¾—
        function trackExpGain(amount) {
            initStatsExtended();
            gameState.stats.totalExpEarned += amount;
            
            // æª¢æŸ¥ç¶“é©—ç¨±è™Ÿ
            if (gameState.stats.totalExpEarned >= 1000000) {
                unlockTitle('exp_god');
            } else if (gameState.stats.totalExpEarned >= 500000) {
                unlockTitle('exp_maniac');
            } else if (gameState.stats.totalExpEarned >= 100000) {
                unlockTitle('exp_master_pro');
            }
        }
        
        // 5. è¿½è¹¤æš´æ“Š
        function trackCrit() {
            initStatsExtended();
            gameState.stats.critCount++;
            
            // æª¢æŸ¥æš´æ“Šç¨±è™Ÿ
            if (gameState.stats.critCount >= 5000) {
                unlockTitle('crit_god');
            } else if (gameState.stats.critCount >= 2000) {
                unlockTitle('crit_expert_pro');
            } else if (gameState.stats.critCount >= 500) {
                unlockTitle('crit_lover');
            }
        }
        
        // 6. è¿½è¹¤é€£å‹
        function trackWinStreak() {
            initStatsExtended();
            gameState.stats.winStreak++;
            
            if (gameState.stats.winStreak > gameState.stats.maxWinStreak) {
                gameState.stats.maxWinStreak = gameState.stats.winStreak;
            }
            
            // æª¢æŸ¥é€£å‹ç¨±è™Ÿ
            if (gameState.stats.maxWinStreak >= 30) {
                unlockTitle('combo_master');
            } else if (gameState.stats.maxWinStreak >= 20) {
                unlockTitle('combo_expert');
            } else if (gameState.stats.maxWinStreak >= 10) {
                unlockTitle('combo_novice');
            }
        }
        
        // 7. é‡ç½®é€£å‹
        function resetWinStreak() {
            initStatsExtended();
            gameState.stats.winStreak = 0;
        }
        
        // 8. è¿½è¹¤å•†åº—è³¼è²·
        function trackShopPurchase() {
            initStatsExtended();
            gameState.stats.shopPurchases++;
            
            // æª¢æŸ¥å•†åº—ç¨±è™Ÿ
            if (gameState.stats.shopPurchases >= 50) {
                unlockTitle('business_master');
            }
        }
        
        // è¿­ä»£å¤©è³¦ç³»çµ±
// å€åŸŸå°ˆå±¬æ¶ˆè€—å“
const REGION_CONSUMABLES = {
    'å…¥é–€é–‹ç™¼å±¤': {
        hp: { name: 'å°å‹ç”Ÿå‘½è—¥æ°´', type: 'hp', recovery: 0.20, dropRate: 0.05 }, // 0.30 â†’ 0.20 (-33%)
        ap: { name: 'å°å‹èƒ½é‡è—¥æ°´', type: 'ap', recovery: 5, dropRate: 0.03 },
        exp: { name: 'å°å‹ç¶“é©—å·è»¸', type: 'exp', exp: 500, dropRate: 0.02 },
        lucky: { name: 'å¹¸é‹ç¡¬å¹£', type: 'lucky', dropRate: 0.005 },
        expBoost: { name: 'é›™å€ç¶“é©—å·', type: 'expBoost', dropRate: 0.008 }
    },
    'ç ”ç™¼æ ¸å¿ƒå±¤': {
        hp: { name: 'ä¸­å‹ç”Ÿå‘½è—¥æ°´', type: 'hp', recovery: 0.40, dropRate: 0.03 }, // 0.50 â†’ 0.40 (-20%)
        ap: { name: 'ä¸­å‹èƒ½é‡è—¥æ°´', type: 'ap', recovery: 10, dropRate: 0.02 },
        exp: { name: 'ä¸­å‹ç¶“é©—å·è»¸', type: 'exp', exp: 2000, dropRate: 0.015 },
        lucky: { name: 'å¹¸é‹ç¡¬å¹£', type: 'lucky', dropRate: 0.005 },
        expBoost: { name: 'é›™å€ç¶“é©—å·', type: 'expBoost', dropRate: 0.008 }
    },
    'è³‡æ–™è£‚ç¸«': {
        hp: { name: 'å¤§å‹ç”Ÿå‘½è—¥æ°´', type: 'hp', recovery: 0.60, dropRate: 0.02 }, // 0.80 â†’ 0.60 (-25%)
        ap: { name: 'å¤§å‹èƒ½é‡è—¥æ°´', type: 'ap', recovery: 20, dropRate: 0.015 },
        exp: { name: 'å¤§å‹ç¶“é©—å·è»¸', type: 'exp', exp: 8000, dropRate: 0.01 },
        lucky: { name: 'å¹¸é‹ç¡¬å¹£', type: 'lucky', dropRate: 0.005 },
        expBoost: { name: 'é›™å€ç¶“é©—å·', type: 'expBoost', dropRate: 0.008 },
        protection: { name: 'ä¿è­·ç¬¦å’’', type: 'protection', dropRate: 0.003 }
    },
    'æ·±äº•è‡¨ç•Œå±¤': {
        hp: { name: 'å®Œå…¨ç”Ÿå‘½è—¥æ°´', type: 'hp', recovery: 0.75, dropRate: 0.01 }, // 1.00 â†’ 0.75 (-25%)
        ap: { name: 'å®Œå…¨èƒ½é‡è—¥æ°´', type: 'ap', recovery: 40, dropRate: 0.008 },
        exp: { name: 'å®Œç¾ç¶“é©—å·è»¸', type: 'exp', exp: 20000, dropRate: 0.005 },
        lucky: { name: 'å¹¸é‹ç¡¬å¹£', type: 'lucky', dropRate: 0.005 },
        expBoost: { name: 'é›™å€ç¶“é©—å·', type: 'expBoost', dropRate: 0.008 },
        protection: { name: 'ä¿è­·ç¬¦å’’', type: 'protection', dropRate: 0.003 }
    }
};

        // ========== ç‰¹æ®ŠBOSS ==========
        const SPECIAL_BOSSES = {
            'å…¥é–€é–‹ç™¼å±¤': {
                name: 'ç‹‚æš´æ­»ç¥',
                icon: 'ğŸ”¥ğŸ’€',
                abilities: [
                    { id: 'berserk', name: 'ç‹‚æš´', icon: 'ğŸ”¥', effect: { atkMultiplier: 1.3 }, reward: { goldMultiplier: 1.2, expMultiplier: 1.2 } },
                    { id: 'enraged', name: 'ç‹‚æ€’', icon: 'âš”ï¸', effect: { lowHpAtkBonus: 0.5, lowHpThreshold: 0.5 }, reward: { goldMultiplier: 1.3, expMultiplier: 1.3 } },
                    { id: 'vampiric', name: 'å—œè¡€', icon: 'ğŸ©¸', effect: { lifeSteal: 0.2 }, reward: { goldMultiplier: 1.2, expMultiplier: 1.2 } }
                ],
                stats: { hpMultiplier: 5.0, atkMultiplier: 2.2, defMultiplier: 1.8, critRate: 0.10, critDamage: 0.30 },
                rewardMultiplier: 6.0
            },
            'ç ”ç™¼æ ¸å¿ƒå±¤': {
                name: 'è™›ç©ºå¹½éˆ',
                icon: 'âš¡ğŸ‘»',
                abilities: [
                    { id: 'void', name: 'è™›ç©º', icon: 'ğŸ•³ï¸', effect: { armorPen: 0.5, lifeSteal: 0.25 }, reward: { goldMultiplier: 1.45, expMultiplier: 1.45 } },
                    { id: 'evasive', name: 'é–ƒé¿', icon: 'âš¡', effect: { dodgeChance: 0.3 }, reward: { goldMultiplier: 1.35, expMultiplier: 1.35 } },
                    { id: 'temporal', name: 'æ™‚ç©º', icon: 'â³', effect: { resetChance: 0.2 }, reward: { goldMultiplier: 1.5, expMultiplier: 1.5 } }
                ],
                stats: { hpMultiplier: 4.5, atkMultiplier: 2.5, defMultiplier: 1.6, critRate: 0.15, critDamage: 0.40 },
                rewardMultiplier: 7.0
            },
            'è³‡æ–™è£‚ç¸«': {
                name: 'æ°¸æ†æ³°å¦',
                icon: 'ğŸ’ğŸŒŠ',
                abilities: [
                    { id: 'resilient', name: 'å …éŸŒ', icon: 'ğŸ›¡ï¸', effect: { defMultiplier: 1.4, hpMultiplier: 1.3 }, reward: { goldMultiplier: 1.2, expMultiplier: 1.2 } },
                    { id: 'tidal', name: 'æ½®æ±', icon: 'ğŸŒŠ', effect: { lowHpDefMultiplier: 2.0, lowHpThreshold: 0.3 }, reward: { goldMultiplier: 1.25, expMultiplier: 1.25 } },
                    { id: 'regenerative', name: 'å†ç”Ÿ', icon: 'ğŸ’š', effect: { regen: 0.05 }, reward: { goldMultiplier: 1.3, expMultiplier: 1.3 } },
                    { id: 'thorny', name: 'å†°ç”²', icon: 'ğŸ§Š', effect: { reflect: 0.15 }, reward: { goldMultiplier: 1.2, expMultiplier: 1.2 } }
                ],
                stats: { hpMultiplier: 6.0, atkMultiplier: 2.0, defMultiplier: 2.5, critRate: 0.05, critDamage: 0.20 },
                rewardMultiplier: 8.0
            },
            'æ·±äº•è‡¨ç•Œå±¤': {
                name: 'ä¸æ»…é­”ç¥',
                icon: 'â˜ ï¸âœ¨',
                abilities: [
                    { id: 'immortal', name: 'ä¸æ»…', icon: 'â°', effect: { revive: true, revivePercent: 0.5 }, reward: { goldMultiplier: 1.8, expMultiplier: 1.8, dropBonus: 0.4 } },
                    { id: 'deadly', name: 'è‡´å‘½', icon: 'ğŸ’€', effect: { critRate: 0.2, critDamage: 0.5 }, reward: { goldMultiplier: 1.25, expMultiplier: 1.25 } },
                    { id: 'swift', name: 'é€£æ“Š', icon: 'âš¡', effect: { doubleAttackChance: 0.3 }, reward: { goldMultiplier: 1.2, expMultiplier: 1.2 } },
                    { id: 'astral', name: 'æ˜Ÿç•Œ', icon: 'ğŸ’«', effect: { stackingAtk: 0.03, maxStacks: 8 }, reward: { goldMultiplier: 1.3, expMultiplier: 1.3 } },
                    { id: 'ironclad', name: 'é‹¼éµ', icon: 'ğŸ’', effect: { damageReduction: 0.12 }, reward: { goldMultiplier: 1.2, expMultiplier: 1.2 } }
                ],
                stats: { hpMultiplier: 5.5, atkMultiplier: 2.8, defMultiplier: 2.2, critRate: 0.25, critDamage: 0.60 },
                rewardMultiplier: 10.0
            }
        };
        
        // ========== ç²¾è‹±æ€ªç‰© ==========
        const ELITE_MONSTERS = {
            'å…¥é–€é–‹ç™¼å±¤': [
                { name: 'é›»æµè¿½è¹¤è€…', icon: 'âš¡ğŸ”Œ' },
                { name: 'æ™¶çŸ³å®ˆè­·è€…', icon: 'ğŸ’ğŸ›¡ï¸' },
                { name: 'æ€’ç„°ç‹‚å¾’', icon: 'ğŸ”¥ğŸ’¢' },
                { name: 'æ˜Ÿå…‰å“¨å…µ', icon: 'ğŸŒŸğŸ—¡ï¸' }
            ],
            'ç ”ç™¼æ ¸å¿ƒå±¤': [
                { name: 'é¢¨æš´è¡Œè€…', icon: 'ğŸŒªï¸âš”ï¸' },
                { name: 'çƒˆç„°å›ä¸»', icon: 'ğŸ”¥ğŸ‘‘' },
                { name: 'æš—å½±åŠè–', icon: 'âš”ï¸ğŸŒ‘' },
                { name: 'æ³°å¦çŸ³è¡›', icon: 'ğŸ—¿ğŸ’ª' }
            ],
            'è³‡æ–™è£‚ç¸«': [
                { name: 'è™›ç©ºè¡Œåˆ‘è€…', icon: 'ğŸ‘»ğŸ—¡ï¸' },
                { name: 'é›·éœ†åŸ·æ³•è€…', icon: 'âš¡âš–ï¸' },
                { name: 'æ˜Ÿç•Œè¡“å£«', icon: 'ğŸŒŒğŸ”®' },
                { name: 'æš—å¤œéœ¸ä¸»', icon: 'ğŸºğŸ‘‘' }
            ],
            'æ·±äº•è‡¨ç•Œå±¤': [
                { name: 'ç…‰ç„æš´å›', icon: 'ğŸ”¥ğŸ˜ˆ' },
                { name: 'é–ƒé›»éœ¸ç‹', icon: 'âš¡ğŸ‘‘' },
                { name: 'æ­»ç¥ä½¿è€…', icon: 'ğŸ’€ğŸ—¡ï¸' },
                { name: 'æ¥µå¯’é­”å›', icon: 'â„ï¸ğŸ‘‘' }
            ]
        };
        
        // ========== å€åŸŸBoss ==========
        const REGION_BOSSES = {
            'å…¥é–€é–‹ç™¼å±¤': { name: 'æ•¸æ“šå®ˆé–€è€…', icon: 'âš”ï¸ğŸšª' },
            'ç ”ç™¼æ ¸å¿ƒå±¤': { name: 'æ ¸å¿ƒç›£å¯Ÿå®˜', icon: 'ğŸ‘ï¸âš¡' },
            'è³‡æ–™è£‚ç¸«': { name: 'è£‚ç¸«ä¸»å­°', icon: 'ğŸ’€ğŸ‘‘' },
            'æ·±äº•è‡¨ç•Œå±¤': { name: 'æ·±æ·µéœ¸ä¸»', icon: 'ğŸ˜ˆğŸ‘‘' }
        };

        const REGIONS = [
            { name: 'å…¥é–€é–‹ç™¼å±¤', level: 1, difficulty: 1.0, reward: 1.0 },
            { name: 'ç ”ç™¼æ ¸å¿ƒå±¤', level: 26, difficulty: 1.2, reward: 1.3 },
            { name: 'è³‡æ–™è£‚ç¸«', level: 51, difficulty: 1.6, reward: 1.7 },
            { name: 'æ·±äº•è‡¨ç•Œå±¤', level: 76, difficulty: 2.2, reward: 2.3 }
        ];

        const MONSTERS = {
            'å…¥é–€é–‹ç™¼å±¤': [
                { name: 'è¿·ä½ å²èŠå§†', icon: 'ğŸŸ¢' },
                { name: 'å·¥åŠé¼ ', icon: 'ğŸ€' },
                { name: 'ç¤¦æ´è™è ', icon: 'ğŸ¦‡' },
                { name: 'è¦‹ç¿’å“¥å¸ƒæ—', icon: 'ğŸ‘º' },
                { name: 'æœ¨æ£å¼·ç›œ', icon: 'ğŸ¹' },
                { name: 'æµå¯‡å¼“æ‰‹', icon: 'ğŸ¯' },
                { name: 'æµæµªé‡çŠ¬', icon: 'ğŸ•' },
                { name: 'éŠ…ç”²ç”²èŸ²', icon: 'ğŸª²' }
            ],
            'ç ”ç™¼æ ¸å¿ƒå±¤': [
                { name: 'é‹¼æ®¼ç”²èŸ²', icon: 'ğŸª²' },
                { name: 'æ£®æ—ç°ç‹¼', icon: 'ğŸº' },
                { name: 'ç›œè³Šåˆºå®¢', icon: 'ğŸ¥·' },
                { name: 'ç«ç„°å­¸å¾’', icon: 'ğŸ”¥' },
                { name: 'çŸ³åƒé¬¼', icon: 'ğŸ—¿' },
                { name: 'éª·é«å…µ', icon: 'ğŸ’€' },
                { name: 'é‡ç›¾å“¥å¸ƒæ—', icon: 'ğŸ›¡ï¸' },
                { name: 'éœ§æ—å¼“æ‰‹', icon: 'ğŸ¹' }
            ],
            'è³‡æ–™è£‚ç¸«': [
                { name: 'é»‘é¬ƒæƒ¡ç‹¼', icon: 'ğŸº' },
                { name: 'æš—å½±åˆºå®¢', icon: 'ğŸ¥·' },
                { name: 'å·«éª¨æ³•å¸«', icon: 'ğŸ§™' },
                { name: 'æ·±ç©´å·¨è™è ', icon: 'ğŸ¦‡' },
                { name: 'å²©ç”²é­”èŸ¹', icon: 'ğŸ¦€' },
                { name: 'å¼©æ‰‹å¼·ç›œ', icon: 'ğŸ¯' },
                { name: 'æ³¥å²©å·¨äºº', icon: 'ğŸ§Œ' },
                { name: 'äº¡éˆå¼“æ‰‹', icon: 'ğŸ’€' }
            ],
            'æ·±äº•è‡¨ç•Œå±¤': [
                { name: 'åœ°ç„çµçŠ¬', icon: 'ğŸ•â€ğŸ¦º' },
                { name: 'é­…å½±åˆºå®¢', icon: 'ğŸ‘»' },
                { name: 'å¹½å†¥éª·é«', icon: 'ğŸ’€' },
                { name: 'ç†”å²©å·¨äºº', icon: 'ğŸ”¥' },
                { name: 'é›·éœ†é­”èœ¥', icon: 'âš¡' },
                { name: 'é­…å½±å¼“æ‰‹', icon: 'ğŸ‘»' },
                { name: 'æš—é»‘è¡“å£«', icon: 'ğŸ§™â€â™‚ï¸' },
                { name: 'å¯’éœœé­”éˆ', icon: 'â„ï¸' }
            ]
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        const RARITIES = [
            { name: 'common', label: 'ç ´èˆŠ', color: '#9E9E9E', shards: 1, multiplier: 1.2 },
            { name: 'uncommon', label: 'å„ªè³ª', color: '#4CAF50', shards: 2, multiplier: 1.6 },
            { name: 'fine', label: 'ç²¾è‰¯', color: '#2196F3', shards: 3, multiplier: 2.2 },
            { name: 'rare', label: 'ç¨€æœ‰', color: '#9C27B0', shards: 5, multiplier: 3.0 },
            { name: 'epic', label: 'å²è©©', color: '#FF6D00', shards: 8, multiplier: 4.2 },
            { name: 'legendary', label: 'å‚³èªª', color: '#FFD700', shards: 12, multiplier: 6.0 },
            { name: 'mythic', label: 'ç¥è©±', color: '#F44336', shards: 20, multiplier: 8.5 },
            { name: 'eternal', label: 'æ°¸æ†', color: '#E040FB', shards: 35, multiplier: 12.0 },
            { name: 'set', label: 'å¥—è£', color: '#00BCD4', shards: 15, multiplier: 25.0 }
        ];

        // å…ƒç´ ç³»çµ±
        const ELEMENTS = {
            fire: {
                name: 'ç«å…ƒç´ ',
                icon: 'ğŸ”¥',
                color: '#FF6B35',
                effect: 'burn',
                effectChance: 0.2,
                effectValue: 0.05,
                effectDuration: 3,
                strongAgainst: 'ice',
                weakAgainst: 'water',
                description: 'æ”»æ“Šæ™‚20%æ©Ÿç‡ç¼ç‡’æ•µäººï¼ˆ5% HPÃ—3å›åˆï¼‰'
            },
            ice: {
                name: 'å†°å…ƒç´ ',
                icon: 'â„ï¸',
                color: '#4FC3F7',
                effect: 'freeze',
                effectChance: 0.25,
                effectValue: 0.2,
                effectDuration: 2,
                strongAgainst: 'water',
                weakAgainst: 'fire',
                description: 'æ”»æ“Šæ™‚25%æ©Ÿç‡é™ä½æ•µäººæ”»æ“ŠåŠ›20%ï¼ˆ2å›åˆï¼‰'
            },
            thunder: {
                name: 'é›·å…ƒç´ ',
                icon: 'âš¡',
                color: '#FFD700',
                effect: 'shock',
                effectChance: 0.15,
                effectValue: 2.0,
                effectDuration: 0,
                strongAgainst: 'water',
                weakAgainst: 'earth',
                description: 'æš´æ“Šç‡+10%ï¼Œæš´æ“Šæ™‚15%æ©Ÿç‡é›™å€æš´æ“Šå‚·å®³'
            },
            poison: {
                name: 'æ¯’å…ƒç´ ',
                icon: 'ğŸŒ¿',
                color: '#66BB6A',
                effect: 'poison',
                effectChance: 0.3,
                effectValue: 0.03,
                effectDuration: 5,
                strongAgainst: 'earth',
                weakAgainst: null,
                description: 'æ”»æ“Šæ™‚30%æ©Ÿç‡ä¸­æ¯’ï¼ˆ3% HPÃ—5å›åˆï¼‰'
            },
            earth: {
                name: 'åœŸå…ƒç´ ',
                icon: 'ğŸŒ',
                color: '#A1887F',
                effect: 'shield',
                effectChance: 0.2,
                effectValue: 0.3,
                effectDuration: 0,
                strongAgainst: 'thunder',
                weakAgainst: 'poison',
                description: 'é˜²ç¦¦+15%ï¼Œå—å‚·æ™‚20%æ©Ÿç‡æ¸›å°‘30%å‚·å®³'
            }
        };

        // å…ƒç´ é™„åŠ æ©Ÿç‡ï¼ˆæ ¹æ“šå“è³ªï¼‰
        const ELEMENT_CHANCE_BY_RARITY = {
            'common': 0,
            'uncommon': 5,
            'fine': 10,
            'rare': 20,
            'epic': 35,
            'legendary': 50,
            'mythic': 70,
            'eternal': 100
        };

        // æ€ªç‰©å…ƒç´ æ©Ÿç‡
        const MONSTER_ELEMENT_CHANCE = {
            'normal': 20,
            'elite': 40,
            'boss': 60
        };

        const EQUIPMENT_SETS = {
            'å…¥é–€é–‹ç™¼å±¤': {
                setName: 'å•Ÿå‹•è€…å¥—è£',
                items: [
                    // æ­¦å™¨ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'weapon', name: 'èª¿è©¦çŸ­åŠ', atk: 45, crit: 3, armorPen: 4, bossDmg: 3 },
                    // é˜²å…·ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'armor', name: 'é ç·¨å¤–å¥—', def: 38, hp: 125, dmgRed: 3, lifeSteal: 1.2 },
                    // é£¾å“1ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'ç·¨è­¯è€…æŒ‡ç’°', atk: 20, def: 20, hp: 75, crit: 2, critDmg: 8, lifeSteal: 1.2, bossDmg: 2 },
                    // é£¾å“2ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'å•Ÿå‹•è€…å¾½ç« ', atk: 18, def: 18, hp: 88, crit: 2, critDmg: 8, dmgRed: 2, armorPen: 2 }
                ]
            },
            'ç ”ç™¼æ ¸å¿ƒå±¤': {
                setName: 'ç ”ç™¼è€…å¥—è£',
                items: [
                    // æ­¦å™¨ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'weapon', name: 'ç›¸ä½é•·æ§', atk: 50, crit: 4, critDmg: 6, armorPen: 5, bossDmg: 2.67 },
                    // é˜²å…·ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'armor', name: 'å¯¦é©—å®¤èƒ¸ç”²', def: 40, hp: 150, dmgRed: 3.5, lifeSteal: 1 },
                    // é£¾å“1ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'åŸå‹è­·ç¬¦', atk: 23, def: 23, hp: 88, crit: 3, critDmg: 10, lifeSteal: 1.2, armorPen: 2 },
                    // é£¾å“2ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'æ ¡æº–æŒ‡ç’°', atk: 20, def: 20, hp: 100, crit: 2, critDmg: 10, dmgRed: 3, bossDmg: 2 }
                ]
            },
            'è³‡æ–™è£‚ç¸«': {
                setName: 'æ©Ÿæ«ƒé˜²ç¦¦å¥—è£',
                items: [
                    // æ­¦å™¨ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'weapon', name: 'è² è¼‰å‡è¡¡å¼“', atk: 55, crit: 4, armorPen: 6, bossDmg: 2 },
                    // é˜²å…·ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'armor', name: 'æ©Ÿæ«ƒéŒ˜èƒ¸', def: 45, hp: 175, dmgRed: 4, lifeSteal: 0.4 },
                    // é£¾å“1ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'é‚Šç•Œè­·ç¬¦', atk: 25, def: 25, hp: 100, crit: 3, dmgRed: 3, bossDmg: 2.67 },
                    // é£¾å“2ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'éš”é›¢æŒ‡ç’°', atk: 23, def: 23, hp: 112, crit: 2, critDmg: 10, lifeSteal: 1.6, armorPen: 2 }
                ]
            },
            'æ·±äº•è‡¨ç•Œå±¤': {
                setName: 'é‡å­åŒæ­¥å¥—è£',
                items: [
                    // æ­¦å™¨ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'weapon', name: 'å¹²æ¶‰ä¹‹åˆƒ', atk: 60, crit: 5, critDmg: 8, armorPen: 3, bossDmg: 0.67 },
                    // é˜²å…·ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'armor', name: 'å¥‡é»èƒ¸ç”²', def: 50, hp: 200, dmgRed: 3 },
                    // é£¾å“1ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'æ™®æœ—å…‹æŒ‡ç’°', atk: 30, def: 30, hp: 112, crit: 3, lifeSteal: 2, bossDmg: 0.67 },
                    // é£¾å“2ï¼šåŸºç¤æ•¸å€¼Ã—2.5
                    { type: 'accessory', name: 'ç¹¾çºé ¸ç’°', atk: 28, def: 28, hp: 125, crit: 2, critDmg: 12, dmgRed: 2, armorPen: 1 }
                ]
            }
        };
        
        // ç¬¬äºŒå¥—å¥—è£ï¼ˆBoss æ‰è½ï¼Œç‰¹åŒ–å‹ï¼‰
        const EQUIPMENT_SETS_2 = {
            'å…¥é–€é–‹ç™¼å±¤': {
                setName: 'æš´æ“Šçµæ®ºå¥—è£',
                items: [
                    { type: 'weapon', name: 'çµæ®ºè€…åˆ©åˆƒ', atk: 40, crit: 8, critDmg: 20, bossDmg: 5 },
                    { type: 'armor', name: 'çµæ®ºè€…è¼•ç”²', def: 25, hp: 80, crit: 5, dodge: 3 },
                    { type: 'accessory', name: 'çµæ®ºè€…å°è¨˜', atk: 18, def: 10, hp: 50, crit: 6, critDmg: 15 },
                    { type: 'accessory', name: 'çµæ®ºè€…å¾½è¨˜', atk: 15, def: 10, hp: 60, crit: 5, critDmg: 12, bossDmg: 3 }
                ]
            },
            'ç ”ç™¼æ ¸å¿ƒå±¤': {
                setName: 'ç”Ÿå‘½æ±²å–å¥—è£',
                items: [
                    { type: 'weapon', name: 'æ±²å–ä¹‹åˆƒ', atk: 48, crit: 3, lifeSteal: 5, armorPen: 8 },
                    { type: 'armor', name: 'æ±²å–è­·ç”²', def: 42, hp: 180, lifeSteal: 4, dmgRed: 5 },
                    { type: 'accessory', name: 'æ±²å–ç¬¦æ–‡', atk: 22, def: 22, hp: 100, lifeSteal: 6, crit: 2 },
                    { type: 'accessory', name: 'æ±²å–å¯¶çŸ³', atk: 20, def: 20, hp: 120, lifeSteal: 5, dmgRed: 4 }
                ]
            },
            'è³‡æ–™è£‚ç¸«': {
                setName: 'éµå£é˜²ç¦¦å¥—è£',
                items: [
                    { type: 'weapon', name: 'éµå£é‡éŒ˜', atk: 45, def: 15, crit: 2, dmgRed: 3 },
                    { type: 'armor', name: 'éµå£é‡ç”²', def: 60, hp: 250, dmgRed: 8, reflect: 5 },
                    { type: 'accessory', name: 'éµå£è­·ç¬¦', atk: 15, def: 35, hp: 150, dmgRed: 6, lifeSteal: 2 },
                    { type: 'accessory', name: 'éµå£ç›¾å¾½', atk: 12, def: 38, hp: 180, dmgRed: 7, reflect: 4 }
                ]
            },
            'æ·±äº•è‡¨ç•Œå±¤': {
                setName: 'ç„¡è¦–ç©¿é€å¥—è£',
                items: [
                    { type: 'weapon', name: 'ç©¿é€ä¹‹çŸ›', atk: 65, crit: 4, armorPen: 15, bossDmg: 8 },
                    { type: 'armor', name: 'ç©¿é€æˆ°ç”²', def: 48, hp: 200, armorPen: 8, dmgRed: 4 },
                    { type: 'accessory', name: 'ç©¿é€ç¬¦å°', atk: 32, def: 25, hp: 100, armorPen: 10, crit: 3 },
                    { type: 'accessory', name: 'ç©¿é€å¯¶ç ', atk: 30, def: 25, hp: 120, armorPen: 12, bossDmg: 5 }
                ]
            }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±

        // éš¨å¾ç³»çµ±å¸¸é‡
        const COMPANION_RARITIES = {
            Common: { name: 'ç ´èˆŠ', color: '#9e9e9e', skillCount: 1, bonusRange: [5, 10] },
            Fine: { name: 'å„ªè³ª', color: '#4caf50', skillCount: 1, bonusRange: [10, 15] },
            Rare: { name: 'ç¨€æœ‰', color: '#2196f3', skillCount: 2, bonusRange: [15, 20] },
            Epic: { name: 'å²è©©', color: '#9c27b0', skillCount: 2, bonusRange: [20, 30] },
            Legendary: { name: 'å‚³èªª', color: '#ffd700', skillCount: 3, bonusRange: [30, 50] },
            Eternal: { name: 'æ°¸æ†', color: '#E040FB', skillCount: 5, bonusRange: [50, 100] }
        };

        // éš¨å¾å®šç¾©ï¼ˆæ–°ç‰ˆ4å¤§æˆ°é¬¥é¡å‹ï¼‰
        const COMPANIONS = {
            // æ”»æ“Šå‹ (Attack)
            attack_core: { id: 'attack_core', name: 'ğŸ—¡ï¸ æ”»æ“Šæ ¸å¿ƒ', type: 'attack', rarity: 'Common', description: 'æå‡åŸºç¤æ”»æ“ŠåŠ›', price: 500, skills: [{ type: 'buff_atk', name: 'æ”»æ“Šå¢å¹…', description: 'æ”»æ“ŠåŠ› +10%', value: 10, trigger: 'passive' }], maxLevel: 50 },
            combat_ai: { id: 'combat_ai', name: 'âš”ï¸ æˆ°é¬¥AI', type: 'attack', rarity: 'Fine', description: 'æå‡æ”»æ“Šå’Œæš´æ“Š', price: 1500, skills: [{ type: 'buff_atk', name: 'æˆ°è¡“åˆ†æ', description: 'æ”»æ“ŠåŠ› +15%', value: 15, trigger: 'passive' }, { type: 'buff_crit', name: 'ç²¾æº–æ‰“æ“Š', description: 'æš´æ“Šç‡ +5%', value: 5, trigger: 'passive' }], maxLevel: 50 },
            destroyer: { id: 'destroyer', name: 'ğŸ’¥ æ¯€æ»…è€…', type: 'attack', rarity: 'Rare', description: 'å…¨é¢æå‡æ”»æ“Šèƒ½åŠ›', price: 3000, skills: [{ type: 'buff_atk', name: 'æ¯€æ»…ä¹‹åŠ›', description: 'æ”»æ“ŠåŠ› +20%', value: 20, trigger: 'passive' }, { type: 'buff_crit', name: 'è‡´å‘½æ‰“æ“Š', description: 'æš´æ“Šç‡ +8%', value: 8, trigger: 'passive' }, { type: 'buff_crit', name: 'æš´æ“Šå¼·åŒ–', description: 'æš´æ“Šå‚·å®³ +15%', value: 15, statType: 'critDmg', trigger: 'passive' }], maxLevel: 50 },
            terminator: { id: 'terminator', name: 'âš¡ çµ‚çµè€…', type: 'attack', rarity: 'Epic', description: 'æ¥µè‡´æ”»æ“ŠåŠ›é‡', price: 5000, skills: [{ type: 'buff_atk', name: 'çµ‚çµä¹‹åŠ›', description: 'æ”»æ“ŠåŠ› +25%', value: 25, trigger: 'passive' }, { type: 'buff_crit', name: 'å¿…æ®ºä¸€æ“Š', description: 'æš´æ“Šç‡ +10%', value: 10, trigger: 'passive' }, { type: 'buff_crit', name: 'æ¯€æ»…æš´æ“Š', description: 'æš´æ“Šå‚·å®³ +25%', value: 25, statType: 'critDmg', trigger: 'passive' }], maxLevel: 50 },
            
            // é˜²ç¦¦å‹ (Defense)
            defense_core: { id: 'defense_core', name: 'ğŸ›¡ï¸ é˜²è­·æ ¸å¿ƒ', type: 'defense', rarity: 'Common', description: 'æå‡åŸºç¤é˜²ç¦¦åŠ›', price: 500, skills: [{ type: 'buff_def', name: 'é˜²ç¦¦å¢å¹…', description: 'é˜²ç¦¦åŠ› +12%', value: 12, trigger: 'passive' }], maxLevel: 50 },
            fortress_guard: { id: 'fortress_guard', name: 'ğŸ° å ¡å£˜å®ˆè¡›', type: 'defense', rarity: 'Fine', description: 'æå‡é˜²ç¦¦å’Œç”Ÿå‘½', price: 1500, skills: [{ type: 'buff_def', name: 'å …å›ºé˜²ç¦¦', description: 'é˜²ç¦¦åŠ› +18%', value: 18, trigger: 'passive' }, { type: 'buff_hp', name: 'ç”Ÿå‘½å¼·åŒ–', description: 'æœ€å¤§ç”Ÿå‘½ +10%', value: 10, trigger: 'passive' }], maxLevel: 50 },
            titan_shield: { id: 'titan_shield', name: 'ğŸ’ æ³°å¦è­·ç›¾', type: 'defense', rarity: 'Rare', description: 'å…¨é¢æå‡é˜²ç¦¦èƒ½åŠ›', price: 3000, skills: [{ type: 'buff_def', name: 'æ³°å¦ä¹‹ç›¾', description: 'é˜²ç¦¦åŠ› +25%', value: 25, trigger: 'passive' }, { type: 'buff_hp', name: 'æ³°å¦è¡€çµ±', description: 'æœ€å¤§ç”Ÿå‘½ +15%', value: 15, trigger: 'passive' }, { type: 'buff_dmgred', name: 'å‚·å®³æ¸›å…', description: 'æ¸›å‚· +8%', value: 8, trigger: 'passive' }], maxLevel: 50 },
            immortal_guard: { id: 'immortal_guard', name: 'ğŸŒŸ ä¸æ»…å®ˆè­·', type: 'defense', rarity: 'Epic', description: 'æ¥µè‡´é˜²ç¦¦åŠ›é‡', price: 5000, skills: [{ type: 'buff_def', name: 'ä¸æ»…ä¹‹ç›¾', description: 'é˜²ç¦¦åŠ› +30%', value: 30, trigger: 'passive' }, { type: 'buff_hp', name: 'ä¸æ»…ä¹‹èº«', description: 'æœ€å¤§ç”Ÿå‘½ +20%', value: 20, trigger: 'passive' }, { type: 'buff_dmgred', name: 'çµ•å°é˜²ç¦¦', description: 'æ¸›å‚· +12%', value: 12, trigger: 'passive' }], maxLevel: 50 },
            
            // æ¢å¾©å‹ (Recovery)
            repair_bot: { id: 'repair_bot', name: 'ğŸ¤– ä¿®å¾©æ©Ÿå™¨äºº', type: 'recovery', rarity: 'Common', description: 'æŒçºŒç‚ºä½ ä¿®å¾©æå‚·', price: 500, skills: [{ type: 'heal_over_time', name: 'æŒçºŒä¿®å¾©', description: 'æ¯å›åˆå›å¾©2%ç”Ÿå‘½', value: 2, trigger: 'turn_start' }], maxLevel: 50 },
            medical_drone: { id: 'medical_drone', name: 'ğŸ§ª é†«ç™‚ç„¡äººæ©Ÿ', type: 'recovery', rarity: 'Fine', description: 'å›å¾©å’Œå¸è¡€', price: 1500, skills: [{ type: 'heal_over_time', name: 'æŒçºŒæ²»ç™‚', description: 'æ¯å›åˆå›å¾©3%ç”Ÿå‘½', value: 3, trigger: 'turn_start' }, { type: 'buff_lifesteal', name: 'ç”Ÿå‘½æ±²å–', description: 'å¸è¡€ +3%', value: 3, trigger: 'passive' }], maxLevel: 50 },
            nano_healer: { id: 'nano_healer', name: 'ğŸ’Š å¥ˆç±³æ²»ç™‚å¸«', type: 'recovery', rarity: 'Rare', description: 'å…¨é¢å›å¾©èƒ½åŠ›', price: 3000, skills: [{ type: 'heal_over_time', name: 'å¿«é€Ÿæ²»ç™‚', description: 'æ¯å›åˆå›å¾©4%ç”Ÿå‘½', value: 4, trigger: 'turn_start' }, { type: 'buff_lifesteal', name: 'å¼·åŠ›å¸è¡€', description: 'å¸è¡€ +5%', value: 5, trigger: 'passive' }, { type: 'battle_heal', name: 'æˆ°å¾Œæ²»ç™‚', description: 'æˆ°é¬¥çµæŸå›å¾©20%ç”Ÿå‘½', value: 20, trigger: 'battle_end' }], maxLevel: 50 },
            life_source: { id: 'life_source', name: 'âœ¨ ç”Ÿå‘½ä¹‹æº', type: 'recovery', rarity: 'Epic', description: 'æ¥µè‡´å›å¾©åŠ›é‡', price: 5000, skills: [{ type: 'heal_over_time', name: 'ç”Ÿå‘½æºæ³‰', description: 'æ¯å›åˆå›å¾©5%ç”Ÿå‘½', value: 5, trigger: 'turn_start' }, { type: 'buff_lifesteal', name: 'ç”Ÿå‘½æ±²å–', description: 'å¸è¡€ +8%', value: 8, trigger: 'passive' }, { type: 'battle_heal', name: 'å®Œå…¨æ¢å¾©', description: 'æˆ°é¬¥çµæŸå›å¾©30%ç”Ÿå‘½', value: 30, trigger: 'battle_end' }, { type: 'emergency_heal', name: 'ç·Šæ€¥æ²»ç™‚', description: 'ç”Ÿå‘½ä½æ–¼30%æ™‚å›å¾©20%ç”Ÿå‘½', value: 20, threshold: 30, cooldown: 5, trigger: 'low_hp' }], maxLevel: 50 },
            
            // å¹³è¡¡å‹ (Balance)
            multi_core: { id: 'multi_core', name: 'âš™ï¸ å¤šåŠŸèƒ½æ ¸å¿ƒ', type: 'balance', rarity: 'Fine', description: 'æ”»é˜²å¹³è¡¡', price: 1500, skills: [{ type: 'buff_atk', name: 'æ”»æ“Šæå‡', description: 'æ”»æ“ŠåŠ› +8%', value: 8, trigger: 'passive' }, { type: 'buff_def', name: 'é˜²ç¦¦æå‡', description: 'é˜²ç¦¦åŠ› +8%', value: 8, trigger: 'passive' }], maxLevel: 50 },
            tactical_ai: { id: 'tactical_ai', name: 'ğŸ¯ æˆ°è¡“AI', type: 'balance', rarity: 'Rare', description: 'å…¨é¢å¹³è¡¡', price: 3000, skills: [{ type: 'buff_atk', name: 'æˆ°è¡“æ”»æ“Š', description: 'æ”»æ“ŠåŠ› +12%', value: 12, trigger: 'passive' }, { type: 'buff_def', name: 'æˆ°è¡“é˜²ç¦¦', description: 'é˜²ç¦¦åŠ› +12%', value: 12, trigger: 'passive' }, { type: 'buff_hp', name: 'ç”Ÿå‘½å¼·åŒ–', description: 'æœ€å¤§ç”Ÿå‘½ +8%', value: 8, trigger: 'passive' }], maxLevel: 50 },
            quantum_core: { id: 'quantum_core', name: 'ğŸŒ€ é‡å­æ ¸å¿ƒ', type: 'balance', rarity: 'Epic', description: 'è¶…å¼·å¹³è¡¡', price: 5000, skills: [{ type: 'buff_atk', name: 'é‡å­æ”»æ“Š', description: 'æ”»æ“ŠåŠ› +15%', value: 15, trigger: 'passive' }, { type: 'buff_def', name: 'é‡å­é˜²ç¦¦', description: 'é˜²ç¦¦åŠ› +15%', value: 15, trigger: 'passive' }, { type: 'buff_hp', name: 'é‡å­ç”Ÿå‘½', description: 'æœ€å¤§ç”Ÿå‘½ +12%', value: 12, trigger: 'passive' }, { type: 'buff_lifesteal', name: 'ç”Ÿå‘½æ±²å–', description: 'å¸è¡€ +4%', value: 4, trigger: 'passive' }], maxLevel: 50 },
            perfect_wargod: { id: 'perfect_wargod', name: 'ğŸ‘‘ å®Œç¾æˆ°ç¥', type: 'balance', rarity: 'Legendary', description: 'çµ‚æ¥µå¹³è¡¡', price: 10000, skills: [{ type: 'buff_atk', name: 'æˆ°ç¥ä¹‹åŠ›', description: 'æ”»æ“ŠåŠ› +20%', value: 20, trigger: 'passive' }, { type: 'buff_def', name: 'æˆ°ç¥ä¹‹ç›¾', description: 'é˜²ç¦¦åŠ› +20%', value: 20, trigger: 'passive' }, { type: 'buff_hp', name: 'æˆ°ç¥ä¹‹é«”', description: 'æœ€å¤§ç”Ÿå‘½ +15%', value: 15, trigger: 'passive' }, { type: 'buff_crit', name: 'æˆ°ç¥ä¹‹çœ¼', description: 'æš´æ“Šç‡ +6%', value: 6, trigger: 'passive' }, { type: 'buff_lifesteal', name: 'æˆ°ç¥ä¹‹é­‚', description: 'å¸è¡€ +6%', value: 6, trigger: 'passive' }], maxLevel: 50 },
            
            // æ°¸æ†éšç´š (Eternal)
            eternal_guardian: { id: 'eternal_guardian', name: 'ğŸŒŒ æ™‚ç©ºå®ˆè­·è€…', type: 'balance', rarity: 'Eternal', description: 'æ°¸æ†ä¹‹åŠ›ï¼Œæ™‚ç©ºä¹‹ä¸»', price: 50000, skills: [{ type: 'buff_atk', name: 'æ™‚ç©ºä¹‹åŠ›', description: 'æ”»æ“ŠåŠ› +35%', value: 35, trigger: 'passive' }, { type: 'buff_def', name: 'æ™‚ç©ºè­·ç›¾', description: 'é˜²ç¦¦åŠ› +35%', value: 35, trigger: 'passive' }, { type: 'buff_hp', name: 'æ°¸æ†ç”Ÿå‘½', description: 'æœ€å¤§ç”Ÿå‘½ +25%', value: 25, trigger: 'passive' }, { type: 'buff_crit', name: 'æ™‚ç©ºæš´æ“Š', description: 'æš´æ“Šç‡ +10%', value: 10, trigger: 'passive' }, { type: 'buff_crit', name: 'æš´æ“Šå¼·åŒ–', description: 'æš´æ“Šå‚·å®³ +30%', value: 30, statType: 'critDmg', trigger: 'passive' }, { type: 'buff_lifesteal', name: 'ç”Ÿå‘½æ±²å–', description: 'å¸è¡€ +10%', value: 10, trigger: 'passive' }, { type: 'heal_over_time', name: 'æ™‚ç©ºå›æº¯', description: 'æ¯å›åˆå›å¾©6%ç”Ÿå‘½', value: 6, trigger: 'turn_start' }, { type: 'battle_heal', name: 'æ°¸æ†ç¥ç¦', description: 'æˆ°é¬¥çµæŸå›å¾©50%ç”Ÿå‘½', value: 50, trigger: 'battle_end' }], maxLevel: 50 }
        };

        // å¡ç‰Œç³»çµ±å®šç¾©
        const CARDS = {
            // æ”»æ“Šå‹ - åˆ€åˆƒç³»åˆ— (Blade)
            blade_common: { id: 'blade_common', name: 'ğŸ—¡ï¸ é‹’éŠ³åˆ€åˆƒ', type: 'attack', rarity: 'Common', series: 'blade', description: 'æ”»æ“ŠåŠ› +8%', price: 500, effect: { type: 'passive', stat: 'atk', value: 8 }, icon: 'ğŸ—¡ï¸' },
            blade_fine: { id: 'blade_fine', name: 'ğŸ—¡ï¸ ç²¾é‹¼åˆ©åˆƒ', type: 'attack', rarity: 'Fine', series: 'blade', description: 'æ”»æ“ŠåŠ› +12%', price: 2000, effect: { type: 'passive', stat: 'atk', value: 12 }, icon: 'ğŸ—¡ï¸' },
            blade_rare: { id: 'blade_rare', name: 'ğŸ—¡ï¸ é¾é±—ç¥åˆƒ', type: 'attack', rarity: 'Rare', series: 'blade', description: 'æ”»æ“ŠåŠ› +16%ï¼Œæ”»æ“Šæ™‚5%æ©Ÿç‡é€ æˆ200%å‚·å®³', price: 8000, effect: { type: 'passive', stat: 'atk', value: 16, trigger: { type: 'attack', chance: 5, effect: 'extra_damage', value: 200 } }, icon: 'ğŸ—¡ï¸' },
            blade_epic: { id: 'blade_epic', name: 'ğŸ—¡ï¸ ç¥è©±å± é¾åŠ', type: 'attack', rarity: 'Epic', series: 'blade', description: 'æ”»æ“ŠåŠ› +20%ï¼Œæ”»æ“Šæ™‚8%æ©Ÿç‡é€ æˆ250%å‚·å®³', price: 30000, effect: { type: 'passive', stat: 'atk', value: 20, trigger: { type: 'attack', chance: 8, effect: 'extra_damage', value: 250 } }, icon: 'ğŸ—¡ï¸' },
            blade_legendary: { id: 'blade_legendary', name: 'ğŸ—¡ï¸ çµ‚ç„‰ä¹‹åˆƒ', type: 'attack', rarity: 'Legendary', series: 'blade', description: 'æ”»æ“ŠåŠ› +28%ï¼Œæ”»æ“Šæ™‚12%æ©Ÿç‡é€ æˆ300%å‚·å®³ä¸¦å›å¾©5%ç”Ÿå‘½', price: 100000, effect: { type: 'passive', stat: 'atk', value: 28, trigger: { type: 'attack', chance: 12, effect: 'extra_damage', value: 300, heal: 5 } }, icon: 'ğŸ—¡ï¸' },
            
            // æ”»æ“Šå‹ - æˆ°å£«ç³»åˆ— (Warrior)
            warrior_common: { id: 'warrior_common', name: 'âš”ï¸ æˆ°å£«ä¹‹å¿ƒ', type: 'attack', rarity: 'Common', series: 'warrior', description: 'æš´æ“Šå‚·å®³ +10%', price: 500, effect: { type: 'passive', stat: 'critDmg', value: 10 }, icon: 'âš”ï¸' },
            warrior_fine: { id: 'warrior_fine', name: 'âš”ï¸ ç‹‚æˆ°å£«ä¹‹é­‚', type: 'attack', rarity: 'Fine', series: 'warrior', description: 'æ”»æ“ŠåŠ› +10%ï¼Œæš´æ“Šç‡ +3%', price: 2000, effect: { type: 'passive', stats: [{ stat: 'atk', value: 10 }, { stat: 'crit', value: 3 }] }, icon: 'âš”ï¸' },
            warrior_rare: { id: 'warrior_rare', name: 'âš”ï¸ ä¸æ»…æˆ°é­‚', type: 'attack', rarity: 'Rare', series: 'warrior', description: 'æ”»æ“ŠåŠ› +12%ï¼Œæš´æ“Šç‡ +5%ï¼Œæš´æ“Šå‚·å®³ +15%', price: 8000, effect: { type: 'passive', stats: [{ stat: 'atk', value: 12 }, { stat: 'crit', value: 5 }, { stat: 'critDmg', value: 15 }] }, icon: 'âš”ï¸' },
            
            // é˜²ç¦¦å‹ - å®ˆè­·ç³»åˆ— (Shield)
            shield_common: { id: 'shield_common', name: 'ğŸ›¡ï¸ éµå£é˜²ç¦¦', type: 'defense', rarity: 'Common', series: 'shield', description: 'é˜²ç¦¦åŠ› +10%', price: 500, effect: { type: 'passive', stat: 'def', value: 10 }, icon: 'ğŸ›¡ï¸' },
            shield_fine: { id: 'shield_fine', name: 'ğŸ›¡ï¸ é‹¼éµå ¡å£˜', type: 'defense', rarity: 'Fine', series: 'shield', description: 'é˜²ç¦¦åŠ› +15%ï¼Œæ¸›å‚· +3%', price: 2000, effect: { type: 'passive', stats: [{ stat: 'def', value: 15 }, { stat: 'dmgRed', value: 3 }] }, icon: 'ğŸ›¡ï¸' },
            shield_rare: { id: 'shield_rare', name: 'ğŸ›¡ï¸ ä¸æœ½è­·ç›¾', type: 'defense', rarity: 'Rare', series: 'shield', description: 'é˜²ç¦¦åŠ› +22%ï¼Œæ¸›å‚· +6%', price: 8000, effect: { type: 'passive', stats: [{ stat: 'def', value: 22 }, { stat: 'dmgRed', value: 6 }] }, icon: 'ğŸ›¡ï¸' },
            
            // é˜²ç¦¦å‹ - ç”Ÿå‘½ç³»åˆ— (Vitality)
            vitality_common: { id: 'vitality_common', name: 'ğŸ’š ç”Ÿå‘½ä¹‹æº', type: 'defense', rarity: 'Common', series: 'vitality', description: 'æœ€å¤§ç”Ÿå‘½ +8%', price: 500, effect: { type: 'passive', stat: 'hp', value: 8 }, icon: 'ğŸ’š' },
            vitality_fine: { id: 'vitality_fine', name: 'ğŸ’š ç”Ÿå‘½ç¥ç¦', type: 'defense', rarity: 'Fine', series: 'vitality', description: 'æœ€å¤§ç”Ÿå‘½ +12%ï¼Œå¸è¡€ +2%', price: 2000, effect: { type: 'passive', stats: [{ stat: 'hp', value: 12 }, { stat: 'lifeSteal', value: 2 }] }, icon: 'ğŸ’š' },
            vitality_rare: { id: 'vitality_rare', name: 'ğŸ’š æ³°å¦è¡€çµ±', type: 'defense', rarity: 'Rare', series: 'vitality', description: 'æœ€å¤§ç”Ÿå‘½ +18%ï¼Œå¸è¡€ +4%', price: 8000, effect: { type: 'passive', stats: [{ stat: 'hp', value: 18 }, { stat: 'lifeSteal', value: 4 }] }, icon: 'ğŸ’š' },
            
            // è¼”åŠ©å‹ - ç²¾æº–ç³»åˆ— (Precision)
            precision_common: { id: 'precision_common', name: 'âœ¨ ç²¾æº–æ‰“æ“Š', type: 'support', rarity: 'Common', series: 'precision', description: 'æš´æ“Šç‡ +4%', price: 500, effect: { type: 'passive', stat: 'crit', value: 4 }, icon: 'âœ¨' },
            precision_fine: { id: 'precision_fine', name: 'âœ¨ è‡´å‘½ç²¾æº–', type: 'support', rarity: 'Fine', series: 'precision', description: 'æš´æ“Šç‡ +6%ï¼Œæš´æ“Šå‚·å®³ +10%', price: 2000, effect: { type: 'passive', stats: [{ stat: 'crit', value: 6 }, { stat: 'critDmg', value: 10 }] }, icon: 'âœ¨' },
            precision_rare: { id: 'precision_rare', name: 'âœ¨ å®Œç¾æ‰“æ“Š', type: 'support', rarity: 'Rare', series: 'precision', description: 'æš´æ“Šç‡ +9%ï¼Œæš´æ“Šå‚·å®³ +18%', price: 8000, effect: { type: 'passive', stats: [{ stat: 'crit', value: 9 }, { stat: 'critDmg', value: 18 }] }, icon: 'âœ¨' },
            
            // ç‰¹æ®Šå‹ - åæ“Šç³»åˆ— (Counter)
            counter_common: { id: 'counter_common', name: 'ğŸŒŸ åæ“Šå§¿æ…‹', type: 'special', rarity: 'Common', series: 'counter', description: 'å—æ“Šæ™‚10%æ©Ÿç‡åæ“Šé€ æˆ50%å‚·å®³', price: 500, effect: { type: 'trigger', trigger: 'on_hit', chance: 10, effect: 'counter', value: 50 }, icon: 'ğŸŒŸ' },
            counter_fine: { id: 'counter_fine', name: 'ğŸŒŸ å®Œç¾åæ“Š', type: 'special', rarity: 'Fine', series: 'counter', description: 'å—æ“Šæ™‚18%æ©Ÿç‡åæ“Šé€ æˆ80%å‚·å®³', price: 2000, effect: { type: 'trigger', trigger: 'on_hit', chance: 18, effect: 'counter', value: 80 }, icon: 'ğŸŒŸ' },
            counter_rare: { id: 'counter_rare', name: 'ğŸŒŸ è‡´å‘½åæ“Š', type: 'special', rarity: 'Rare', series: 'counter', description: 'å—æ“Šæ™‚25%æ©Ÿç‡åæ“Šé€ æˆ120%å‚·å®³', price: 8000, effect: { type: 'trigger', trigger: 'on_hit', chance: 25, effect: 'counter', value: 120 }, icon: 'ğŸŒŸ' },
            
            // æ°¸æ†éšç´š - é›·éœ†ç³»åˆ— (Thunder)
            eternal_thunder: { id: 'eternal_thunder', name: 'âš¡ æ°¸æ†é›·éœ†', type: 'attack', rarity: 'Eternal', series: 'thunder', description: 'æ”»æ“ŠåŠ› +40%ï¼Œæš´æ“Šç‡ +8%ï¼Œæš´æ“Šå‚·å®³ +25%ã€‚æ”»æ“Šæ™‚15%æ©Ÿç‡è§¸ç™¼ã€Œé›·éœ†å¯©åˆ¤ã€ï¼šé€ æˆ400%å‚·å®³ä¸¦å›å¾©10%ç”Ÿå‘½ï¼Œé¡å¤–ç²å¾—20%é‡‘å¹£', price: 150000, effect: { type: 'passive', stats: [{ stat: 'atk', value: 40 }, { stat: 'crit', value: 8 }, { stat: 'critDmg', value: 25 }], trigger: { type: 'attack', chance: 15, effect: 'thunder_judgment', value: 400, heal: 10, goldBonus: 20 } }, icon: 'âš¡' }
        };

        // å¡ç‰Œè©ç¶´ç³»çµ±å®šç¾©
        const CARD_AFFIXES = {
            // æ”»æ“Šé¡è©ç¶´
            sharp: { id: 'sharp', name: 'é‹’éŠ³', category: 'attack', stat: 'atk', value: 3, type: 'percent', weight: 100, color: '#ff6b6b' },
            deadly: { id: 'deadly', name: 'è‡´å‘½', category: 'attack', stat: 'crit', value: 2, type: 'flat', weight: 80, color: '#ff6b6b' },
            brutal: { id: 'brutal', name: 'æ®˜æš´', category: 'attack', stat: 'critDmg', value: 8, type: 'percent', weight: 70, color: '#ff6b6b' },
            piercing: { id: 'piercing', name: 'ç©¿é€', category: 'attack', stat: 'ignoreDefense', value: 5, type: 'percent', weight: 60, color: '#ff6b6b' },
            furious: { id: 'furious', name: 'ç‹‚æš´', category: 'attack', stats: [{stat: 'atk', value: 5}, {stat: 'def', value: -2}], type: 'percent', weight: 50, color: '#ff6b6b' },
            
            // é˜²ç¦¦é¡è©ç¶´
            sturdy: { id: 'sturdy', name: 'å …å›º', category: 'defense', stat: 'def', value: 4, type: 'percent', weight: 100, color: '#4dabf7' },
            vital: { id: 'vital', name: 'æ´»åŠ›', category: 'defense', stat: 'hp', value: 5, type: 'percent', weight: 90, color: '#4dabf7' },
            resilient: { id: 'resilient', name: 'éŸŒæ€§', category: 'defense', stat: 'dmgRed', value: 2, type: 'percent', weight: 70, color: '#4dabf7' },
            regenerating: { id: 'regenerating', name: 'å†ç”Ÿ', category: 'defense', stat: 'regen', value: 1, type: 'percent', weight: 60, color: '#4dabf7' },
            vampiric: { id: 'vampiric', name: 'å¸è¡€', category: 'defense', stat: 'lifeSteal', value: 3, type: 'percent', weight: 80, color: '#4dabf7' },
            
            // ç‰¹æ®Šé¡è©ç¶´
            lucky: { id: 'lucky', name: 'å¹¸é‹', category: 'special', stat: 'luck', value: 2, type: 'percent', weight: 70, color: '#ffd43b' },
            wealthy: { id: 'wealthy', name: 'å¯Œè£•', category: 'special', stat: 'goldBonus', value: 3, type: 'percent', weight: 80, color: '#ffd43b' },
            studious: { id: 'studious', name: 'å­¸ç¿’', category: 'special', stat: 'expBonus', value: 2, type: 'percent', weight: 80, color: '#ffd43b' },
            swift: { id: 'swift', name: 'è¿…æ·', category: 'special', stat: 'speed', value: 5, type: 'percent', weight: 60, color: '#ffd43b' },
            divine: { id: 'divine', name: 'ç¥è–', category: 'special', stats: [{stat: 'atk', value: 1}, {stat: 'def', value: 1}, {stat: 'hp', value: 1}], type: 'percent', weight: 30, color: '#ffd43b' }
        };

        // è©ç¶´ç”Ÿæˆæ©Ÿç‡é…ç½®ï¼ˆæŒ‰å“éšï¼‰
        const AFFIX_CHANCES = {
            'Common': { one: 0.10, two: 0 },
            'Fine': { one: 0.20, two: 0 },
            'Rare': { one: 0.40, two: 0.10 },
            'Epic': { one: 0.60, two: 0.20 },
            'Legendary': { one: 0.80, two: 0.40 }
        };

        // éš¨å¾è£å‚™å®šç¾©
        const COMPANION_EQUIPMENT = {
            // æ”»æ“Šå‹
            attack_chip: {
                id: 'attack_chip',
                name: 'æˆ°é¬¥èŠ‹ç‰‡',
                icon: 'âš”ï¸',
                type: 'attack',
                rarity: 'common',
                description: 'æ”»æ“ŠåŠ› +5%',
                effects: { atk: 0.05 }
            },
            attack_core: {
                id: 'attack_core',
                name: 'ç ´å£æ ¸å¿ƒ',
                icon: 'ğŸ’¥',
                type: 'attack',
                rarity: 'rare',
                description: 'æ”»æ“ŠåŠ› +8%, æš´æ“Šç‡ +3%, æš´æ“Šå‚·å®³ +10%',
                effects: { atk: 0.08, crit: 0.03, critDmg: 0.10 }
            },
            attack_engine: {
                id: 'attack_engine',
                name: 'æ¯€æ»…å¼•æ“',
                icon: 'ğŸ”¥',
                type: 'attack',
                rarity: 'epic',
                description: 'æ”»æ“ŠåŠ› +12%, æš´æ“Šç‡ +5%, æš´æ“Šå‚·å®³ +20%, ç„¡è¦–é˜²ç¦¦ +5%',
                effects: { atk: 0.12, crit: 0.05, critDmg: 0.20, ignoreDefense: 0.05 }
            },
            
            // é˜²ç¦¦å‹
            defense_chip: {
                id: 'defense_chip',
                name: 'é˜²è­·èŠ‹ç‰‡',
                icon: 'ğŸ›¡ï¸',
                type: 'defense',
                rarity: 'common',
                description: 'é˜²ç¦¦åŠ› +5%, æœ€å¤§ç”Ÿå‘½ +5%',
                effects: { def: 0.05, hp: 0.05 }
            },
            defense_core: {
                id: 'defense_core',
                name: 'å ¡å£˜æ ¸å¿ƒ',
                icon: 'ğŸ’',
                type: 'defense',
                rarity: 'rare',
                description: 'é˜²ç¦¦åŠ› +8%, æœ€å¤§ç”Ÿå‘½ +10%, æ¸›å‚· +3%',
                effects: { def: 0.08, hp: 0.10, dmgRed: 0.03 }
            },
            defense_wall: {
                id: 'defense_wall',
                name: 'ä¸æ»…å£å£˜',
                icon: 'ğŸ”±',
                type: 'defense',
                rarity: 'epic',
                description: 'é˜²ç¦¦åŠ› +12%, æœ€å¤§ç”Ÿå‘½ +15%, æ¸›å‚· +5%, åå‚· +3%',
                effects: { def: 0.12, hp: 0.15, dmgRed: 0.05, reflect: 0.03 }
            },
            
            // æ¢å¾©å‹
            heal_chip: {
                id: 'heal_chip',
                name: 'ä¿®å¾©èŠ‹ç‰‡',
                icon: 'ğŸ’š',
                type: 'heal',
                rarity: 'common',
                description: 'æ¯å›åˆå›å¾© 1.5% ç”Ÿå‘½, å¸è¡€ +2%',
                effects: { regen: 0.015, lifeSteal: 0.02 }
            },
            heal_core: {
                id: 'heal_core',
                name: 'å†ç”Ÿæ ¸å¿ƒ',
                icon: 'ğŸ’Š',
                type: 'heal',
                rarity: 'rare',
                description: 'æ¯å›åˆå›å¾© 2.5% ç”Ÿå‘½, å¸è¡€ +4%, æˆ°å¾Œå›å¾© 5%',
                effects: { regen: 0.025, lifeSteal: 0.04, postBattleHeal: 0.05 }
            },
            heal_fountain: {
                id: 'heal_fountain',
                name: 'ç”Ÿå‘½æºæ³‰',
                icon: 'ğŸŒˆ',
                type: 'heal',
                rarity: 'epic',
                description: 'æ¯å›åˆå›å¾© 4% ç”Ÿå‘½, å¸è¡€ +6%, æˆ°å¾Œå›å¾© 10%, ä½è¡€å›å¾© +10%',
                effects: { regen: 0.04, lifeSteal: 0.06, postBattleHeal: 0.10, lowHpHeal: 0.10 }
            }
        };

        // ========== å¯µç‰©ç³»çµ± ==========
        // å¯µç‰©å®šç¾©
        const PETS = {
            // é¾æ—
            drake_hatchling: {
                id: 'drake_hatchling',
                name: 'å¹¼é¾',
                family: 'dragon',
                stage: 1,
                rarity: 'epic',
                icon: 'ğŸ²',
                description: 'å‰›å­µåŒ–çš„å¹¼é¾ï¼Œæ“æœ‰ç«ç„°çš„åŠ›é‡',
                baseStats: { atk: 50, def: 20, hp: 200 },
                growthRate: { atk: 3, def: 1.5, hp: 12 },
                skills: [
                    {
                        id: 'spark',
                        name: 'å°ç«èŠ±',
                        chance: 0.4,
                        description: 'å™´å‡ºå°ç«èŠ±æ”»æ“Šæ•µäºº',
                        effect: { type: 'damage', multiplier: 1.2, element: 'fire', burnChance: 0.15 }
                    }
                ],
                evolution: {
                    nextStage: 'wyvern',
                    requiredLevel: 30,
                    materials: { evolutionStone: 50, petShards: 20 }
                }
            },
            wyvern: {
                id: 'wyvern',
                name: 'é£›é¾',
                family: 'dragon',
                stage: 2,
                rarity: 'legendary',
                icon: 'ğŸ‰',
                description: 'æˆé•·å¾Œçš„é£›é¾ï¼Œç«ç„°æ›´åŠ å¼·å¤§',
                baseStats: { atk: 120, def: 50, hp: 500 },
                growthRate: { atk: 5, def: 2.5, hp: 20 },
                skills: [
                    {
                        id: 'flame_burst',
                        name: 'çƒˆç„°å™´å°„',
                        chance: 0.35,
                        description: 'å™´å‡ºå¼·åŠ›çƒˆç„°',
                        effect: { type: 'damage', multiplier: 1.8, element: 'fire', burnChance: 0.3 }
                    },
                    {
                        id: 'dragon_roar',
                        name: 'é¾ä¹‹å’†å“®',
                        chance: 0.2,
                        description: 'å’†å“®å‰Šå¼±æ•µäºº',
                        effect: { type: 'debuff', stat: 'atk', value: 0.1, duration: 3 }
                    }
                ],
                evolution: {
                    nextStage: 'elder_dragon',
                    requiredLevel: 60,
                    materials: { evolutionStone: 200, petShards: 100 }
                }
            },
            elder_dragon: {
                id: 'elder_dragon',
                name: 'å·¨é¾',
                family: 'dragon',
                stage: 3,
                rarity: 'mythic',
                icon: 'ğŸ”¥',
                description: 'å¤è€è€Œå¼·å¤§çš„å·¨é¾',
                baseStats: { atk: 300, def: 120, hp: 1200 },
                growthRate: { atk: 8, def: 4, hp: 35 },
                skills: [
                    {
                        id: 'inferno_sea',
                        name: 'ç…‰ç„ç«æµ·',
                        chance: 0.3,
                        description: 'å°å…¨é«”æ•µäººé€ æˆç«ç„°å‚·å®³',
                        effect: { type: 'aoe_damage', multiplier: 1.5, element: 'fire', burnChance: 0.5 }
                    },
                    {
                        id: 'ancient_majesty',
                        name: 'ä¸Šå¤é¾å¨',
                        chance: 0.25,
                        description: 'å¨å£“å‰Šå¼±æ•µäººé˜²ç¦¦',
                        effect: { type: 'debuff', stat: 'def', value: 0.2, duration: 3, stunChance: 0.3 }
                    }
                ],
                awakening: {
                    nextStage: 'dragon_god',
                    requiredLevel: 90,
                    materials: { eternalSource: 1, petShards: 500 }
                }
            },
            dragon_god: {
                id: 'dragon_god',
                name: 'é¾ç¥',
                family: 'dragon',
                stage: 4,
                rarity: 'eternal',
                icon: 'â­',
                description: 'è¶…è¶Šå‡¡é¾çš„ç¥è–å­˜åœ¨',
                baseStats: { atk: 600, def: 250, hp: 2500 },
                growthRate: { atk: 12, def: 6, hp: 50 },
                skills: [
                    {
                        id: 'inferno_sea',
                        name: 'ç…‰ç„ç«æµ·',
                        chance: 0.3,
                        description: 'å°å…¨é«”æ•µäººé€ æˆç«ç„°å‚·å®³',
                        effect: { type: 'aoe_damage', multiplier: 1.5, element: 'fire', burnChance: 0.5 }
                    },
                    {
                        id: 'ancient_majesty',
                        name: 'ä¸Šå¤é¾å¨',
                        chance: 0.25,
                        description: 'å¨å£“å‰Šå¼±æ•µäººé˜²ç¦¦',
                        effect: { type: 'debuff', stat: 'def', value: 0.2, duration: 3, stunChance: 0.3 }
                    },
                    {
                        id: 'celestial_annihilation',
                        name: 'æ˜Ÿè¾°å¯‚æ»…',
                        chance: 0.15,
                        description: 'æ°¸æ†æŠ€èƒ½ï¼šé€ æˆçœŸå¯¦å‚·å®³ä¸¦æ¸…é™¤å¢ç›Š',
                        effect: { type: 'true_damage', multiplier: 3.0, clearBuffs: true }
                    }
                ]
            },
            
            // æ©Ÿæ¢°æ—
            scout_drone: {
                id: 'scout_drone',
                name: 'åµå¯Ÿæ©Ÿå…µ',
                family: 'mecha',
                stage: 1,
                rarity: 'epic',
                icon: 'ğŸ¤–',
                description: 'å°å‹åµå¯Ÿç„¡äººæ©Ÿ',
                baseStats: { atk: 60, def: 15, hp: 150 },
                growthRate: { atk: 3.5, def: 1, hp: 10 },
                skills: [
                    {
                        id: 'laser_shot',
                        name: 'æ¿€å…‰å°„æ“Š',
                        chance: 0.45,
                        description: 'ç™¼å°„ç²¾æº–æ¿€å…‰',
                        effect: { type: 'damage', multiplier: 1.3, element: 'tech' }
                    }
                ],
                evolution: {
                    nextStage: 'assault_mech',
                    requiredLevel: 30,
                    materials: { evolutionStone: 50, petShards: 20 }
                }
            },
            assault_mech: {
                id: 'assault_mech',
                name: 'é‡è£æ©Ÿç”²',
                family: 'mecha',
                stage: 2,
                rarity: 'legendary',
                icon: 'ğŸ¦¾',
                description: 'é…å‚™é‡å‹æ­¦å™¨çš„æ©Ÿç”²',
                baseStats: { atk: 140, def: 40, hp: 400 },
                growthRate: { atk: 6, def: 2, hp: 18 },
                skills: [
                    {
                        id: 'gatling_fire',
                        name: 'åŠ ç‰¹æ—æƒå°„',
                        chance: 0.35,
                        description: 'é«˜é€Ÿé€£å°„',
                        effect: { type: 'multi_hit', hits: 3, multiplier: 0.7, element: 'tech' }
                    },
                    {
                        id: 'missile_barrage',
                        name: 'å°å½ˆé½Šå°„',
                        chance: 0.25,
                        description: 'ç™¼å°„å¤šæšå°å½ˆ',
                        effect: { type: 'aoe_damage', multiplier: 1.4, element: 'tech' }
                    }
                ],
                evolution: {
                    nextStage: 'fortress_golem',
                    requiredLevel: 60,
                    materials: { evolutionStone: 200, petShards: 100 }
                }
            },
            fortress_golem: {
                id: 'fortress_golem',
                name: 'è¦å¡å ¡å£˜',
                family: 'mecha',
                stage: 3,
                rarity: 'mythic',
                icon: 'ğŸ°',
                description: 'ç§»å‹•è¦å¡ï¼Œç«åŠ›å¼·å¤§',
                baseStats: { atk: 280, def: 150, hp: 1500 },
                growthRate: { atk: 7, def: 5, hp: 40 },
                skills: [
                    {
                        id: 'artillery_strike',
                        name: 'ç‚®ç«æ‰“æ“Š',
                        chance: 0.3,
                        description: 'é‡å‹ç‚®ç«è½Ÿæ“Š',
                        effect: { type: 'aoe_damage', multiplier: 1.8, element: 'tech' }
                    },
                    {
                        id: 'shield_generator',
                        name: 'è­·ç›¾ç”Ÿæˆ',
                        chance: 0.25,
                        description: 'ç‚ºè‡ªå·±ç”Ÿæˆè­·ç›¾',
                        effect: { type: 'shield', value: 0.3, duration: 2 }
                    }
                ],
                awakening: {
                    nextStage: 'genesis_core',
                    requiredLevel: 90,
                    materials: { eternalSource: 1, petShards: 500 }
                }
            },
            genesis_core: {
                id: 'genesis_core',
                name: 'å‰µä¸–æ ¸å¿ƒ',
                family: 'mecha',
                stage: 4,
                rarity: 'eternal',
                icon: 'ğŸ’ ',
                description: 'çµ‚æ¥µæ©Ÿæ¢°æ ¸å¿ƒ',
                baseStats: { atk: 550, def: 300, hp: 3000 },
                growthRate: { atk: 10, def: 8, hp: 60 },
                skills: [
                    {
                        id: 'artillery_strike',
                        name: 'ç‚®ç«æ‰“æ“Š',
                        chance: 0.3,
                        description: 'é‡å‹ç‚®ç«è½Ÿæ“Š',
                        effect: { type: 'aoe_damage', multiplier: 1.8, element: 'tech' }
                    },
                    {
                        id: 'shield_generator',
                        name: 'è­·ç›¾ç”Ÿæˆ',
                        chance: 0.25,
                        description: 'ç‚ºè‡ªå·±ç”Ÿæˆè­·ç›¾',
                        effect: { type: 'shield', value: 0.3, duration: 2 }
                    },
                    {
                        id: 'genesis_beam',
                        name: 'å‰µä¸–å…‰æŸ',
                        chance: 0.15,
                        description: 'æ°¸æ†æŠ€èƒ½ï¼šæ¯€æ»…æ€§èƒ½é‡å…‰æŸ',
                        effect: { type: 'true_damage', multiplier: 2.8, defenseBreak: 0.5 }
                    }
                ]
            },
            
            // è™›ç©ºæ—
            void_gazer: {
                id: 'void_gazer',
                name: 'è™›ç©ºä¹‹çœ¼',
                family: 'void',
                stage: 1,
                rarity: 'epic',
                icon: 'ğŸ‘ï¸',
                description: 'æ¼‚æµ®çš„è™›ç©ºä¹‹çœ¼',
                baseStats: { atk: 55, def: 10, hp: 180 },
                growthRate: { atk: 3.2, def: 0.8, hp: 11 },
                skills: [
                    {
                        id: 'void_gaze',
                        name: 'è™›ç©ºå‡è¦–',
                        chance: 0.4,
                        description: 'è™›ç©ºèƒ½é‡ä¾µè•',
                        effect: { type: 'damage', multiplier: 1.25, element: 'void', drainHp: 0.1 }
                    }
                ],
                evolution: {
                    nextStage: 'shadow_stalker',
                    requiredLevel: 30,
                    materials: { evolutionStone: 50, petShards: 20 }
                }
            },
            shadow_stalker: {
                id: 'shadow_stalker',
                name: 'æš—å½±çµæ‰‹',
                family: 'void',
                stage: 2,
                rarity: 'legendary',
                icon: 'ğŸŒ‘',
                description: 'æ½›è¡Œæ–¼æš—å½±ä¸­çš„çµæ‰‹',
                baseStats: { atk: 150, def: 35, hp: 450 },
                growthRate: { atk: 6.5, def: 1.8, hp: 19 },
                skills: [
                    {
                        id: 'shadow_strike',
                        name: 'æš—å½±çªè¥²',
                        chance: 0.35,
                        description: 'å¾æš—å½±ä¸­çªè¥²',
                        effect: { type: 'damage', multiplier: 2.0, element: 'void', critBonus: 0.3 }
                    },
                    {
                        id: 'void_drain',
                        name: 'è™›ç©ºæ±²å–',
                        chance: 0.25,
                        description: 'å¸å–æ•µäººç”Ÿå‘½',
                        effect: { type: 'damage', multiplier: 1.5, element: 'void', drainHp: 0.5 }
                    }
                ],
                evolution: {
                    nextStage: 'abyss_lord',
                    requiredLevel: 60,
                    materials: { evolutionStone: 200, petShards: 100 }
                }
            },
            abyss_lord: {
                id: 'abyss_lord',
                name: 'æ·±æ·µé ˜ä¸»',
                family: 'void',
                stage: 3,
                rarity: 'mythic',
                icon: 'ğŸ‘¹',
                description: 'æ·±æ·µçš„çµ±æ²»è€…',
                baseStats: { atk: 320, def: 100, hp: 1100 },
                growthRate: { atk: 9, def: 3.5, hp: 32 },
                skills: [
                    {
                        id: 'abyss_wave',
                        name: 'æ·±æ·µæ³¢å‹•',
                        chance: 0.3,
                        description: 'è™›ç©ºèƒ½é‡æ³¢å‹•',
                        effect: { type: 'aoe_damage', multiplier: 1.6, element: 'void', drainHp: 0.3 }
                    },
                    {
                        id: 'void_prison',
                        name: 'è™›ç©ºå›šç± ',
                        chance: 0.25,
                        description: 'æŸç¸›æ•µäºº',
                        effect: { type: 'debuff', stat: 'spd', value: 0.5, duration: 2, stunChance: 0.4 }
                    }
                ],
                awakening: {
                    nextStage: 'chaos_singularity',
                    requiredLevel: 90,
                    materials: { eternalSource: 1, petShards: 500 }
                }
            },
            chaos_singularity: {
                id: 'chaos_singularity',
                name: 'æ··æ²Œå¥‡é»',
                family: 'void',
                stage: 4,
                rarity: 'eternal',
                icon: 'âš«',
                description: 'æ··æ²Œçš„åŒ–èº«',
                baseStats: { atk: 580, def: 200, hp: 2200 },
                growthRate: { atk: 11, def: 5, hp: 45 },
                skills: [
                    {
                        id: 'abyss_wave',
                        name: 'æ·±æ·µæ³¢å‹•',
                        chance: 0.3,
                        description: 'è™›ç©ºèƒ½é‡æ³¢å‹•',
                        effect: { type: 'aoe_damage', multiplier: 1.6, element: 'void', drainHp: 0.3 }
                    },
                    {
                        id: 'void_prison',
                        name: 'è™›ç©ºå›šç± ',
                        chance: 0.25,
                        description: 'æŸç¸›æ•µäºº',
                        effect: { type: 'debuff', stat: 'spd', value: 0.5, duration: 2, stunChance: 0.4 }
                    },
                    {
                        id: 'chaos_collapse',
                        name: 'æ··æ²Œå´©å¡Œ',
                        chance: 0.15,
                        description: 'æ°¸æ†æŠ€èƒ½ï¼šåå™¬ä¸€åˆ‡',
                        effect: { type: 'true_damage', multiplier: 3.2, clearBuffs: true, drainHp: 0.8 }
                    }
                ]
            }
        };

        // å¥—ç‰Œæ•ˆæœå®šç¾©ï¼ˆæ–°ç‰ˆ4å¤§æˆ°é¬¥é¡å‹ï¼‰
        const DECK_EFFECTS = {
            blade: { name: 'åˆ€åˆƒå¥—ç‰Œ', bonus: { atk: 15, trigger: { type: 'attack', chance: 20, effect: 'extra_damage', value: 150 } }, description: 'æ”»æ“ŠåŠ›+15%ï¼Œæ”»æ“Šæ™‚20%æ©Ÿç‡é€ æˆé¡å¤–150%å‚·å®³' },
            warrior: { name: 'æˆ°å£«å¥—ç‰Œ', bonus: { atk: 12, crit: 6, critDmg: 18 }, description: 'æ”»æ“ŠåŠ›+12%ï¼Œæš´æ“Šç‡+6%ï¼Œæš´æ“Šå‚·å®³+18%' },
            shield: { name: 'å®ˆè­·å¥—ç‰Œ', bonus: { def: 30, dmgRed: 18 }, description: 'é˜²ç¦¦åŠ›+30%ï¼Œæ¸›å‚·+18%' },
            vitality: { name: 'ç”Ÿå‘½å¥—ç‰Œ', bonus: { hp: 20, lifeSteal: 8 }, description: 'æœ€å¤§ç”Ÿå‘½+20%ï¼Œå¸è¡€+8%' },
            precision: { name: 'ç²¾æº–å¥—ç‰Œ', bonus: { crit: 12, critDmg: 30 }, description: 'æš´æ“Šç‡+12%ï¼Œæš´æ“Šå‚·å®³+30%' },
            counter: { name: 'åæ“Šå¥—ç‰Œ', bonus: { trigger: { type: 'on_hit', chance: 35, effect: 'counter', value: 180 } }, description: 'å—æ“Šæ™‚35%æ©Ÿç‡åæ“Šé€ æˆ180%å‚·å®³' },
            thunder: { name: 'é›·éœ†å¥—ç‰Œ', bonus: { atk: 50, crit: 15, critDmg: 40, trigger: { type: 'attack', chance: 25, effect: 'thunder_judgment', value: 500, heal: 15, goldBonus: 30 } }, description: 'æ”»æ“ŠåŠ›+50%ï¼Œæš´æ“Šç‡+15%ï¼Œæš´æ“Šå‚·å®³+40%ã€‚æ”»æ“Šæ™‚25%æ©Ÿç‡è§¸ç™¼é›·éœ†å¯©åˆ¤ï¼šé€ æˆ500%å‚·å®³ä¸¦å›å¾©15%ç”Ÿå‘½ï¼Œé¡å¤–ç²å¾—30%é‡‘å¹£' }
        };

        // å¥—è£æ•ˆæœå®šç¾©ï¼ˆå¼·åŒ–ç‰ˆï¼‰
        const SET_EFFECTS = {
            'å•Ÿå‹•è€…å¥—è£': {
                2: { name: 'å•Ÿå‹•å”è­°', atkPercent: 50, defPercent: 50, hpPercent: 50 },
                4: { name: 'ç³»çµ±åŠ é€Ÿ', critBonus: 20, lifeStealBonus: 15, expBonusBonus: 30, specialEffect: 'kill_heal' }
            },
            'ç ”ç™¼è€…å¥—è£': {
                2: { name: 'ç ”ç™¼çªç ´', atkPercent: 60, critBonus: 20, critDmgBonus: 50 },
                4: { name: 'å®Œç¾ä»£ç¢¼', armorPenBonus: 30, critDmgBonus: 60, specialEffect: 'crit_chain' }
            },
            'æ©Ÿæ«ƒé˜²ç¦¦å¥—è£': {
                2: { name: 'é˜²ç«ç‰†å”è­°', defPercent: 60, hpPercent: 60, dmgRedBonus: 20 },
                4: { name: 'å®Œå…¨éš”é›¢', dmgRedBonus: 25, hpRegenBonus: 8, specialEffect: 'counter_heal' }
            },
            'é‡å­åŒæ­¥å¥—è£': {
                2: { name: 'é‡å­çºçº', atkPercent: 50, defPercent: 50, armorPenBonus: 30, bossDmgBonus: 40 },
                4: { name: 'å¥‡é»çˆ†ç™¼', critBonus: 25, critDmgBonus: 80, lifeStealBonus: 20, specialEffect: 'quantum_collapse' }
            }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        // è¨ˆç®—å¥—è£æ•ˆæœ
        function calculateSetEffects() {
            const setCount = {};
            const player = gameState.player;
            
            // çµ±è¨ˆå¥—è£ä»¶æ•¸
            ['weapon', 'armor', 'accessory1', 'accessory2'].forEach(slot => {
                const item = player.equipment[slot];
                if (item && item.setName) {
                    setCount[item.setName] = (setCount[item.setName] || 0) + 1;
                }
            });
            
            // æ¸…ç©ºä¸¦é‡æ–°è¨ˆç®—å¥—è£åŠ æˆ
            player.setEffects = {
                atkPercent: 0,      // æ”»æ“Šç™¾åˆ†æ¯”
                defPercent: 0,      // é˜²ç¦¦ç™¾åˆ†æ¯”
                hpPercent: 0,       // ç”Ÿå‘½ç™¾åˆ†æ¯”
                crit: 0,            // æš´æ“Šç‡
                critDmg: 0,         // æš´æ“Šå‚·
                dmgRed: 0,          // æ¸›å‚·
                lifeSteal: 0,       // å¸è¡€
                armorPen: 0,        // ç„¡è¦–é˜²ç¦¦
                bossDmg: 0,         // å°é¦–é ˜å‚·å®³
                hpRegen: 0,         // ç”Ÿå‘½å›å¾©
                expBonus: 0,        // ç¶“é©—åŠ æˆ
                specialEffects: [], // ç‰¹æ®Šæ•ˆæœ
                setCount: setCount
            };
            
            // æ‡‰ç”¨å¥—è£æ•ˆæœ
            for (const [setName, count] of Object.entries(setCount)) {
                const effects = SET_EFFECTS[setName];
                if (!effects) continue;
                
                // 2ä»¶å¥—æ•ˆæœ
                if (count >= 2 && effects[2]) {
                    const effect = effects[2];
                    if (effect.atkPercent) player.setEffects.atkPercent += effect.atkPercent;
                    if (effect.defPercent) player.setEffects.defPercent += effect.defPercent;
                    if (effect.hpPercent) player.setEffects.hpPercent += effect.hpPercent;
                    if (effect.critBonus) player.setEffects.crit += effect.critBonus;
                    if (effect.critDmgBonus) player.setEffects.critDmg += effect.critDmgBonus;
                    if (effect.dmgRedBonus) player.setEffects.dmgRed += effect.dmgRedBonus;
                    if (effect.lifeStealBonus) player.setEffects.lifeSteal += effect.lifeStealBonus;
                    if (effect.armorPenBonus) player.setEffects.armorPen += effect.armorPenBonus;
                    if (effect.bossDmgBonus) player.setEffects.bossDmg += effect.bossDmgBonus;
                    if (effect.hpRegenBonus) player.setEffects.hpRegen += effect.hpRegenBonus;
                    if (effect.expBonusBonus) player.setEffects.expBonus += effect.expBonusBonus;
                }
                
                // 4ä»¶å¥—æ•ˆæœ
                if (count >= 4 && effects[4]) {
                    const effect = effects[4];
                    if (effect.atkPercent) player.setEffects.atkPercent += effect.atkPercent;
                    if (effect.defPercent) player.setEffects.defPercent += effect.defPercent;
                    if (effect.hpPercent) player.setEffects.hpPercent += effect.hpPercent;
                    if (effect.critBonus) player.setEffects.crit += effect.critBonus;
                    if (effect.critDmgBonus) player.setEffects.critDmg += effect.critDmgBonus;
                    if (effect.dmgRedBonus) player.setEffects.dmgRed += effect.dmgRedBonus;
                    if (effect.lifeStealBonus) player.setEffects.lifeSteal += effect.lifeStealBonus;
                    if (effect.armorPenBonus) player.setEffects.armorPen += effect.armorPenBonus;
                    if (effect.bossDmgBonus) player.setEffects.bossDmg += effect.bossDmgBonus;
                    if (effect.hpRegenBonus) player.setEffects.hpRegen += effect.hpRegenBonus;
                    if (effect.expBonusBonus) player.setEffects.expBonus += effect.expBonusBonus;
                    if (effect.specialEffect) player.setEffects.specialEffects.push(effect.specialEffect);
                }
            }
            
            return player.setEffects;
        }

        // å¥—è£æŠ€èƒ½ç³»çµ±å·²ç§»é™¤ï¼Œæ”¹ç‚ºç´”å±¬æ€§åŠ æˆ

        // å€åŸŸå°ˆå±¬æ‰è½è£å‚™
        const REGION_LOOT = {
    'å…¥é–€é–‹ç™¼å±¤': {
        weapons: [
            { name: 'æœ¨åŠ', type: 'weapon' },
            { name: 'æœ¨æ§Œ', type: 'weapon' },
            { name: 'çŸ­åŒ•é¦–', type: 'weapon' },
            { name: 'è¼•é•·æ–', type: 'weapon' },
            { name: 'ä¿®ç†å°–éŒ', type: 'weapon' },
            { name: 'éµçŸ­åŠ', type: 'weapon' },
            { name: 'å°é‹¸åˆ€', type: 'weapon' },
            { name: 'è¨“ç·´é•·æ£', type: 'weapon' },
            { name: 'æœ¨å¼“', type: 'weapon' },
            { name: 'å·¥æˆ¿æ‰³æ‰‹', type: 'weapon' }
        ],
        armors: [
            { name: 'æ–°æ‰‹è­·ç”²', type: 'armor' },
            { name: 'å¸†å¸ƒè­·ç”²', type: 'armor' },
            { name: 'çš®é©è­·ç”²', type: 'armor' },
            { name: 'åŠ å›ºè­·ç”²', type: 'armor' },
            { name: 'å·¥ä½œè­·ç”²', type: 'armor' },
            { name: 'ç²—å¸ƒè­·ç”²', type: 'armor' },
            { name: 'å¸ƒè¢', type: 'armor' },
            { name: 'è¼•çš®ç”²', type: 'armor' },
            { name: 'å·¥å…·èƒŒå¿ƒ', type: 'armor' },
            { name: 'è€ç£¨å¤–å¥—', type: 'armor' }
        ],
        accessories: [
            { name: 'éŠ…æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ¸¬è©¦æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'é‹æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ¨™è¨˜æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç°¡æ˜“æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'éŒ«æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'éµæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'åˆ»å­—æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç´°ç¹©æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ¨¹è„‚æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'èº«åˆ†ç‰Œé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'é‡‘å±¬å°ç‰‡é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'å·¥ç‰Œé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'æ¨™ç±¤ç‰Œé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'æœ¨ç‰Œé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'çš®ç¹©é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'éŠ…ç‰Œé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'å°é½’è¼ªé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'æœ¨ç é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'ç·šåœˆå¢œ', type: 'accessory', subtype: 'necklace' }
        ]
    },
    'ç ”ç™¼æ ¸å¿ƒå±¤': {
        weapons: [
            { name: 'é•·æ§', type: 'weapon' },
            { name: 'çŸ­åˆƒ', type: 'weapon' },
            { name: 'åˆ‡å‰²åˆ€', type: 'weapon' },
            { name: 'é‡éŒ˜', type: 'weapon' },
            { name: 'èƒ½é‡æ³•æ–', type: 'weapon' },
            { name: 'åŸå‹é•·åˆ€', type: 'weapon' },
            { name: 'å¯¦é©—é•·æ£', type: 'weapon' },
            { name: 'èƒ½é‡æ§', type: 'weapon' },
            { name: 'åˆ‡å‰²é‹¸', type: 'weapon' },
            { name: 'ç£è„ˆéŒ˜', type: 'weapon' }
        ],
        armors: [
            { name: 'å¯¦é©—è­·ç”²', type: 'armor' },
            { name: 'é˜²è­·èƒŒå¿ƒ', type: 'armor' },
            { name: 'å†·æ„Ÿè­·ç”²', type: 'armor' },
            { name: 'ç·©è¡è­·ç”²', type: 'armor' },
            { name: 'çµ•ç·£è­·ç”²', type: 'armor' },
            { name: 'é˜²çˆ†å¤–å¥—', type: 'armor' },
            { name: 'é˜²é…¸å¤–è¡£', type: 'armor' },
            { name: 'å¯¦é©—è¢', type: 'armor' },
            { name: 'çµ•ç·£å¤–å¥—', type: 'armor' },
            { name: 'ç›¸ä½å¤–ç”²', type: 'armor' }
        ],
        accessories: [
            { name: 'èª¿æ ¡æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ ¡æº–æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ•¸æ“šæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'å¯¦é©—æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'è‡¨ç•Œæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'åŸå‹æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'é »ç‡æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'è„ˆè¡æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç®—æ³•æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ¸¬åºæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'è­·ç¬¦', type: 'accessory', subtype: 'necklace' },
            { name: 'ç›¸ä½é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'å†·å»ç›’é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'æ¸¬é‡é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'å¾½ç« é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'ç ”ç©¶å¾½ç« ', type: 'accessory', subtype: 'necklace' },
            { name: 'å¯¦é©—è­‰ç« ', type: 'accessory', subtype: 'necklace' },
            { name: 'é »ç‡åŠå¢œ', type: 'accessory', subtype: 'necklace' },
            { name: 'èƒ½é‡æ ¸å¿ƒé–', type: 'accessory', subtype: 'necklace' },
            { name: 'åƒæ•¸è­˜åˆ¥ç‰Œ', type: 'accessory', subtype: 'necklace' }
        ]
    },
    'è³‡æ–™è£‚ç¸«': {
        weapons: [
            { name: 'å¼“', type: 'weapon' },
            { name: 'é˜»æ–·çŸ­åˆ€', type: 'weapon' },
            { name: 'é‡éŒ˜', type: 'weapon' },
            { name: 'é•·çŸ›', type: 'weapon' },
            { name: 'å¹²æ“¾æ§', type: 'weapon' },
            { name: 'å¼·å¼©', type: 'weapon' },
            { name: 'çŸ­å¼©', type: 'weapon' },
            { name: 'é›»æ“Šæ£’', type: 'weapon' },
            { name: 'é˜²è¡›çŸ­åˆ€', type: 'weapon' },
            { name: 'å·¡é‚é•·æ§', type: 'weapon' }
        ],
        armors: [
            { name: 'æ©Ÿæˆ¿è­·ç”²', type: 'armor' },
            { name: 'æ•£ç†±è­·ç”²', type: 'armor' },
            { name: 'éš”é›¢æ¿ç”²', type: 'armor' },
            { name: 'å¼·åŒ–è­·ç”²', type: 'armor' },
            { name: 'å…‰çº–è­·ç”²', type: 'armor' },
            { name: 'é˜²è­·å¤–æ®¼', type: 'armor' },
            { name: 'é‡‘å±¬èƒŒå¿ƒ', type: 'armor' },
            { name: 'æ•£ç†±èƒŒå¿ƒ', type: 'armor' },
            { name: 'å…‰çº–å¤–å¥—', type: 'armor' },
            { name: 'åŠ å›ºè­·è¡£', type: 'armor' }
        ],
        accessories: [
            { name: 'åŠ å¯†æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'é‚Šç•Œæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'éš”é›¢æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ·¨åŒ–æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'è·¯å¾‘æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'é˜²ç«ç‰†æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'é€šé“æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç¯€é»æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ†‘è­‰æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç›£æ§æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ ¸å¿ƒé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'è­‰ç« é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'ç¯€é»é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'é€šè¡Œä»¤ç‰Œ', type: 'accessory', subtype: 'necklace' },
            { name: 'é–˜é“é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'å…‰çº–é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'è·¯ç”±ç‰Œ', type: 'accessory', subtype: 'necklace' },
            { name: 'ç›£æ§å¾½ç« ', type: 'accessory', subtype: 'necklace' },
            { name: 'å†—é¤˜æ›ç‰Œ', type: 'accessory', subtype: 'necklace' },
            { name: 'æ©Ÿæˆ¿é‘°åŒ™ç‰Œ', type: 'accessory', subtype: 'necklace' }
        ]
    },
    'æ·±äº•è‡¨ç•Œå±¤': {
        weapons: [
            { name: 'é‡å­ä¹‹åˆƒ', type: 'weapon' },
            { name: 'æ™‚é–“æˆ°éŒ˜', type: 'weapon' },
            { name: 'é›¶é»é•·æ§', type: 'weapon' },
            { name: 'æ›²ç‡æ³•æ–', type: 'weapon' },
            { name: 'ç›¸å¹²é•·åˆƒ', type: 'weapon' },
            { name: 'æ™‚é–“çŸ­åˆƒ', type: 'weapon' },
            { name: 'ç›¸ä½é•·åˆ€', type: 'weapon' },
            { name: 'å¥‡é»å¼“', type: 'weapon' },
            { name: 'é‡å­é•·æ£', type: 'weapon' },
            { name: 'æŠ˜ç–ŠåŒ•é¦–', type: 'weapon' }
        ],
        armors: [
            { name: 'é‡å­è­·ç”²', type: 'armor' },
            { name: 'ç–ŠåŠ è­·ç”²', type: 'armor' },
            { name: 'ç›¸å¹²è­·ç”²', type: 'armor' },
            { name: 'æ›²ç‡èƒ¸é§', type: 'armor' },
            { name: 'è‡¨ç•Œæˆ°ç”²', type: 'armor' },
            { name: 'æ™‚é–“è­·ç”²', type: 'armor' },
            { name: 'å¥‡é»è­·ç”²', type: 'armor' },
            { name: 'ç©ºé–“è­·ç”²', type: 'armor' },
            { name: 'è£‚ç¸«è­·ç”²', type: 'armor' },
            { name: 'å¹²æ¶‰è­·ç”²', type: 'armor' }
        ],
        accessories: [
            { name: 'é‡å­æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ™‚é–“æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'èƒ½é‡æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç›¸å¹²æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'é€šé‡æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'å¥‡é»æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æ™‚ç©ºæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'æŠ˜ç–Šæˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'å…±é³´æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç›¸ä½æˆ’', type: 'accessory', subtype: 'ring' },
            { name: 'ç³¾çºé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'é‡å­å¢œ', type: 'accessory', subtype: 'necklace' },
            { name: 'é›¶é»é …åœˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'ç›¸å¹²é …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'è‡¨ç•Œé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'æ™‚ç©ºé …éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'å…±é³´å¢œ', type: 'accessory', subtype: 'necklace' },
            { name: 'å¹²æ¶‰é–éˆ', type: 'accessory', subtype: 'necklace' },
            { name: 'æŠ˜ç–Šé ¸ç’°', type: 'accessory', subtype: 'necklace' },
            { name: 'å¥‡é»å‹³ç« ', type: 'accessory', subtype: 'necklace' }
        ]
    }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±

        // ========== éŠæˆ²ç‹€æ…‹ ==========
        // ========== éŸ³æ•ˆç³»çµ± ==========
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const now = audioContext.currentTime;
            
            switch(type) {
                case 'encounter': // é‡æ•µ
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.2);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    break;
                    
                case 'attack': // æ™®é€šæ”»æ“Š
                    oscillator.frequency.setValueAtTime(300, now);
                    oscillator.frequency.exponentialRampToValueAtTime(150, now + 0.1);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    oscillator.start(now);
                    oscillator.stop(now + 0.1);
                    break;
                    
                case 'crit': // æš´æ“Š
                    oscillator.frequency.setValueAtTime(600, now);
                    oscillator.frequency.exponentialRampToValueAtTime(300, now + 0.15);
                    gainNode.gain.setValueAtTime(0.35, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    oscillator.start(now);
                    oscillator.stop(now + 0.15);
                    break;
                    
                case 'hit': // å—æ“Š
                    oscillator.frequency.setValueAtTime(200, now);
                    gainNode.gain.setValueAtTime(0.25, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    oscillator.start(now);
                    oscillator.stop(now + 0.08);
                    break;
                    
                case 'skill': // æŠ€èƒ½è§¸ç™¼
                    oscillator.frequency.setValueAtTime(500, now);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(400, now + 0.2);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    oscillator.start(now);
                    oscillator.stop(now + 0.2);
                    break;
                    
                case 'victory': // å‹åˆ©
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    oscillator.start(now);
                    oscillator.stop(now + 0.3);
                    break;
                    
                case 'defeat': // å¤±æ•—
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.4);
                    gainNode.gain.setValueAtTime(0.3, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                    break;
                    
                case 'reward': // ç²å¾—çå‹µ
                    oscillator.frequency.setValueAtTime(600, now);
                    oscillator.frequency.setValueAtTime(800, now + 0.05);
                    gainNode.gain.setValueAtTime(0.2, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    oscillator.start(now);
                    oscillator.stop(now + 0.15);
                    break;
                    
                case 'levelup': // å‡ç´š
                    oscillator.frequency.setValueAtTime(400, now);
                    oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                    oscillator.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                    oscillator.frequency.exponentialRampToValueAtTime(1000, now + 0.3);
                    gainNode.gain.setValueAtTime(0.35, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    oscillator.start(now);
                    oscillator.stop(now + 0.4);
                    break;
            }
        }
        
        // ========== éŠæˆ²ç‰ˆæœ¬æ§åˆ¶ ==========
        const GAME_VERSION = '1.0.1'; // ä¿®å¾©å¿«å–å•é¡Œ
        const FILE_VERSION_KEY = 'darui_file_version';
        const CURRENT_FILE_TIMESTAMP = Date.now(); // æª”æ¡ˆæ™‚é–“æˆ³
        const SAVE_KEY = 'darui_game_save';
        
        // ========== localStorage åŒ…è£å™¨ï¼ˆæ”¯æ´æ²™ç›’ç’°å¢ƒï¼‰ ==========
        const storage = (() => {
            let memoryStorage = {};
            let useMemory = false;
            
            // æ¸¬è©¦localStorageæ˜¯å¦å¯ç”¨
            try {
                const testKey = '__storage_test__';
                localStorage.setItem(testKey, 'test');
                localStorage.removeItem(testKey);
            } catch (e) {
                console.warn('localStorage ä¸å¯ç”¨ï¼Œä½¿ç”¨è¨˜æ†¶é«”å„²å­˜ï¼ˆé—œé–‰åˆ†é å¾Œæ•¸æ“šå°‡éºå¤±ï¼‰');
                useMemory = true;
            }
            
            return {
                getItem: (key) => {
                    if (useMemory) {
                        // åœ¨è¨˜æ†¶é«”æ¨¡å¼ä¸‹ï¼Œå˜—è©¦å¾localStorageè®€å–èˆŠå­˜æª”
                        if (!memoryStorage[key]) {
                            try {
                                const oldSave = localStorage.getItem(key);
                                if (oldSave) {
                                    console.log('å¾localStorageé·ç§»èˆŠå­˜æª”åˆ°è¨˜æ†¶é«”');
                                    memoryStorage[key] = oldSave;
                                    return oldSave;
                                }
                            } catch (e) {
                                // localStorageä¸å¯ç”¨ï¼Œå¿½ç•¥
                            }
                        }
                        return memoryStorage[key] || null;
                    }
                    try {
                        return localStorage.getItem(key);
                    } catch (e) {
                        return memoryStorage[key] || null;
                    }
                },
                setItem: (key, value) => {
                    if (useMemory) {
                        memoryStorage[key] = value;
                        return;
                    }
                    try {
                        localStorage.setItem(key, value);
                    } catch (e) {
                        memoryStorage[key] = value;
                    }
                },
                removeItem: (key) => {
                    if (useMemory) {
                        delete memoryStorage[key];
                        return;
                    }
                    try {
                        localStorage.removeItem(key);
                    } catch (e) {
                        delete memoryStorage[key];
                    }
                },
                clear: () => {
                    if (useMemory) {
                        memoryStorage = {};
                        return;
                    }
                    try {
                        localStorage.clear();
                    } catch (e) {
                        memoryStorage = {};
                    }
                }
            };
        })();
        
        let gameState = {
            version: GAME_VERSION,
            player: {
                name: '',
                class: '',
                level: 1,
                exp: 0,
                expToNext: 100,
                hp: 100,
                maxHp: 100,
                ap: 100,
                maxAp: 100,
                gold: 200,
                shards: 0,
                atk: 10,
                def: 5,
                crit: 5,
                critDmg: 150,
                dmgRed: 0,
                lifeSteal: 0,
                armorPen: 0,
                bossDmg: 0,
                hpRegen: 0,
                expBonus: 0,
                luck: 0,        // å¹¸é‹å€¼ï¼ˆæ‰å¯¶ç‡åŠ æˆï¼‰
                goldBonus: 0,   // é‡‘å¹£åŠ æˆ
                equipment: {
                    weapon: null,
                    armor: null,
                    accessory1: null,
                    accessory2: null
                },
                skill: null,  // é¸æ“‡çš„æŠ€èƒ½
                buffs: [],    // ç•¶å‰Buffæ•ˆæœ
                classBonus: {} // è·æ¥­è¢«å‹•åŠ æˆ
            },
            region: 0,
            battleProgress: 0,
            inventory: [],
            maxInventory: 50,  // èƒŒåŒ…ä¸Šé™
            potionCooldown: 0, // è—¥æ°´å†·å»æ™‚é–“æˆ³
            autoExplore: false, // è‡ªå‹•æˆ°é¬¥ç‹€æ…‹
            autoExploreInterval: null, // è‡ªå‹•æˆ°é¬¥è¨ˆæ™‚å™¨
            autoPotion: false, // è‡ªå‹•å–è—¥ç‹€æ…‹
            autoPotionThreshold: 50, // è‡ªå‹•å–è—¥é–€æª»ï¼ˆç™¾åˆ†æ¯”ï¼‰
            apRegenTime: Date.now(), // é«”åŠ›å›å¾©æ™‚é–“æˆ³
            hpRegenTime: Date.now(), // ç”Ÿå‘½å›å¾©æ™‚é–“æˆ³
            stats: {
                kills: 0,
                items: 0,
                startTime: Date.now(),
                legendaryItems: 0,  // å‚³èªªè£å‚™ç²å¾—æ•¸é‡
                currentWinStreak: 0,  // ç•¶å‰é€£å‹
                maxWinStreak: 0  // æœ€é«˜é€£å‹
            },
            iteration: {
                count: 0,  // è¿­ä»£æ¬¡æ•¸
                totalIP: 0,  // ç¸½è¿­ä»£é»æ•¸
                availableIP: 0,  // å¯ç”¨è¿­ä»£é»æ•¸
                talents: {},  // å·²è§£é–çš„å¤©è³¦ {talentId: level}
                completedBosses: []  // å·²å®Œæˆçš„Bossåˆ—è¡¨
            },
            dailyQuests: {
                lastReset: Date.now(),  // ä¸Šæ¬¡é‡ç½®æ™‚é–“
                quests: [],  // ç•¶å‰ä»»å‹™åˆ—è¡¨
                completed: [],  // å·²å®Œæˆçš„ä»»å‹™ID
                rewardsClaimed: {  // å·²é ˜å–çš„å®Œæˆåº¦çå‹µ
                    three: false,
                    five: false
                },
                totalCompleted: 0  // ç¸½å®Œæˆä»»å‹™æ•¸
            },
            titles: {
                unlocked: [],  // å·²è§£é–çš„ç¨±è™ŸID
                equipped: null,  // ç•¶å‰è£å‚™çš„ç¨±è™ŸID
                progress: {}  // ç¨±è™Ÿé€²åº¦ {titleId: progress}
            },
            dungeons: {
                records: {}  // å‰¯æœ¬æŒ‘æˆ°è¨˜éŒ„ {dungeonId_difficulty: {cleared, dailyCount, totalCount, bestTime, lastReset}}
            },
            companions: {
                owned: [],  // æ“æœ‰çš„éš¨å¾åˆ—è¡¨
                active: null,  // ç•¶å‰è£å‚™çš„éš¨å¾
                equipment: null,  // ç•¶å‰è£å‚™çš„è£å‚™ (attack/defense/heal)
                shards: 0,  // éš¨å¾ç¢ç‰‡æ•¸é‡
                equipmentLevels: {  // è£å‚™ç­‰ç´š
                    attack: 1,
                    defense: 1,
                    heal: 1
                },
                cooldowns: {}  // æŠ€èƒ½å†·å´æ™‚é–“
            },
            offline: {
                lastOnlineTime: Date.now(),  // ä¸Šæ¬¡åœ¨ç·šæ™‚é–“
                totalOfflineTime: 0,  // ç´¯è¨ˆé›¢ç·šæ™‚é–“ï¼ˆæ¯«ç§’ï¼‰
                rewardsClaimed: true,  // æ˜¯å¦å·²é ˜å–çå‹µ
                stats: {
                    totalGoldEarned: 0,  // é›¢ç·šç²å¾—é‡‘å¹£
                    totalExpEarned: 0,  // é›¢ç·šç²å¾—ç¶“é©—
                    claimCount: 0  // é ˜å–æ¬¡æ•¸
                }
            },
            cards: {
                slot1: null,  // å¡æ§½1
                slot2: null,  // å¡æ§½2
                collection: [],  // å¡ç‰Œæ”¶è—
                shards: {},  // å¡ç‰Œç¢ç‰‡ {rarity: count}
                stats: {
                    totalCardsObtained: 0,  // ç¸½ç²å¾—å¡ç‰Œæ•¸
                    totalCardsUpgraded: 0,  // ç¸½å‡ç´šæ¬¡æ•¸
                    deckEffectsTriggered: 0  // å¥—ç‰Œæ•ˆæœè§¸ç™¼æ¬¡æ•¸
                }
            },
            endlessMode: {
                unlocked: false,           // æ˜¯å¦è§£é–(Lv.30)
                active: false,             // æ˜¯å¦æ­£åœ¨é€²è¡Œ
                currentFloor: 1,           // ç•¶å‰å±¤æ•¸
                highestFloor: 0,           // æ­·å²æœ€é«˜å±¤æ•¸
                checkpoint: 1,             // æœ€è¿‘æª¢æŸ¥é»(æ¯10å±¤)
                buffs: [],                 // æ°¸ä¹…Buffåˆ—è¡¨ [{id, name, type, value, floor}]
                lastEntryDate: null,       // ä¸Šæ¬¡é€²å…¥æ—¥æœŸ (YYYY-MM-DD)
                dailyEntered: false,       // ä»Šæ—¥æ˜¯å¦å·²é€²å…¥
                stats: {
                    totalKills: 0,         // ç¸½æ“Šæ®ºæ•¸
                    totalGold: 0,          // ç¸½ç²å¾—é‡‘å¹£
                    totalFloors: 0,        // ç¸½é€šé—œå±¤æ•¸
                    totalRuns: 0,          // ç¸½æŒ‘æˆ°æ¬¡æ•¸
                    averageFloor: 0        // å¹³å‡å±¤æ•¸
                }
            },
            codex: {
                monsters: {},      // æ€ªç‰©åœ–é‘‘ {monsterName: {name, icon, region, type, killCount, firstKillTime, unlocked, rewardsCollected}}
                equipment: {},     // è£å‚™åœ–é‘‘ {equipKey: {name, type, rarity, icon, obtained, firstObtainTime, obtainCount}}
                companions: {},    // éš¨å¾åœ–é‘‘ {companionId: {id, name, type, rarity, obtained, firstObtainTime}}
                cards: {},         // å¡ç‰Œåœ–é‘‘ {cardId: {id, name, type, rarity, series, obtained, firstObtainTime}}
                pets: {},          // å¯µç‰©åœ–é‘‘ {petId: {id, name, family, stage, rarity, obtained, firstObtainTime}}
                stats: {
                    totalMonstersUnlocked: 0,
                    totalEquipmentObtained: 0,
                    totalCompanionsObtained: 0,
                    totalCardsObtained: 0,
                    totalPetsObtained: 0
                },
                rewardsCollected: {  // å·²é ˜å–çš„é€²åº¦çå‹µ
                    monsters: [],    // [å€åŸŸåç¨±]
                    equipment: [],   // [5, 10, 15, 21]
                    companions: [],  // [3, 6, 10, 13]
                    cards: []        // [5, 10, 15, 20]
                }
            },
            autoEquipment: {
                enabled: false,  // æ˜¯å¦å•Ÿç”¨è‡ªå‹•è£å‚™
                autoSalvage: false,  // æ˜¯å¦å•Ÿç”¨è‡ªå‹•åˆ†è§£
                salvageQuality: ['common'],  // è‡ªå‹•åˆ†è§£çš„å“è³ª ['common', 'uncommon', 'fine']
                protectSet: true,  // ä¿è­·å¥—è£è£å‚™
                considerSet: false,  // è©•åˆ†æ™‚è€ƒæ…®å¥—è£æ•ˆæœ
                stats: {
                    autoEquipped: 0,  // è‡ªå‹•è£å‚™æ¬¡æ•¸
                    autoSalvaged: 0,  // è‡ªå‹•åˆ†è§£æ¬¡æ•¸
                    materialsGained: 0  // ç²å¾—çš„ææ–™æ•¸
                }
            },
            materials: {
                enhanceStone: 0,  // å¼·åŒ–çŸ³
                reforgeStone: 0,  // é‡é‹±çŸ³
                evolutionStone: 0, // é€²åŒ–çŸ³
                eternalSource: 0   // æ°¸æ†ä¹‹æº
            },
            pets: {
                collection: [],    // å·²æ“æœ‰çš„å¯µç‰© [{instanceId, baseId, name, level, exp, stats, skills, ...}]
                equipped: null,    // ç•¶å‰è£å‚™çš„å¯µç‰© (instanceId)
                eggs: [],          // å¯µç‰©è›‹ [{family, hatchTime}]
                shards: {}         // å¯µç‰©ç¢ç‰‡ {family: count}
            }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        let selectedClass = null;
        let currentEquipSlot = null;


        // ========== BGM ç³»çµ± ==========
        let bgmEnabled = true;
        let currentBGMIndex = 0;
        let bgmAudio1 = null;
        let bgmAudio2 = null;
        let bgmVolume = 0.5;
        
        // åˆå§‹åŒ– BGM
        function initBGM() {
            bgmAudio1 = new Audio('BGM1.mp3');
            bgmAudio2 = new Audio('BGM2.mp3');
            
            bgmAudio1.volume = bgmVolume;
            bgmAudio2.volume = bgmVolume;
            
            // ç•¶ BGM1 æ’­æ”¾çµæŸæ™‚ï¼Œæ’­æ”¾ BGM2
            bgmAudio1.addEventListener('ended', () => {
                if (bgmEnabled) {
                    currentBGMIndex = 1;
                    bgmAudio2.play().catch(e => console.log('BGM2 æ’­æ”¾å¤±æ•—:', e));
                }
            });
            
            // ç•¶ BGM2 æ’­æ”¾çµæŸæ™‚ï¼Œæ’­æ”¾ BGM1
            bgmAudio2.addEventListener('ended', () => {
                if (bgmEnabled) {
                    currentBGMIndex = 0;
                    bgmAudio1.play().catch(e => console.log('BGM1 æ’­æ”¾å¤±æ•—:', e));
                }
            });
            
            // å˜—è©¦è‡ªå‹•æ’­æ”¾ï¼ˆå¯èƒ½è¢«ç€è¦½å™¨é˜»æ­¢ï¼‰
            if (bgmEnabled) {
                bgmAudio1.play().catch(e => {
                    console.log('BGM è‡ªå‹•æ’­æ”¾è¢«é˜»æ­¢ï¼Œè«‹é»æ“Šé é¢å¾Œæœƒé–‹å§‹æ’­æ”¾');
                });
            }
        }
        
        // åˆ‡æ› BGM é–‹é—œ
        function toggleBGM() {
            bgmEnabled = !bgmEnabled;
            const btn = document.getElementById('bgm-toggle-btn');
            
            if (bgmEnabled) {
                btn.textContent = 'ğŸµ BGM: ON';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                
                // æ’­æ”¾ç•¶å‰æ‡‰è©²æ’­æ”¾çš„ BGM
                if (currentBGMIndex === 0) {
                    bgmAudio1.play().catch(e => console.log('BGM1 æ’­æ”¾å¤±æ•—:', e));
                } else {
                    bgmAudio2.play().catch(e => console.log('BGM2 æ’­æ”¾å¤±æ•—:', e));
                }
            } else {
                btn.textContent = 'ğŸ”‡ BGM: OFF';
                btn.style.background = 'linear-gradient(135deg, #6c757d 0%, #495057 100%)';
                
                // æš«åœæ‰€æœ‰ BGM
                bgmAudio1.pause();
                bgmAudio2.pause();
            }
        }
        
        // èª¿æ•´ BGM éŸ³é‡
        function changeBGMVolume(value) {
            bgmVolume = value / 100;
            if (bgmAudio1) bgmAudio1.volume = bgmVolume;
            if (bgmAudio2) bgmAudio2.volume = bgmVolume;
            document.getElementById('volume-display').textContent = value + '%';
        }
        
        // åœ¨é é¢åŠ è¼‰å®Œæˆå¾Œåˆå§‹åŒ– BGM
        document.addEventListener('DOMContentLoaded', () => {
            initBGM();
            
            // æ·»åŠ ç”¨æˆ¶äº¤äº’ç›£è½ï¼Œç¢ºä¿ BGM èƒ½æ’­æ”¾
            document.addEventListener('click', () => {
                if (bgmEnabled && bgmAudio1.paused && bgmAudio2.paused) {
                    if (currentBGMIndex === 0) {
                        bgmAudio1.play().catch(e => console.log('BGM1 æ’­æ”¾å¤±æ•—:', e));
                    } else {
                        bgmAudio2.play().catch(e => console.log('BGM2 æ’­æ”¾å¤±æ•—:', e));
                    }
                }
            }, { once: true });
        });

        // ========== åˆå§‹åŒ– ==========
        document.addEventListener('DOMContentLoaded', () => {
            // æª¢æŸ¥æª”æ¡ˆç‰ˆæœ¬ï¼Œé˜²æ­¢å¿«å–
            try {
                const storedFileVersion = storage.getItem(FILE_VERSION_KEY);
                if (storedFileVersion && storedFileVersion !== GAME_VERSION) {
                    console.log(`æª¢æ¸¬åˆ°æª”æ¡ˆç‰ˆæœ¬æ›´æ–°ï¼š${storedFileVersion} -> ${GAME_VERSION}`);
                    // æ›´æ–°ç‰ˆæœ¬è¨˜éŒ„
                    storage.setItem(FILE_VERSION_KEY, GAME_VERSION);
                    
                    // å¼·åˆ¶é‡æ–°è¼‰å…¥ä»¥æ¸…é™¤å¿«å–
                    if (storedFileVersion !== null) {
                        console.log('æ¸…é™¤å¿«å–ä¸¦é‡æ–°è¼‰å…¥...');
                        location.reload(true);
                        return;
                    }
                } else if (!storedFileVersion) {
                    // é¦–æ¬¡è¼‰å…¥ï¼Œè¨˜éŒ„ç‰ˆæœ¬
                    storage.setItem(FILE_VERSION_KEY, GAME_VERSION);
                }
            } catch (e) {
                console.error('ç‰ˆæœ¬æª¢æŸ¥å¤±æ•—ï¼š', e);
            }
            
            // ä¸»é¸å–®æŒ‰éˆ•
            document.getElementById('new-game-btn').addEventListener('click', () => {
                // æª¢æŸ¥æ˜¯å¦æœ‰å­˜æª”
                const hasSave = storage.getItem(SAVE_KEY) !== null;
                
                if (hasSave) {
                    // æœ‰å­˜æª”æ™‚é¡¯ç¤ºç¢ºèªå°è©±æ¡†
                    const confirmed = confirm('âš ï¸ è­¦å‘Šï¼\n\né–‹å§‹æ–°éŠæˆ²å°‡æœƒåˆªé™¤ç¾æœ‰å­˜æª”ï¼\n\nç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ');
                    
                    if (confirmed) {
                        // ç¢ºèªå¾Œå†æ¬¡ç¢ºèª
                        const doubleConfirmed = confirm('å†æ¬¡ç¢ºèªï¼š\n\nä½ çš„æ‰€æœ‰é€²åº¦å°‡æœƒæ°¸ä¹…åˆªé™¤ï¼\n\nçœŸçš„è¦é–‹å§‹æ–°éŠæˆ²å—ï¼Ÿ');
                        
                        if (doubleConfirmed) {
                            showCharacterCreation();
                        }
                    }
                } else {
                    // æ²’æœ‰å­˜æª”æ™‚ç›´æ¥é–‹å§‹
                    showCharacterCreation();
                }
            });
            document.getElementById('load-game-btn').addEventListener('click', loadGame);
            document.getElementById('how-to-play-btn').addEventListener('click', openHowToPlay);
            
            // è‡ªå‹•è£å‚™æŒ‰éˆ•
            const autoEquipBtn = document.getElementById('auto-equip-btn');
            if (autoEquipBtn) {
                autoEquipBtn.addEventListener('click', openAutoEquipSettings);
            }
            
            // è§’è‰²å‰µå»ºæŒ‰éˆ•
            document.getElementById('confirm-character-btn').addEventListener('click', confirmCharacter);
            document.getElementById('back-to-menu-btn').addEventListener('click', backToMenu);
            document.getElementById('confirm-skill-btn').addEventListener('click', confirmSkill);
            
            // ç”Ÿæˆè·æ¥­é¸æ“‡
            generateClassSelection();
            
            // é«”åŠ›å’Œç”Ÿå‘½å›å¾©
            setInterval(() => {
                checkAndRecoverResources();
                updateUI();
                
                // å¦‚æœä»»å‹™é¢æ¿æ‰“é–‹ï¼Œæ›´æ–°å€è¨ˆæ™‚
                if (document.getElementById('daily-quests-modal').style.display === 'flex') {
                    updateDailyQuestsUI();
                }
            }, 1000); // æ¯ç§’æ›´æ–°
            
            // æ›´æ–°éŠæˆ²æ™‚é–“
            setInterval(updateGameTime, 60000); // æ¯åˆ†é˜æ›´æ–°
            
            // å®šæœŸè‡ªå‹•å­˜æª”ï¼ˆæ¯30ç§’ï¼‰
            setInterval(() => {
                if (document.getElementById('game-main').style.display === 'block') {
                    try {
                        gameState.version = GAME_VERSION;
                        gameState.lastSaveTime = Date.now(); // è¨˜éŒ„å­˜æª”æ™‚é–“
                        storage.setItem(SAVE_KEY, JSON.stringify(gameState));
                        console.log('è‡ªå‹•å­˜æª”å®Œæˆ');
                    } catch (e) {
                        console.error('è‡ªå‹•å­˜æª”å¤±æ•—', e);
                    }
                }
            }, 30000); // 30ç§’ = 30000æ¯«ç§’
        });

        // ========== è·æ¥­é¸æ“‡ ==========
        function generateClassSelection() {
            const container = document.getElementById('class-selection');
            const classes = [
                { name: 'ç³»çµ±æ¶æ§‹å¸«', icon: 'ğŸ›¡ï¸', desc: 'å¹³è¡¡å‹ï¼Œæ“…é•·é˜²ç¦¦' },
                { name: 'æš´åŠ›æ¸¬è©¦å“¡', icon: 'ğŸ”¨', desc: 'é«˜æ”»æ“Šé«˜æš´æ“Š' },
                { name: 'æ»²é€å·¥ç¨‹å¸«', icon: 'ğŸ”ª', desc: 'é«˜æ•æ·é«˜æš´æ“Šç‡' },
                { name: 'æ•¸æ“šç§‘å­¸å®¶', icon: 'ğŸ“Š', desc: 'é­”æ³•å‹ï¼ŒæŒçºŒæˆé•·' },
                { name: 'é‹ç¶­å·¥ç¨‹å¸«', icon: 'âš™ï¸', desc: 'é«˜ç”Ÿå‘½é«˜é˜²ç¦¦' },
                { name: 'å‰ç«¯é–‹ç™¼è€…', icon: 'ğŸ¨', desc: 'å‡è¡¡æ”»æ“Šï¼Œç©©å®šè¼¸å‡º' },
                { name: 'å€å¡Šéˆå·¥ç¨‹å¸«', icon: 'ğŸ”—', desc: 'å …éŸŒé˜²ç¦¦ï¼Œç©©å®šæˆé•·' },
                { name: 'AIè¨“ç·´å¸«', icon: 'ğŸ¤–', desc: 'æ¥µé«˜æš´æ“Šï¼Œè„†çš®è¼¸å‡º' },
                { name: 'é›²ç«¯æ¶æ§‹å¸«', icon: 'â˜ï¸', desc: 'é«˜è€ä¹…ï¼Œç©©å®šé˜²ç¦¦' }
            ];
            
            classes.forEach(cls => {
                const card = document.createElement('div');
                card.style.cssText = `
                    padding: 20px; 
                    border-radius: 10px; 
                    cursor: pointer;
                    border: 2px solid rgba(0, 217, 255, 0.3);
                    background: rgba(0, 217, 255, 0.05);
                    transition: all 0.3s;
                    text-align: center;
                `;
                const classData = CLASSES[cls.name];
                let bonusText = [];
                if (classData.bonusHp) bonusText.push(`ç”Ÿå‘½+${classData.bonusHp}%`);
                if (classData.bonusDef) bonusText.push(`é˜²ç¦¦+${classData.bonusDef}%`);
                if (classData.bonusAtk) bonusText.push(`æ”»æ“Š+${classData.bonusAtk}%`);
                if (classData.bonusCrit) bonusText.push(`æš´æ“Š+${classData.bonusCrit}%`);
                if (classData.bonusCritDmg) bonusText.push(`æš´å‚·+${classData.bonusCritDmg}%`);
                
                card.innerHTML = `
                    <div style="font-size: 3rem; margin-bottom: 10px;">${cls.icon}</div>
                    <h3 style="color: #00d9ff; margin-bottom: 10px;">${cls.name}</h3>
                    <p style="color: #7a8fb8; font-size: 0.9rem;">${cls.desc}</p>
                    <div style="margin-top: 15px; font-size: 0.85rem; color: #7a8fb8;">
                        <div>ç”Ÿå‘½: ${classData.hp}</div>
                        <div>æ”»æ“Š: ${classData.atk}</div>
                        <div>é˜²ç¦¦: ${classData.def}</div>
                    </div>
                    ${bonusText.length > 0 ? `
                        <div style="margin-top: 10px; padding: 8px; background: rgba(0, 255, 136, 0.1); border-radius: 5px; border: 1px solid rgba(0, 255, 136, 0.3);">
                            <div style="font-size: 0.75rem; color: #00ff88; margin-bottom: 3px;">âœ¨ è¢«å‹•åŠ æˆ</div>
                            <div style="font-size: 0.8rem; color: #00ff88;">${bonusText.join('ã€')}</div>
                        </div>
                    ` : ''}
                `;
                card.addEventListener('click', () => selectClass(cls.name, card));
                container.appendChild(card);
            });
        }

        function selectClass(className, card) {
            // ç§»é™¤å…¶ä»–å¡ç‰‡çš„é¸ä¸­ç‹€æ…‹
            document.querySelectorAll('#class-selection > div').forEach(c => {
                c.style.border = '2px solid rgba(0, 217, 255, 0.3)';
                c.style.boxShadow = 'none';
            });
            
            // è¨­ç½®ç•¶å‰å¡ç‰‡ç‚ºé¸ä¸­ç‹€æ…‹
            card.style.border = '2px solid #00d9ff';
            card.style.boxShadow = '0 0 20px rgba(0, 217, 255, 0.5)';
            selectedClass = className;
        }

        function showCharacterCreation() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('character-creation').style.display = 'block';
            
            // æ•™å­¸ç³»çµ±å·²ç§»é™¤
        }

        function backToMenu() {
            document.getElementById('character-creation').style.display = 'none';
            document.getElementById('start-screen').style.display = 'block';
            selectedClass = null;
            document.getElementById('character-name').value = '';
        }

        function confirmCharacter() {
            const name = document.getElementById('character-name').value.trim();
            if (!name) {
                alert('è«‹è¼¸å…¥è§’è‰²åç¨±ï¼');
                return;
            }
            if (!selectedClass) {
                alert('è«‹é¸æ“‡è·æ¥­ï¼');
                return;
            }
            
            // åˆå§‹åŒ–è§’è‰²
            const classStats = CLASSES[selectedClass];
            gameState.player.name = name;
            gameState.player.class = selectedClass;
            gameState.player.hp = classStats.hp;
            gameState.player.maxHp = classStats.hp;
            gameState.player.atk = classStats.atk;
            gameState.player.def = classStats.def;
            gameState.player.crit = classStats.crit;
            gameState.player.critDmg = classStats.critDmg;
            
            // åˆå§‹åŒ–æ–°å¢å±¬æ€§
            gameState.player.dmgRed = 0;
            gameState.player.lifeSteal = 0;
            gameState.player.armorPen = 0;
            gameState.player.bossDmg = 0;
            
            // å„²å­˜è·æ¥­è¢«å‹•åŠ æˆ
            gameState.player.classBonus = {
                bonusHp: classStats.bonusHp || 0,
                bonusDef: classStats.bonusDef || 0,
                bonusAtk: classStats.bonusAtk || 0,
                bonusCrit: classStats.bonusCrit || 0,
                bonusCritDmg: classStats.bonusCritDmg || 0
            };
            
            // æ·»åŠ å‡ºç”Ÿç¦®åŒ…é“å…·
            gameState.inventory.push({
                id: Date.now() + Math.random(),
                type: 'consumable',
                subtype: 'starter_pack',
                name: 'ğŸ å‡ºç”Ÿç¦®åŒ…',
                description: '[ä¸€æ¬¡æ€§] é–‹å•Ÿç²å¾—æ–°æ‰‹è£å‚™ã€éš¨å¾ã€å¡ç‰Œå’Œè—¥æ°´',
                quantity: 1,
                canUse: true
            });
            
            // åˆå§‹åŒ–æ¯æ—¥ä»»å‹™ç³»çµ±
            if (!gameState.dailyQuests) {
                gameState.dailyQuests = {
                    lastReset: Date.now(),
                    quests: [],
                    completed: [],
                    rewardsClaimed: { three: false, five: false },
                    refreshCount: 3, // æ¯æ—¥å¯é‡ç½®æ¬¡æ•¸
                    totalCompleted: 0
                };
            }
            
            // åˆå§‹åŒ–ç¨±è™Ÿç³»çµ±
            if (!gameState.titles) {
                gameState.titles = {
                    unlocked: [],
                    equipped: null,
                    progress: {}
                };
            }
            
            // é‡æ–°è¨ˆç®—å±¬æ€§ï¼ˆåŒ…å«è£å‚™åŠ æˆï¼‰
            recalculateStats();
            
            // é¡¯ç¤ºæŠ€èƒ½é¸æ“‡é é¢
            showSkillSelection();
        }


        let selectedSkill = null;
        
        function showSkillSelection() {
            document.getElementById('character-creation').style.display = 'none';
            document.getElementById('skill-selection').style.display = 'block';
            
            const skillCards = document.getElementById('skill-cards');
            skillCards.innerHTML = Object.keys(SKILLS).map(skillName => {
                const skill = SKILLS[skillName];
                let typeIcon = '', typeLabel = '';
                if (skill.type === 'attack') { typeIcon = 'âš”ï¸'; typeLabel = 'æ”»æ“ŠæŠ€èƒ½'; }
                else if (skill.type === 'counter') { typeIcon = 'ğŸ›¡ï¸'; typeLabel = 'é˜²ç¦¦æŠ€èƒ½'; }
                else if (skill.type === 'buff') { typeIcon = 'âœ¨'; typeLabel = 'å¢ç›ŠæŠ€èƒ½'; }
                
                return `<div class="skill-card" onclick="selectSkill('${skillName}')" style="padding:20px;background:linear-gradient(135deg,rgba(0,217,255,0.05) 0%,rgba(0,217,255,0.1) 100%);border:2px solid rgba(0,217,255,0.3);border-radius:12px;cursor:pointer;transition:all 0.3s;"><div style="font-size:2rem;text-align:center;margin-bottom:10px;">${typeIcon}</div><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff;text-align:center;margin-bottom:8px;">${skillName}</div><div style="font-size:0.9rem;color:#7a8fb8;text-align:center;margin-bottom:12px;">${typeLabel}</div><div style="font-size:0.95rem;color:#e0e6ff;line-height:1.6;">${skill.desc}</div></div>`;
            }).join('');
        }
        
        function selectSkill(skillName) {
            document.querySelectorAll('.skill-card').forEach(card => {
                card.style.border = '2px solid rgba(0, 217, 255, 0.3)';
                card.style.boxShadow = 'none';
            });
            event.target.closest('.skill-card').style.border = '2px solid #00d9ff';
            event.target.closest('.skill-card').style.boxShadow = '0 0 20px rgba(0, 217, 255, 0.5)';
            selectedSkill = skillName;
        }
        
        function confirmSkill() {
            if (!selectedSkill) { alert('è«‹é¸æ“‡ä¸€å€‹æŠ€èƒ½ï¼'); return; }
            gameState.player.skill = selectedSkill;
            startGame();
        }
        
        // æŠ€èƒ½é¸æ“‡æ¨¡æ…‹è¦–çª—ç›¸é—œå‡½æ•¸
        let modalSelectedSkill = null;
        
        function openSkillSelectionModal() {
            const modal = document.getElementById('skill-selection-modal');
            const skillCards = document.getElementById('skill-modal-cards');
            
            skillCards.innerHTML = Object.keys(SKILLS).map(skillName => {
                const skill = SKILLS[skillName];
                let typeIcon = '', typeLabel = '';
                if (skill.type === 'attack') { typeIcon = 'âšœï¸'; typeLabel = 'æ”»æ“ŠæŠ€èƒ½'; }
                else if (skill.type === 'counter') { typeIcon = 'ğŸ›¡ï¸'; typeLabel = 'é˜²ç¦¦æŠ€èƒ½'; }
                else if (skill.type === 'buff') { typeIcon = 'âœ¨'; typeLabel = 'å¢ç›ŠæŠ€èƒ½'; }
                
                const isCurrentSkill = gameState.player.skill === skillName;
                const borderColor = isCurrentSkill ? '#FFD700' : 'rgba(0, 217, 255, 0.3)';
                
                return `<div class="skill-modal-card" onclick="selectModalSkill('${skillName}')" style="padding:20px;background:linear-gradient(135deg,rgba(0,217,255,0.05) 0%,rgba(0,217,255,0.1) 100%);border:2px solid ${borderColor};border-radius:12px;cursor:pointer;transition:all 0.3s;"><div style="font-size:2rem;text-align:center;margin-bottom:10px;">${typeIcon}</div><div style="font-size:1.2rem;font-weight:bold;color:#00d9ff;text-align:center;margin-bottom:8px;">${skillName}</div><div style="font-size:0.9rem;color:#7a8fb8;text-align:center;margin-bottom:12px;">${typeLabel}</div><div style="font-size:0.95rem;color:#e0e6ff;line-height:1.6;">${skill.desc}</div>${isCurrentSkill ? '<div style="text-align:center;margin-top:10px;color:#FFD700;font-weight:bold;">â˜… ç•¶å‰æŠ€èƒ½</div>' : ''}</div>`;
            }).join('');
            
            modalSelectedSkill = null;
            modal.classList.add('active');
        }
        
        function selectModalSkill(skillName) {
            document.querySelectorAll('.skill-modal-card').forEach(card => {
                card.style.border = '2px solid rgba(0, 217, 255, 0.3)';
                card.style.boxShadow = 'none';
            });
            event.target.closest('.skill-modal-card').style.border = '2px solid #00d9ff';
            event.target.closest('.skill-modal-card').style.boxShadow = '0 0 20px rgba(0, 217, 255, 0.5)';
            modalSelectedSkill = skillName;
        }
        
        function confirmSkillSelection() {
            if (!modalSelectedSkill) {
                addLog('ç³»çµ±', 'è«‹é¸æ“‡ä¸€å€‹æŠ€èƒ½ï¼');
                return;
            }
            gameState.player.skill = modalSelectedSkill;
            addLog('ç³»çµ±', `å·²é¸æ“‡æŠ€èƒ½ï¼š${modalSelectedSkill}`);
            closeSkillSelectionModal();
            updateUI();
            saveGame();
        }
        
        function closeSkillSelectionModal() {
            document.getElementById('skill-selection-modal').classList.remove('active');
        }
        // æª¢æŸ¥ä¸¦æ¢å¾©è³‡æºï¼ˆé«”åŠ›å’Œç”Ÿå‘½ï¼‰
        function checkAndRecoverResources() {
            const now = Date.now();
            
            // ç¢ºä¿æ™‚é–“æˆ³å­˜åœ¨
            if (!gameState.apRegenTime) gameState.apRegenTime = now;
            if (!gameState.hpRegenTime) gameState.hpRegenTime = now;
            
            // é«”åŠ›æ¢å¾©ï¼š2åˆ†é˜å›å¾©1é»
            if (gameState.player.ap < gameState.player.maxAp) {
                const apOfflineTime = now - gameState.apRegenTime;
                const AP_REGEN_INTERVAL = 120000; // 2åˆ†é˜ = 120000æ¯«ç§’
                const apToRecover = Math.floor(apOfflineTime / AP_REGEN_INTERVAL);
                
                if (apToRecover > 0) {
                    const actualRecovery = Math.min(apToRecover, gameState.player.maxAp - gameState.player.ap);
                    gameState.player.ap += actualRecovery;
                    // æ›´æ–°æ™‚é–“æˆ³ï¼Œä¿ç•™é¤˜æ•¸
                    gameState.apRegenTime = now - (apOfflineTime % AP_REGEN_INTERVAL);
                }
            }
            
            // ç”Ÿå‘½æ¢å¾©ï¼š5ç§’å›å¾©2%æœ€å¤§ç”Ÿå‘½
            if (gameState.player.hp < gameState.player.maxHp) {
                const hpOfflineTime = now - gameState.hpRegenTime;
                const HP_REGEN_INTERVAL = 5000; // 5ç§’ = 5000æ¯«ç§’
                const regenCount = Math.floor(hpOfflineTime / HP_REGEN_INTERVAL);
                const hpToRecover = Math.floor(gameState.player.maxHp * 0.02 * regenCount); // æ¯æ¬¡å›å¾©2%æœ€å¤§ç”Ÿå‘½
                
                if (hpToRecover > 0) {
                    const actualHpRecovery = Math.min(hpToRecover, gameState.player.maxHp - gameState.player.hp);
                    gameState.player.hp += actualHpRecovery;
                    // æ›´æ–°æ™‚é–“æˆ³ï¼Œä¿ç•™é¤˜æ•¸
                    gameState.hpRegenTime = now - (hpOfflineTime % HP_REGEN_INTERVAL);
                }
            }
        }
        
        // è‡ªå‹•å–è—¥ç›¸é—œå‡½æ•¸
        function toggleAutoPotion() {
            gameState.autoPotion = document.getElementById('auto-potion-toggle').checked;
            saveGame();
            if (gameState.autoPotion) {
                const potionName = gameState.selectedPotionId ? 
                    (gameState.inventory.find(i => i.id == gameState.selectedPotionId)?.name || 'æœªé¸æ“‡') : 
                    'æœªé¸æ“‡';
                addLog('ç³»çµ±', `å·²é–‹å•Ÿè‡ªå‹•å–è—¥ï¼ˆç”Ÿå‘½ < ${gameState.autoPotionThreshold || 50}% æ™‚ä½¿ç”¨ ${potionName}ï¼‰`);
                // ç«‹å³æª¢æŸ¥æ˜¯å¦éœ€è¦å–è—¥
                if (tryAutoPotion()) {
                    updateUI();
                }
            } else {
                addLog('ç³»çµ±', 'å·²é—œé–‰è‡ªå‹•å–è—¥');
            }
        }
        
        function updateAutoPotionThreshold() {
            gameState.autoPotionThreshold = parseInt(document.getElementById('auto-potion-threshold').value);
            saveGame();
            if (gameState.autoPotion) {
                addLog('ç³»çµ±', `è‡ªå‹•å–è—¥é–€æª»å·²èª¿æ•´ç‚º ${gameState.autoPotionThreshold}%`);
                // ç«‹å³æª¢æŸ¥æ˜¯å¦éœ€è¦å–è—¥
                if (tryAutoPotion()) {
                    updateUI();
                }
            }
        }
        
        function selectPotionType() {
            const select = document.getElementById('potion-selector');
            gameState.selectedPotionId = select.value;
            saveGame();
            
            if (gameState.selectedPotionId) {
                const item = gameState.inventory.find(i => i.id == gameState.selectedPotionId);
                if (item) {
                    addLog('ç³»çµ±', `å·²é¸æ“‡è—¥æ°´ï¼š${item.name}`);
                }
            }
        }
        
        // æ›´æ–°è—¥æ°´é¸æ“‡å™¨ï¼ˆæ ¹æ“šèƒŒåŒ…ä¸­çš„è—¥æ°´ï¼‰
        function updatePotionSelector() {
            const select = document.getElementById('potion-selector');
            if (!select) return;
            
            // ç²å–æ‰€æœ‰HPè—¥æ°´ï¼ˆæ”¯æŒæ‰€æœ‰é¡å‹ï¼‰
            const hpPotions = gameState.inventory.filter(item => 
                item.type === 'consumable' && 
                (item.subtype === 'hp' || item.subtype === 'hp_percent' || item.subtype === 'hp_fixed' || 
                 item.subtype === 'hp_potion' || item.subtype === 'both_percent' || item.subtype === 'both_fixed') &&
                (item.quantity || 1) > 0
            );
            
            // å»é‡ï¼ˆæŒ‰åç¨±ï¼‰
            const uniquePotions = [];
            const seenNames = new Set();
            hpPotions.forEach(potion => {
                if (!seenNames.has(potion.name)) {
                    seenNames.add(potion.name);
                    uniquePotions.push(potion);
                }
            });
            
            // æŒ‰å›å¾©é‡æ’åºï¼ˆå¾é«˜åˆ°ä½ï¼‰
            uniquePotions.sort((a, b) => {
                const aRecovery = a.recovery || a.hpPercent || 0;
                const bRecovery = b.recovery || b.hpPercent || 0;
                return bRecovery - aRecovery;
            });
            
            // ä¿å­˜ç•¶å‰é¸æ“‡
            const currentValue = gameState.selectedPotionId || '';
            
            // æ¸…ç©ºé¸é …
            select.innerHTML = '<option value="">é¸æ“‡è—¥æ°´...</option>';
            
            // æ·»åŠ è—¥æ°´é¸é …
            uniquePotions.forEach(potion => {
                const option = document.createElement('option');
                option.value = potion.id;
                let percent;
                
                // å„ªå…ˆæª¢æŸ¥ hpPercent å±¬æ€§ï¼ˆæ–°æ‰‹åŒ…è—¥æ°´ä½¿ç”¨ï¼‰
                if (potion.hpPercent !== undefined) {
                    percent = Math.round(potion.hpPercent * 100);
                } else if (potion.recovery !== undefined) {
                    // æª¢æŸ¥æ˜¯å¦ç‚ºç™¾åˆ†æ¯”é¡å‹
                    if (potion.subtype === 'hp' || potion.subtype === 'hp_percent' || potion.subtype === 'hp_potion') {
                        percent = Math.round(potion.recovery * 100);
                    } else if (potion.subtype === 'hp_fixed') {
                        percent = potion.recovery;
                    }
                } else if (potion.subtype === 'both_percent') {
                    percent = Math.round(potion.hpPercent * 100);
                } else if (potion.subtype === 'both_fixed') {
                    percent = potion.hpRecovery;
                } else {
                    // é è¨­å€¼ï¼Œé˜²æ­¢ NaN
                    percent = 0;
                }
                
                option.textContent = `${potion.name} (${percent}${potion.subtype && potion.subtype.includes('fixed') ? '' : '%'})`;
                select.appendChild(option);
            });
            
            // æ¢å¾©é¸æ“‡
            if (currentValue && uniquePotions.some(p => p.id == currentValue)) {
                select.value = currentValue;
            }
        }
        
        // å¾é¸æ“‡å™¨ä½¿ç”¨è—¥æ°´
        function usePotionFromSelector() {
            const select = document.getElementById('potion-selector');
            const itemId = select.value;
            
            if (!itemId) return;
            
            // æ‰¾åˆ°è—¥æ°´
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item) {
                addLog('ç³»çµ±', 'è—¥æ°´ä¸å­˜åœ¨ï¼');
                select.value = '';
                updatePotionSelector();
                return;
            }
            
            // ä½¿ç”¨è—¥æ°´
            if (item.subtype === 'hp' || item.subtype === 'hp_percent' || item.subtype === 'hp_potion') {
                const healAmount = Math.floor(gameState.player.maxHp * item.recovery);
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
            } else if (item.subtype === 'hp_fixed') {
                const healAmount = item.recovery;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
            } else if (item.subtype === 'both_percent') {
                const healAmount = Math.floor(gameState.player.maxHp * item.hpPercent);
                const restoreAmount = item.apRecovery;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + restoreAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} HP å’Œ ${restoreAmount} APï¼`);
            } else if (item.subtype === 'both_fixed') {
                const healAmount = item.hpRecovery;
                const restoreAmount = item.apRecovery;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + restoreAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} HP å’Œ ${restoreAmount} APï¼`);
            }
            
            // æ¸›å°‘æ•¸é‡æˆ–ç§»é™¤
            if (item.quantity && item.quantity > 1) {
                item.quantity--;
            } else {
                gameState.inventory = gameState.inventory.filter(i => i.id != itemId);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šåˆ†è§£è£å‚™
            updateQuestProgress('salvage_equipment', 1);
            }
            
            // é‡ç½®é¸æ“‡å™¨
            select.value = '';
            
            // æ›´æ–°UI
            updateUI();
            saveGame();
        }
        
        function tryAutoPotion() {
            if (!gameState.autoPotion) return false;
            
            // é˜²æ­¢NaNï¼šæª¢æŸ¥maxHpæ˜¯å¦æœ‰æ•ˆ
            if (!gameState.player.maxHp || gameState.player.maxHp <= 0) {
                console.error('è‡ªå‹•å–è—¥éŒ¯èª¤ï¼šmaxHpç„¡æ•ˆ', gameState.player.maxHp);
                return false;
            }
            
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦å–è—¥
            if (hpPercent >= (gameState.autoPotionThreshold || 50)) return false;
            
            // æª¢æŸ¥æ˜¯å¦æœ‰é¸æ“‡è—¥æ°´
            if (!gameState.selectedPotionId) {
                addLog('ç³»çµ±', 'æœªé¸æ“‡è—¥æ°´ï¼è«‹å…ˆé¸æ“‡è¦ä½¿ç”¨çš„è—¥æ°´ã€‚');
                gameState.autoPotion = false;
                document.getElementById('auto-potion-toggle').checked = false;
                return false;
            }
            
            // æ‰¾åˆ°é¸å®šçš„è—¥æ°´
            let potion = gameState.inventory.find(item => 
                item.id == gameState.selectedPotionId &&
                item.type === 'consumable' && 
                (item.subtype === 'hp' || item.subtype === 'hp_percent' || item.subtype === 'hp_fixed' || 
                 item.subtype === 'hp_potion' || item.subtype === 'both_percent' || item.subtype === 'both_fixed') &&
                (item.quantity || 1) > 0
            );
            
            if (!potion) {
                addLog('ç³»çµ±', 'é¸å®šçš„è—¥æ°´å·²ç”¨å®Œï¼è«‹é‡æ–°é¸æ“‡ã€‚');
                gameState.selectedPotionId = null;
                gameState.autoPotion = false;
                document.getElementById('auto-potion-toggle').checked = false;
                updatePotionSelector();
                return false;
            }
            // potion å·²ç¶“åœ¨ä¸Šé¢æ‰¾åˆ°äº†
            
            // è¨ˆç®—å›å¾©é‡
            let healAmount = 0;
            if (potion.subtype === 'hp_percent' || potion.subtype === 'hp' || potion.subtype === 'hp_potion') {
                // æ”¯æ´ recovery å’Œ hpPercent å…©ç¨®å±¬æ€§
                const recovery = (potion.recovery !== undefined && !isNaN(potion.recovery)) ? potion.recovery : 
                                 (potion.hpPercent !== undefined && !isNaN(potion.hpPercent)) ? potion.hpPercent : 0;
                healAmount = Math.floor(gameState.player.maxHp * recovery);
            } else if (potion.subtype === 'hp_fixed') {
                healAmount = potion.recovery || 0;
            } else if (potion.subtype === 'both_percent') {
                // çµ„åˆè—¥æ°´ï¼ˆç™¾åˆ†æ¯”HPï¼‰
                const hpPercent = (potion.hpPercent !== undefined && !isNaN(potion.hpPercent)) ? potion.hpPercent : 0;
                healAmount = Math.floor(gameState.player.maxHp * hpPercent);
                // åŒæ™‚å›å¾©AP
                if (potion.apRecovery) {
                    gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + potion.apRecovery);
                }
            } else if (potion.subtype === 'both_fixed') {
                // çµ„åˆè—¥æ°´ï¼ˆå›ºå®šHPï¼‰
                healAmount = potion.hpRecovery || 0;
                // åŒæ™‚å›å¾©AP
                if (potion.apRecovery) {
                    gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + potion.apRecovery);
                }
            }
            
            // é˜²æ­¢NaNï¼šæª¢æŸ¥healAmountæ˜¯å¦æœ‰æ•ˆ
            if (isNaN(healAmount) || healAmount <= 0) {
                console.error('è‡ªå‹•å–è—¥éŒ¯èª¤ï¼šhealAmountç„¡æ•ˆ', healAmount, potion);
                return false;
            }
            
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
            
            // æ¸›å°‘æ•¸é‡
            if (potion.quantity && potion.quantity > 1) {
                potion.quantity--;
            } else {
                gameState.inventory = gameState.inventory.filter(i => i.id !== potion.id);
                // è—¥æ°´ç”¨å®Œäº†ï¼Œæ¸…é™¤é¸æ“‡
                gameState.selectedPotionId = null;
                updatePotionSelector();
            }
            
            addLog('è‡ªå‹•å–è—¥', `[è‡ªå‹•] ä½¿ç”¨äº† ${potion.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
            
            return true;
        }

        function startGame() {
            document.getElementById('character-creation').style.display = 'none';
            document.getElementById('skill-selection').style.display = 'none';
            document.getElementById('game-main').style.display = 'block';
            
            // åˆå§‹åŒ–æ™‚é–“æˆ³
            const now = Date.now();
            if (!gameState.apRegenTime) gameState.apRegenTime = now;
            if (!gameState.hpRegenTime) gameState.hpRegenTime = now;
            
            calculateSetEffects(); // åˆå§‹åŒ–å¥—è£æ•ˆæœ
            
            // åˆå§‹åŒ–è‡ªå‹•å–è—¥UIç‹€æ…‹
            if (document.getElementById('auto-potion-toggle')) {
                document.getElementById('auto-potion-toggle').checked = gameState.autoPotion || false;
            }
            if (document.getElementById('auto-potion-threshold')) {
                document.getElementById('auto-potion-threshold').value = gameState.autoPotionThreshold || 50;
            }
            
            // åˆå§‹åŒ–éš¨å¾ç³»çµ±ï¼ˆä¸å†è´ˆé€åˆå§‹éš¨å¾ï¼Œç”±å‡ºç”Ÿç¦®åŒ…æä¾›ï¼‰
            initCompanionSystem();
            
            // åˆå§‹åŒ–åœ–é‘‘ç³»çµ±
            initCodexSystem();
            
            // æª¢æŸ¥æ¯æ—¥ä»»å‹™é‡ç½®
            // checkDailyReset(); // å·²ç§»é™¤ï¼Œå‰¯æœ¬ç³»çµ±æœ‰è‡ªå·±çš„é‡ç½®é‚è¼¯
            
            updateUI();
            addLog('ç³»çµ±', `æ­¡è¿ ${gameState.player.name}ï¼ˆ${gameState.player.class}ï¼‰ï¼é–‹å§‹ä½ çš„é™¤éŒ¯ä¹‹æ—…å§ï¼`);
        }

        // ========== æˆ°é¬¥ç³»çµ± ==========
        // ========== è‡ªå‹•æˆ°é¬¥ç³»çµ± ==========
        function toggleAutoExplore() {
            if (gameState.autoExplore) {
                // åœæ­¢è‡ªå‹•æˆ°é¬¥
                stopAutoExplore();
            } else {
                // é–‹å§‹è‡ªå‹•æˆ°é¬¥
                startAutoExplore();
            }
        }

        function startAutoExplore() {
            if (gameState.player.ap < 1) {
                addLog('ç³»çµ±', 'é«”åŠ›ä¸è¶³ï¼ç„¡æ³•é–‹å§‹è‡ªå‹•æˆ°é¬¥ã€‚');
                return;
            }
            
            gameState.autoExplore = true;
            document.getElementById('auto-explore-btn').textContent = 'â¸ï¸ åœæ­¢è‡ªå‹•';
            document.getElementById('auto-explore-btn').style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)';
            

            addLog('ç³»çµ±', 'âš¡ è‡ªå‹•æˆ°é¬¥å·²é–‹å•Ÿï¼');
            
            // ç«‹å³åŸ·è¡Œä¸€æ¬¡
            autoExploreLoop();
        }

        function stopAutoExplore() {
            gameState.autoExplore = false;
            if (gameState.autoExploreInterval) {
                clearTimeout(gameState.autoExploreInterval);
                gameState.autoExploreInterval = null;
            }
            document.getElementById('auto-explore-btn').textContent = 'â–¶ï¸ è‡ªå‹•æˆ°é¬¥';
            document.getElementById('auto-explore-btn').style.background = '';
            

            addLog('ç³»çµ±', 'â¸ï¸ è‡ªå‹•æˆ°é¬¥å·²åœæ­¢ã€‚');
        }

        function autoExploreLoop() {
            if (!gameState.autoExplore) return;
            
            // å¦‚æœæˆ°é¬¥é‚„åœ¨é€²è¡Œä¸­ï¼Œç­‰å¾…500mså¾Œå†æª¢æŸ¥
            if (isBattleInProgress) {
                gameState.autoExploreInterval = setTimeout(() => {
                    autoExploreLoop();
                }, 500);
                return;
            }
            
            // æª¢æŸ¥æ­»äº¡
            if (gameState.player.hp <= 0) {
                stopAutoExplore();
                addLog('ç³»çµ±', 'âŒ è§’è‰²æ­»äº¡ï¼Œè‡ªå‹•æˆ°é¬¥å·²åœæ­¢ã€‚');
                return;
            }
            
            // æª¢æŸ¥é«”åŠ›
            if (gameState.player.ap < 1) {
                stopAutoExplore();
                addLog('ç³»çµ±', 'âš¡ é«”åŠ›è€—ç›¡ï¼Œè‡ªå‹•æˆ°é¬¥å·²åœæ­¢ã€‚');
                return;
            }
            
            // åŸ·è¡Œæˆ°é¬¥
            startExplore();
            
            // è¨­ç½®ä¸‹æ¬¡åŸ·è¡Œï¼ˆç­‰å¾…1ç§’å¾Œå†æª¢æŸ¥æˆ°é¬¥æ˜¯å¦çµæŸï¼‰
            gameState.autoExploreInterval = setTimeout(() => {
                autoExploreLoop();
            }, 1000);
        }
        // è™•ç†æ€ªç‰©è©ç¶´æ•ˆæœï¼ˆæ”»æ“Šæ™‚ï¼‰
        function applyMonsterAffixOnAttack(enemy, damage) {
            if (!enemy.affixEffects) return { damage: damage, doubleAttack: false, lifeSteal: 0 };
            
            let finalDamage = damage;
            let doubleAttack = false;
            let lifeStealAmount = 0;
            
            // ä½è¡€ç‹‚æš´ï¼šç”Ÿå‘½ä½æ–¼50%æ™‚æ”»æ“ŠåŠ›+50%
            if (enemy.affixEffects.lowHpAtkBonus && enemy.hp < enemy.maxHp * (enemy.affixEffects.lowHpThreshold || 0.5)) {
                finalDamage = Math.floor(finalDamage * (1 + enemy.affixEffects.lowHpAtkBonus));
            }
            
            // å‚·å®³æ³¢å‹•ï¼šå‚·å®³éš¨æ©Ÿæ³¢å‹•
            if (enemy.affixEffects.damageVariance) {
                const variance = enemy.affixEffects.damageVariance;
                const multiplier = 1 + (Math.random() * 2 - 1) * variance;
                finalDamage = Math.floor(finalDamage * multiplier);
            }
            
            // ç–ŠåŠ æ”»æ“Šï¼šæ¯æ¬¡æ”»æ“Šå¢åŠ æ”»æ“ŠåŠ›
            if (enemy.affixEffects.stackingAtk && enemy.affixEffects.currentStacks < enemy.affixEffects.maxStacks) {
                enemy.affixEffects.currentStacks++;
                const stackBonus = enemy.affixEffects.stackingAtk * enemy.affixEffects.currentStacks;
                finalDamage = Math.floor(finalDamage * (1 + stackBonus));
            }
            
            // å˜—è¡€è©ç¶´ï¼šæ”¿æ“Šæ™‚å›å¾©ç”Ÿå‘½
            if (enemy.affixEffects.lifeSteal) {
                lifeStealAmount = Math.floor(finalDamage * enemy.affixEffects.lifeSteal);
            }
            
            // é€£æ“Šè©ç¶´ï¼šæ©Ÿç‡é€£çºŒæ”»æ“Šå…©æ¬¡
            if (enemy.affixEffects.doubleAttackChance && Math.random() < enemy.affixEffects.doubleAttackChance) {
                doubleAttack = true;
            }
            
            return { damage: finalDamage, doubleAttack: doubleAttack, lifeSteal: lifeStealAmount };
        }
        
        // è™•ç†æ€ªç‰©è©ç¶´æ•ˆæœï¼ˆå—æ“Šæ™‚ï¼‰
        function applyMonsterAffixOnHit(enemy, damage) {
            if (!enemy.affixEffects) return { damage: damage, reflect: 0, dodged: false };
            
            let finalDamage = damage;
            let reflectDamage = 0;
            let dodged = false;
            
            // é–ƒé¿æª¢æŸ¥
            if (enemy.affixEffects.dodgeChance && Math.random() < enemy.affixEffects.dodgeChance) {
                dodged = true;
                return { damage: 0, reflect: 0, dodged: true };
            }
            
            // æ¸›å‚·
            if (enemy.affixEffects.damageReduction) {
                finalDamage = Math.floor(finalDamage * (1 - enemy.affixEffects.damageReduction));
            }
            
            // ä½è¡€é˜²ç¦¦å€å¢ï¼šç”Ÿå‘½ä½æ–¼30%æ™‚é˜²ç¦¦åŠ›å€å¢
            if (enemy.affixEffects.lowHpDefMultiplier && enemy.hp < enemy.maxHp * (enemy.affixEffects.lowHpDefThreshold || 0.3)) {
                // é‡æ–°è¨ˆç®—å‚·å®³ï¼Œä½¿ç”¨å€å¢å¾Œçš„é˜²ç¦¦åŠ›
                const boostedDef = Math.floor(enemy.def * enemy.affixEffects.lowHpDefMultiplier);
                const playerAtk = gameState.player.atk;
                const armorPen = gameState.player.armorPen || 0;
                const effectiveDef = Math.floor(boostedDef * (1 - armorPen / 100));
                finalDamage = Math.max(1, playerAtk - effectiveDef);
            }
            
            // èˆŠçš„ä½è¡€æ¸›å‚·é€»è¼¯ï¼ˆå·²ç§»é™¤ï¼Œä¿ç•™ç›¸å®¹æ€§ï¼‰
            if (enemy.affixEffects.lowHpDefBonus && enemy.hp < enemy.maxHp * (enemy.affixEffects.lowHpDefThreshold || 0.3)) {
                const reduction = Math.min(enemy.affixEffects.lowHpDefBonus, 0.5); // ä¸Šé™ 50%
                finalDamage = Math.floor(finalDamage * (1 - reduction));
            }
            
            // åå½ˆå‚·å®³
            if (enemy.affixEffects.reflect) {
                reflectDamage = Math.floor(damage * enemy.affixEffects.reflect);
            }
            
            return { damage: finalDamage, reflect: reflectDamage, dodged: dodged };
        }
        
        // è™•ç†æ€ªç‰©å›åˆé–‹å§‹æ•ˆæœ
        function applyMonsterAffixOnTurn(enemy) {
            if (!enemy.affixEffects) return 0;
            
            let healAmount = 0;
            
            // ç”Ÿå‘½å›å¾©
            if (enemy.affixEffects.regen) {
                healAmount = Math.floor(enemy.maxHp * enemy.affixEffects.regen);
                enemy.hp = Math.min(enemy.hp + healAmount, enemy.maxHp);
            }
            
            return healAmount;
        }
        
        // è™•ç†è£å‚™è©ç¶´æ•ˆæœ
        function applyEquipmentAffixEffects(damage, isCrit, enemy) {
            let finalDamage = damage;
            const player = gameState.player;
            const equipment = player.equipment;
            
            // æª¢æŸ¥æ‰€æœ‰è£å‚™çš„è©ç¶´
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item || !item.affixes) continue;
                
                for (const affix of item.affixes) {
                    // ç†¾ç†±çš„ï¼š15%æ©Ÿç‡é€ æˆé¡å¤–50%å‚·å®³
                    if (affix === 'blazing' && Math.random() < 0.15) {
                        const extraDmg = Math.floor(damage * 0.5);
                        finalDamage += extraDmg;
                        addLog('è©ç¶´', `ğŸ”¥ ç†¾ç†±æ•ˆæœè§¸ç™¼ï¼é€ æˆé¡å¤– ${extraDmg} é»å‚·å®³`);
                    }
                    
                    // é–ƒé›»çš„ï¼š20%æ©Ÿç‡é€£é–å‚·å®³ï¼ˆ30%Ã—2æ¬¡ï¼‰
                    if (affix === 'lightning' && Math.random() < 0.20) {
                        const chainDmg1 = Math.floor(damage * 0.3);
                        const chainDmg2 = Math.floor(damage * 0.3);
                        finalDamage += chainDmg1 + chainDmg2;
                        addLog('è©ç¶´', `âš¡ é–ƒé›»é€£é–ï¼é€ æˆé¡å¤– ${chainDmg1 + chainDmg2} é»å‚·å®³`);
                    }
                    
                    // è‡´å‘½çš„ï¼šå°ä½è¡€æ•µäºº+30%å‚·å®³
                    if (affix === 'deadly' && enemy.hp < enemy.maxHp * 0.3) {
                        const extraDmg = Math.floor(damage * 0.3);
                        finalDamage += extraDmg;
                        addLog('è©ç¶´', `ğŸ’€ è‡´å‘½æ•ˆæœï¼å°ä½è¡€æ•µäººé¡å¤– ${extraDmg} é»å‚·å®³`);
                    }
                    
                    // ç²¾æº–çš„ï¼šæš´æ“Šæ™‚é¡å¤–+20%å‚·å®³
                    if (affix === 'precise' && isCrit) {
                        const extraDmg = Math.floor(damage * 0.2);
                        finalDamage += extraDmg;
                        addLog('è©ç¶´', `ğŸ¯ ç²¾æº–æš´æ“Šï¼é¡å¤– ${extraDmg} é»å‚·å®³`);
                    }
                }
            }
            
            return finalDamage - damage; // è¿”å›é¡å¤–å‚·å®³
        }
        
        // è™•ç†ç©å®¶æ”»æ“Šå‹ç‰¹æ®Šæ•ˆæœï¼ˆå®Œæ•´ç‰ˆï¼‰
        function applyPlayerSpecialEffects(damage, isCrit, enemy) {
            let extraDamage = 0;
            let message = '';
            const player = gameState.player;
            const equipment = player.equipment;
            
            // é€£æ“Šæ•ˆæœæª¢æŸ¥
            if (player.comboReady) {
                extraDamage += damage; // é›™å€å‚·å®³ = é¡å¤–100%
                message += `âš¡ é€£æ“Šçˆ†ç™¼ï¼é€ æˆé›™å€å‚·å®³ï¼ `;
                player.comboReady = false;
                player.comboKills = 0;
            }
            
            // æª¢æŸ¥æ‰€æœ‰è£å‚™çš„ç‰¹æ®Šæ•ˆæœ
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item) continue;
                
                // æª¢æŸ¥ equipmentAffix ä¸­çš„å‰ç¶´æ•ˆæœ
                if (item.equipmentAffix && item.equipmentAffix.prefix && item.equipmentAffix.prefix.effect) {
                    const effect = item.equipmentAffix.prefix.effect;
                    
                    // 1. onHit é¡å‹ï¼šæ”»æ“Šæ™‚æœ‰æ©Ÿç‡è§¸ç™¼
                    if (effect.type === 'onHit' && effect.chance) {
                        if (Math.random() < effect.chance) {
                            if (effect.damageMultiplier) {
                                const bonusDmg = Math.floor(damage * effect.damageMultiplier);
                                extraDamage += bonusDmg;
                                const elementText = effect.element ? `ï¼ˆ${effect.element}ï¼‰` : '';
                                message += `âœ¨ ${item.equipmentAffix.prefix.name}æ•ˆæœè§¸ç™¼${elementText}ï¼é¡å¤– ${bonusDmg} å‚·å®³ `;
                            }
                            
                            // é–ƒé›»é€£é–æ•ˆæœ
                            if (effect.chainCount && effect.chainDamage) {
                                for (let i = 0; i < effect.chainCount; i++) {
                                    const chainDmg = Math.floor(damage * effect.chainDamage);
                                    extraDamage += chainDmg;
                                }
                                message += `âš¡ é€£é–${effect.chainCount}æ¬¡ï¼`;
                            }
                            
                            // å†°éœœæ¸›é€Ÿæ•ˆæœ
                            if (effect.slowAmount) {
                                if (!enemy.debuffs) enemy.debuffs = {};
                                enemy.debuffs.slow = effect.slowAmount;
                                enemy.atk = Math.floor(enemy.atk * (1 - effect.slowAmount));
                                message += `â„ï¸ æ•µäººè¢«æ¸›é€Ÿï¼`;
                            }
                        }
                    }
                    
                    // 2. onCrit é¡å‹ï¼šæš´æ“Šæ™‚é¡å¤–å‚·å®³
                    if (effect.type === 'onCrit' && isCrit && effect.damageBonus) {
                        const bonusDmg = Math.floor(damage * effect.damageBonus);
                        extraDamage += bonusDmg;
                        message += `ğŸ¯ ç²¾æº–æš´æ“Šï¼é¡å¤– ${bonusDmg} å‚·å®³ `;
                    }
                    
                    // 3. onLowHpEnemy é¡å‹ï¼šå°ä½è¡€æ•µäººé¡å¤–å‚·å®³
                    if (effect.type === 'onLowHpEnemy' && effect.threshold && effect.damageBonus) {
                        const enemyHpPercent = enemy.hp / enemy.maxHp;
                        if (enemyHpPercent < effect.threshold) {
                            const bonusDmg = Math.floor(damage * effect.damageBonus);
                            extraDamage += bonusDmg;
                            message += `ğŸ’€ è‡´å‘½ä¸€æ“Šï¼é¡å¤– ${bonusDmg} å‚·å®³ `;
                        }
                    }
                    
                    // 4. onLowHp é¡å‹ï¼šç”Ÿå‘½ä½æ–¼é–€æª»æ™‚æ”»æ“Šæå‡
                    if (effect.type === 'onLowHp' && effect.threshold && effect.atkBonus) {
                        const hpPercent = player.hp / player.maxHp;
                        if (hpPercent < effect.threshold) {
                            const bonusDmg = Math.floor(damage * effect.atkBonus);
                            extraDamage += bonusDmg;
                        }
                    }
                }
                
                // æª¢æŸ¥ç‰¹æ®Šè©ç¶´ï¼ˆé£¾å“ï¼‰çš„è¢«å‹•æ•ˆæœ
                if (item.equipmentAffix && item.equipmentAffix.type === 'special' && item.equipmentAffix.data) {
                    const effect = item.equipmentAffix.data.effect;
                    
                    // çµæ®ºï¼šå°Bossé¡å¤–å‚·å®³
                    if (effect && effect.type === 'passive' && effect.bossDamageBonus) {
                        if (enemy.isBoss || enemy.isSpecialBoss) {
                            const bonusDmg = Math.floor(damage * effect.bossDamageBonus);
                            extraDamage += bonusDmg;
                        }
                    }
                }
            }
            
            return { extraDamage, message };
        }
        
        // è™•ç†ç©å®¶é˜²ç¦¦å‹ç‰¹æ®Šæ•ˆæœï¼ˆå®Œæ•´ç‰ˆï¼‰
        function applyPlayerDefenseSpecialEffects(incomingDamage, enemy) {
            let damageReduction = 0;
            let reflectDamage = 0;
            let message = '';
            const player = gameState.player;
            const equipment = player.equipment;
            
            // æª¢æŸ¥æ‰€æœ‰è£å‚™çš„ç‰¹æ®Šæ•ˆæœ
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item) continue;
                
                // æª¢æŸ¥ equipmentAffix ä¸­çš„å¾Œç¶´æ•ˆæœ
                if (item.equipmentAffix && item.equipmentAffix.suffix && item.equipmentAffix.suffix.effect) {
                    const effect = item.equipmentAffix.suffix.effect;
                    
                    // 1. onLethal é¡å‹ï¼šè‡´å‘½å‚·å®³ä¿è­·
                    if (effect.type === 'onLethal' && effect.chance) {
                        if (player.hp - incomingDamage <= 0) {
                            const now = Date.now();
                            const cooldownKey = `lethal_${slot}`;
                            if (!player.cooldowns) player.cooldowns = {};
                            
                            if (!player.cooldowns[cooldownKey] || now - player.cooldowns[cooldownKey] > effect.cooldown) {
                                if (Math.random() < effect.chance) {
                                    damageReduction = incomingDamage - 1;
                                    player.cooldowns[cooldownKey] = now;
                                    message += `ğŸ›¡ï¸ å®ˆè­·æ•ˆæœè§¸ç™¼ï¼å…ç–«è‡´å‘½å‚·å®³ï¼ `;
                                }
                            }
                        }
                    }
                    
                    // 2. onHit é¡å‹ï¼šå—æ“Šæ™‚è§¸ç™¼
                    if (effect.type === 'onHit') {
                        // åå°„å‚·å®³
                        if (effect.reflectPercent) {
                            const reflect = Math.floor(incomingDamage * effect.reflectPercent);
                            reflectDamage += reflect;
                            message += `âš”ï¸ åå°„ ${reflect} é»å‚·å®³ï¼ `;
                        }
                        
                        // å†°ç”²æ¸›å‚·
                        if (effect.chance && effect.damageReduction) {
                            if (Math.random() < effect.chance) {
                                const reduction = Math.floor(incomingDamage * effect.damageReduction);
                                damageReduction += reduction;
                                message += `â„ï¸ å†°ç”²è§¸ç™¼ï¼æ¸›å°‘ ${reduction} é»å‚·å®³ï¼ `;
                            }
                        }
                    }
                    
                    // 3. onLowHp é¡å‹ï¼šä½è¡€æ™‚æå‡é˜²ç¦¦
                    if (effect.type === 'onLowHp' && effect.threshold && effect.defBonus) {
                        const hpPercent = player.hp / player.maxHp;
                        if (hpPercent < effect.threshold) {
                            const reduction = Math.floor(incomingDamage * effect.defBonus * 0.15);
                            damageReduction += reduction;
                        }
                    }
                    
                    // 4. passive é¡å‹ï¼šè¢«å‹•æ¸›å‚·
                    if (effect.type === 'passive' && effect.damageReduction) {
                        const reduction = Math.floor(incomingDamage * effect.damageReduction);
                        damageReduction += reduction;
                    }
                }
            }
            
            return { damageReduction, reflectDamage, message };
        }
        
        // è™•ç†æ“Šæ®ºæ™‚çš„ç‰¹æ®Šæ•ˆæœï¼ˆå®Œæ•´ç‰ˆï¼‰
        function applyKillSpecialEffects() {
            const player = gameState.player;
            const equipment = player.equipment;
            
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item) continue;
                
                // æª¢æŸ¥å‰ç¶´æ•ˆæœ
                if (item.equipmentAffix && item.equipmentAffix.prefix && item.equipmentAffix.prefix.effect) {
                    const effect = item.equipmentAffix.prefix.effect;
                    
                    // å—œè¡€æ•ˆæœ
                    if (effect.type === 'onKill' && effect.healPercent) {
                        const healAmount = Math.floor(player.maxHp * effect.healPercent);
                        player.hp = Math.min(player.hp + healAmount, player.maxHp);
                        addLog('è©ç¶´', `ğŸ©¸ å—œè¡€æ•ˆæœï¼å›å¾© ${healAmount} é»ç”Ÿå‘½å€¼`);
                    }
                }
                
                // æª¢æŸ¥ç‰¹æ®Šè©ç¶´ï¼ˆé£¾å“ï¼‰
                if (item.equipmentAffix && item.equipmentAffix.type === 'special' && item.equipmentAffix.data) {
                    const effect = item.equipmentAffix.data.effect;
                    
                    // é€£æ“Šæ•ˆæœ
                    if (effect && effect.type === 'onCombo' && effect.comboCount) {
                        if (!player.comboKills) player.comboKills = 0;
                        player.comboKills++;
                        
                        if (player.comboKills >= effect.comboCount) {
                            player.comboReady = true;
                            addLog('é€£æ“Š', `âš¡ é€£æ“Šå°±ç·’ï¼ä¸‹æ¬¡æ”»æ“Šé€ æˆé›™å€å‚·å®³ï¼`);
                        }
                    }
                    
                    // æ˜Ÿè¾°æ•ˆæœ
                    if (effect && effect.type === 'onKill' && effect.stackCount && effect.statBonus) {
                        if (!player.stellarStacks) player.stellarStacks = 0;
                        if (!player.stellarKills) player.stellarKills = 0;
                        
                        player.stellarKills++;
                        
                        if (player.stellarKills >= effect.stackCount && player.stellarStacks < 10) {
                            player.stellarStacks++;
                            player.stellarKills = 0;
                            player.atk += effect.statBonus;
                            player.def += effect.statBonus;
                            addLog('æ˜Ÿè¾°', `â­ æ˜Ÿè¾°æ•ˆæœï¼å…¨å±¬æ€§+${effect.statBonus}ï¼ˆ${player.stellarStacks}/10å±¤ï¼‰`);
                        }
                    }
                }
            }
        }


        // è¨ˆç®—è¢«å‹•åŠ æˆï¼ˆé‡‘å¹£ã€ç¶“é©—ã€æ‰è½ç­‰ï¼‰
        function getPassiveBonuses() {
            const player = gameState.player;
            const equipment = player.equipment;
            
            const bonuses = {
                goldBonus: 0,
                expBonus: 0,
                dropBonus: 0,
                potionBonus: 0
            };
            
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item) continue;
                
                // æª¢æŸ¥ç‰¹æ®Šè©ç¶´ï¼ˆé£¾å“ï¼‰
                if (item.equipmentAffix && item.equipmentAffix.type === 'special' && item.equipmentAffix.data) {
                    const effect = item.equipmentAffix.data.effect;
                    
                    if (effect && effect.type === 'passive') {
                        if (effect.goldBonus) bonuses.goldBonus += effect.goldBonus;
                        if (effect.expBonus) bonuses.expBonus += effect.expBonus;
                        if (effect.dropBonus) bonuses.dropBonus += effect.dropBonus;
                        if (effect.potionBonus) bonuses.potionBonus += effect.potionBonus;
                    }
                }
            }
            
            return bonuses;
        }

        function startExplore() {

            if (gameState.player.ap < 1) {
                addLog('ç³»çµ±', 'é«”åŠ›ä¸è¶³ï¼è«‹ç­‰å¾…é«”åŠ›å›å¾©ã€‚');
                // é«”åŠ›ä¸è¶³ï¼Œé‡æ–°å•Ÿç”¨æŒ‰éˆ•
                if (exploreBtn) exploreBtn.disabled = false;
                return;
            }
            
            gameState.player.ap--;
            // é‡ç½®é«”åŠ›å›å¾©è¨ˆæ™‚å™¨
            if (gameState.player.ap < gameState.player.maxAp) {
                gameState.apRegenTime = Date.now();
            }
            
            // æ¶ˆè€—é«”åŠ›å¾Œç«‹å³å­˜æª”
            saveGame();
            
            // ç”Ÿæˆæ•µäºº
            const region = REGIONS[gameState.region];
            const isBoss = gameState.battleProgress >= 9;
            const enemy = generateEnemy(region, isBoss);
            
            // é¡¯ç¤ºæ€ªç‰©è©ç¶´
            let enemyDisplayName = `${enemy.icon} ${enemy.name}`;
            
            // ğŸ¯ ç²¾è‹±æ€ªç‰©æ¨™è¨˜
            if (enemy.isElite) {
                enemyDisplayName = `â­ç²¾è‹±â­ ${enemyDisplayName}`;
            }
            
            if (enemy.affixes && enemy.affixes.length > 0) {
                const affixDesc = enemy.affixes.map(a => `${a.icon}${a.name}`).join(' ');
                enemyDisplayName += ` [${affixDesc}]`;
            }
            addLog('é‡åˆ°', `é‡åˆ°äº† ${enemyDisplayName}ï¼`, enemy.isSpecialBoss);
            
            // åµæŸ¥å·è»¸æ•ˆæœï¼šé¡¯ç¤ºæ•µäººè©³ç´°è³‡è¨Š
            if (gameState.scoutInfo && gameState.scoutInfo.remaining > 0) {
                const dropRate = Math.floor((enemy.dropRate || 0.3) * 100);
                addLog('åµæŸ¥', `ğŸ” æ•µäººè³‡è¨Šï¼šHP ${enemy.hp} | ATK ${enemy.atk} | DEF ${enemy.def} | æ‰è½ç‡ ${dropRate}%`);
                gameState.scoutInfo.remaining--;
                if (gameState.scoutInfo.remaining === 0) {
                    delete gameState.scoutInfo;
                    addLog('åµæŸ¥', 'åµæŸ¥å·è»¸æ•ˆæœå·²ç”¨ç›¡ã€‚');
                }
            }
            playSound('encounter'); // é­é‡éŸ³æ•ˆ
            
            // æˆ°é¬¥
            setTimeout(() => battle(enemy), 500);
        }

        // ========== æ€ªç‰©è©ç¶´ç³»çµ± ==========
        // ğŸ”´ å‰ç¶´ - æ”»æ“Šå‹
        const PREFIX_AFFIXES = [
            // æ”»æ“Šå‹è©ç¶´
            {
                id: 'furious',
                name: 'ç‹‚æš´',
                icon: 'ğŸ”¥',
                color: '#ffd700',
                type: 'offensive',
                effect: { atkMultiplier: 1.3 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'æ”»æ“ŠåŠ›+30%'
            },
            {
                id: 'swift',
                name: 'é€£æ“Š',
                icon: 'âš¡',
                color: '#ffd700',
                type: 'offensive',
                effect: { doubleAttackChance: 0.3 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: '30%æ©Ÿç‡é€£çºŒæ”»æ“Šå…©æ¬¡'
            },
            {
                id: 'deadly',
                name: 'è‡´å‘½',
                icon: 'ğŸ’€',
                color: '#ffd700',
                type: 'offensive',
                effect: { critRate: 0.2, critDamage: 0.5 },
                reward: { goldMultiplier: 1.25, expMultiplier: 1.25 },
                description: 'æš´æ“Šç‡+20%, æš´æ“Šå‚·å®³+50%'
            },
            {
                id: 'vampiric',
                name: 'å—œè¡€',
                icon: 'ğŸ©¸',
                color: '#ffd700',
                type: 'offensive',
                effect: { lifeSteal: 0.2 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'æ”»æ“Šæ™‚å›å¾©20%å‚·å®³'
            },
            {
                id: 'enraged',
                name: 'ç‹‚æ€’',
                icon: 'âš”ï¸',
                color: '#ffd700',
                type: 'offensive',
                effect: { lowHpAtkBonus: 0.5, lowHpThreshold: 0.5 },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'ç”Ÿå‘½ä½æ–¼50%æ™‚æ”»æ“ŠåŠ›+50%'
            },
            {
                id: 'accurate',
                name: 'ç²¾æº–',
                icon: 'ğŸ¯',
                color: '#ffd700',
                type: 'offensive',
                effect: { armorPen: 0.3 },
                reward: { goldMultiplier: 1.25, expMultiplier: 1.25 },
                description: 'ç„¡è¦–ç©å®¶30%é˜²ç¦¦'
            },
            
            // é˜²ç¦¦å‹è©ç¶´
            {
                id: 'resilient',
                name: 'å …éŸŒ',
                icon: 'ğŸ›¡ï¸',
                color: '#ffd700',
                type: 'defensive',
                effect: { defMultiplier: 1.4, hpMultiplier: 1.3 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'é˜²ç¦¦åŠ›+40%, ç”Ÿå‘½+30%'
            },
            {
                id: 'ironclad',
                name: 'é‹¼éµ',
                icon: 'ğŸ’',
                color: '#ffd700',
                type: 'defensive',
                effect: { damageReduction: 0.12 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'æ¸›å°‘æ‰€æœ‰å—åˆ°çš„å‚·å®³12%'
            },
            {
                id: 'thorny',
                name: 'å†°ç”²',
                icon: 'ğŸ§Š',
                color: '#ffd700',
                type: 'defensive',
                effect: { reflect: 0.15 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'å—åˆ°æ”»æ“Šæ™‚åå½ˆ15%å‚·å®³'
            },
            {
                id: 'regenerative',
                name: 'å†ç”Ÿ',
                icon: 'ğŸ’š',
                color: '#ffd700',
                type: 'defensive',
                effect: { regen: 0.05 },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'æ¯å›åˆå›å¾©5%æœ€å¤§ç”Ÿå‘½'
            },
            {
                id: 'evasive',
                name: 'é–ƒé¿',
                icon: 'âš¡',
                color: '#ffd700',
                type: 'defensive',
                effect: { dodgeChance: 0.3 },
                reward: { goldMultiplier: 1.35, expMultiplier: 1.35 },
                description: '30%æ©Ÿç‡é–ƒé¿æ”»æ“Š'
            },
            {
                id: 'tidal',
                name: 'æ½®æ±',
                icon: 'ğŸŒŠ',
                color: '#ffd700',
                type: 'defensive',
                effect: { lowHpDefMultiplier: 2.0, lowHpThreshold: 0.3 },
                reward: { goldMultiplier: 1.25, expMultiplier: 1.25 },
                description: 'ç”Ÿå‘½ä½æ–¼30%æ™‚é˜²ç¦¦åŠ›+100%'
            },
            
            // ç‰¹æ®Šå‹è©ç¶´
            {
                id: 'elite',
                name: 'ç²¾è‹±',
                icon: 'ğŸ‘‘',
                color: '#ff9800',
                type: 'special',
                effect: { allStatsMultiplier: 1.2 },
                reward: { goldMultiplier: 1.5, expMultiplier: 1.5, dropBonus: 0.3 },
                description: 'å…¨å±¬æ€§+20%'
            },
            {
                id: 'legendary',
                name: 'å‚³å¥‡',
                icon: 'ğŸŒŸ',
                color: '#ff4444',
                type: 'special',
                effect: { allStatsMultiplier: 1.4 },
                reward: { goldMultiplier: 2.0, expMultiplier: 2.0, dropBonus: 0.5 },
                description: 'å…¨å±¬æ€§+40%'
            },
            {
                id: 'magical',
                name: 'é­”æ³•',
                icon: 'ğŸ”®',
                color: '#ffd700',
                type: 'special',
                effect: { elementalAttack: true },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'æ”»æ“Šé™„å¸¶éš¨æ©Ÿå…ƒç´ æ•ˆæœ'
            },
            {
                id: 'astral',
                name: 'æ˜Ÿç•Œ',
                icon: 'ğŸ’«',
                color: '#ffd700',
                type: 'special',
                effect: { stackingAtk: 0.03, maxStacks: 8 },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'æ¯æ¬¡æ”»æ“Šç²å¾—3%æ”»æ“ŠåŠ›ï¼ˆæœ€å¤š8å±¤ï¼‰'
            },
            {
                id: 'chaotic',
                name: 'æ··æ²Œ',
                icon: 'ğŸ²',
                color: '#ffd700',
                type: 'special',
                effect: { damageVariance: 0.25 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'æ¯æ¬¡æ”»æ“Šå‚·å®³åœ¨75%-125%é–“æ³¢å‹•'
            },
            {
                id: 'immortal',
                name: 'ä¸æ»…',
                icon: 'â°',
                color: '#ff4444',
                type: 'special',
                effect: { revive: true, revivePercent: 0.5 },
                reward: { goldMultiplier: 1.8, expMultiplier: 1.8, dropBonus: 0.4 },
                description: 'ç¬¬ä¸€æ¬¡æ­»äº¡æ™‚å¾©æ´»ä¸¦å›å¾©50%ç”Ÿå‘½'
            }
        ];
        
        // ğŸ”µ å¾Œç¶´ - é˜²ç¦¦å‹
        const SUFFIX_AFFIXES = [
            {
                id: 'shielded',
                name: 'ä¹‹ç›¾',
                icon: 'ğŸ›¡ï¸',
                color: '#4dabf7',
                tier: 'basic',
                effect: { defMultiplier: 1.3 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'é˜²ç¦¦+30%'
            },
            {
                id: 'armored',
                name: 'ä¹‹éŒ˜',
                icon: 'ğŸ›¡ï¸',
                color: '#4dabf7',
                tier: 'basic',
                effect: { damageReduction: 0.2 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'æ¸›å‚·20%'
            },
            {
                id: 'fortified',
                name: 'ä¹‹å£',
                icon: 'ğŸ¯',
                color: '#4dabf7',
                tier: 'basic',
                effect: { hpMultiplier: 1.3 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'ç”Ÿå‘½+30%'
            },
            {
                id: 'shadowy',
                name: 'ä¹‹å½±',
                icon: 'ğŸŒ‘',
                color: '#4dabf7',
                tier: 'basic',
                effect: { dodgeChance: 0.3 },
                reward: { goldMultiplier: 1.25, expMultiplier: 1.25 },
                description: 'é–ƒé¿30%'
            },
            {
                id: 'thorny',
                name: 'ä¹‹åˆº',
                icon: 'ğŸŒ¹',
                color: '#4dabf7',
                tier: 'basic',
                effect: { reflect: 0.2 },
                reward: { goldMultiplier: 1.25, expMultiplier: 1.25 },
                description: 'åå‚·20%'
            },
            {
                id: 'regenerating',
                name: 'ä¹‹å¿ƒ',
                icon: 'â¤ï¸',
                color: '#ff6b6b',
                tier: 'advanced',
                effect: { regen: 0.05 },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'æ¯å›åˆå›å¾©5%ç”Ÿå‘½'
            },
            {
                id: 'titan',
                name: 'ä¹‹é«”',
                icon: 'ğŸ’ª',
                color: '#ff6b6b',
                tier: 'advanced',
                effect: { hpMultiplier: 1.5, defMultiplier: 1.2 },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'ç”Ÿå‘½+50%, é˜²ç¦¦+20%'
            },
            {
                id: 'ethereal',
                name: 'ä¹‹é­‚',
                icon: 'ğŸ‘»',
                color: '#ff6b6b',
                tier: 'advanced',
                effect: { damageReduction: 0.3, dodgeChance: 0.2 },
                reward: { goldMultiplier: 1.35, expMultiplier: 1.35 },
                description: 'æ¸›å‚·30%, é–ƒé¿20%'
            },
            {
                id: 'king',
                name: 'ä¹‹ç‹',
                icon: 'ğŸ‘‘',
                color: '#ffd700',
                tier: 'boss',
                effect: { allStatsMultiplier: 1.3 },
                reward: { goldMultiplier: 1.4, expMultiplier: 1.4 },
                description: 'å…¨å±¬æ€§+30%'
            },
            {
                id: 'god',
                name: 'ä¹‹ç¥',
                icon: 'âœ¨',
                color: '#ffd700',
                tier: 'boss',
                effect: { hpMultiplier: 1.8, defMultiplier: 1.4 },
                reward: { goldMultiplier: 1.5, expMultiplier: 1.5 },
                description: 'ç”Ÿå‘½+80%, é˜²ç¦¦+40%'
            },
            {
                id: 'tower',
                name: 'ä¹‹å¡”',
                icon: 'ğŸ—¼',
                color: '#ffd700',
                tier: 'boss',
                effect: { defMultiplier: 2.0, damageReduction: 0.3 },
                reward: { goldMultiplier: 1.45, expMultiplier: 1.45 },
                description: 'é˜²ç¦¦+100%, æ¸›å‚·30%'
            },
            {
                id: 'spirit',
                name: 'ä¹‹éˆ',
                icon: 'ğŸ”®',
                color: '#ffd700',
                tier: 'boss',
                effect: { hpMultiplier: 1.6, regen: 0.08 },
                reward: { goldMultiplier: 1.4, expMultiplier: 1.4 },
                description: 'ç”Ÿå‘½+60%, æ¯å›åˆå›å¾©8%'
            },
            {
                id: 'plated',
                name: 'ä¹‹éŒ˜ç”²',
                icon: 'ğŸ›¡ï¸',
                color: '#ffd700',
                tier: 'boss',
                effect: { damageReduction: 0.4, reflect: 0.3 },
                reward: { goldMultiplier: 1.4, expMultiplier: 1.4 },
                description: 'æ¸›å‚·40%, åå‚·30%'
            },
            {
                id: 'immortal_suffix',
                name: 'ä¸æ»…',
                icon: 'â°',
                color: '#ff4444',
                tier: 'special',
                effect: { revive: true, revivePercent: 0.5 },
                reward: { goldMultiplier: 1.8, expMultiplier: 1.8, dropBonus: 0.4 },
                description: 'ç¬¬ä¸€æ¬¡æ­»äº¡å¾©æ´»50%ç”Ÿå‘½'
            },
            {
                id: 'eternal',
                name: 'æ°¸æ†',
                icon: 'â™¾ï¸',
                color: '#ff4444',
                tier: 'special',
                effect: { hpMultiplier: 2.5, regen: 0.1 },
                reward: { goldMultiplier: 2.0, expMultiplier: 2.0, dropBonus: 0.5 },
                description: 'ç”Ÿå‘½+150%, æ¯å›åˆå›å¾©10%'
            }
        ];
        
        // ğŸŸ¡ ä¸­ç¶´ - ç‰¹æ®Šå‹ï¼ˆåƒ¥Bossï¼‰
        const INFIX_AFFIXES = [
            {
                id: 'elemental',
                name: 'å…ƒç´ ',
                icon: 'ğŸ”®',
                color: '#ffd700',
                tier: 'boss',
                effect: { elementalAttack: true },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'æ”»æ“Šé™„å¸¶éš¨æ©Ÿå…ƒç´ æ•ˆæœ'
            },
            {
                id: 'astral',
                name: 'æ˜Ÿç•Œ',
                icon: 'ğŸ’«',
                color: '#ffd700',
                tier: 'boss',
                effect: { stackingAtk: 0.03, maxStacks: 8 },
                reward: { goldMultiplier: 1.3, expMultiplier: 1.3 },
                description: 'æ¯æ¬¡æ”»æ“Šç²å¾—3%æ”»æ“Šï¼ˆç–Š8å±¤ï¼‰'
            },
            {
                id: 'chaotic',
                name: 'æ··æ²Œ',
                icon: 'ğŸ²',
                color: '#ffd700',
                tier: 'boss',
                effect: { damageVariance: 0.25 },
                reward: { goldMultiplier: 1.2, expMultiplier: 1.2 },
                description: 'æ¯æ¬¡æ”»æ“Šå‚·å®³åœ¨75%-125%é–“æ³¢å‹•'
            },
            {
                id: 'shadow',
                name: 'æš—å½±',
                icon: 'ğŸŒ‘',
                color: '#9b59b6',
                tier: 'boss',
                effect: { dodgeChance: 0.3, critRate: 0.2 },
                reward: { goldMultiplier: 1.35, expMultiplier: 1.35 },
                description: '30%é–ƒé¿+20%æš´æ“Š'
            },
            {
                id: 'frenzy',
                name: 'ç‹‚äº‚',
                icon: 'ğŸ”¥',
                color: '#e74c3c',
                tier: 'boss',
                effect: { atkMultiplier: 1.4, doubleAttackChance: 0.2 },
                reward: { goldMultiplier: 1.4, expMultiplier: 1.4 },
                description: 'æ”»æ“Š+40%+20%é›™å€æ”»æ“Š'
            },
            {
                id: 'colossus',
                name: 'æ³°å¦',
                icon: 'ğŸ’ª',
                color: '#3498db',
                tier: 'boss',
                effect: { hpMultiplier: 2.0, defMultiplier: 1.5 },
                reward: { goldMultiplier: 1.4, expMultiplier: 1.4 },
                description: 'ç”Ÿå‘½+100%+é˜²ç¦¦+50%'
            },
            {
                id: 'void',
                name: 'è™›ç©º',
                icon: 'ğŸ•³ï¸',
                color: '#8e44ad',
                tier: 'boss',
                effect: { armorPen: 0.5, lifeSteal: 0.25 },
                reward: { goldMultiplier: 1.45, expMultiplier: 1.45 },
                description: 'ç„¡è¦–é˜²ç¦¦50%+å¸è €25%'
            },
            {
                id: 'temporal',
                name: 'æ™‚ç©º',
                icon: 'â³',
                color: '#16a085',
                tier: 'special',
                effect: { resetChance: 0.2 },
                reward: { goldMultiplier: 1.5, expMultiplier: 1.5 },
                description: '20%æ©Ÿç‡é‡ç½®å›åˆ'
            },
            {
                id: 'divine',
                name: 'ç¥è–',
                icon: 'âœ¨',
                color: '#f39c12',
                tier: 'special',
                effect: { allStatsMultiplier: 1.4, regen: 0.1 },
                reward: { goldMultiplier: 1.6, expMultiplier: 1.6 },
                description: 'å…¨å±¬æ€§+40%+æ¯å›åˆå›å¾©10%'
            },
            {
                id: 'apocalypse',
                name: 'æœ«æ—¥',
                icon: 'â˜ ï¸',
                color: '#c0392b',
                tier: 'special',
                effect: { atkMultiplier: 1.8, hpMultiplier: 1.8, damageReduction: 0.3 },
                reward: { goldMultiplier: 1.8, expMultiplier: 1.8, dropBonus: 0.5 },
                description: 'æ”»æ“Š+80%+ç”Ÿå‘½+80%+æ¸›å‚·30%'
            }
        ];
        
        // æ€ªç‰©è©ç¶´æ©Ÿç‡è¡¨
        const MONSTER_AFFIX_CHANCES = {
            normal: { 0: 0.95, 1: 0.05, 2: 0, 3: 0 },
            elite: { 0: 0.70, 1: 0.25, 2: 0.05, 3: 0 },
            boss: { 0: 0.50, 1: 0.30, 2: 0.15, 3: 0.05 },
            specialBoss: { 0: 0, 1: 0, 2: 0.50, 3: 0.50 }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±

        // æ€ªç‰©è©ç¶´ç”Ÿæˆå‡½æ•¸
        function generateMonsterAffixes(enemy, regionMultiplier = 1.0) {
            // æ±ºå®šæ€ªç‰©é¡å‹
            let monsterType = 'normal';
            let isBossType = false;
            if (enemy.isSpecialBoss) {
                monsterType = 'specialBoss';
                isBossType = true;
            } else if (enemy.isBoss) {
                monsterType = 'boss';
                isBossType = true;
            } else if (enemy.isElite) {
                monsterType = 'elite';
            }
            
            // ğŸ¯ æ‡‰ç”¨å€åŸŸå€ç‡åˆ°è©ç¶´æ©Ÿç‡
            const baseChances = MONSTER_AFFIX_CHANCES[monsterType];
            const chances = {};
            
            // è¨ˆç®—èª¿æ•´å¾Œçš„æ©Ÿç‡ï¼ˆå¾é«˜åˆ°ä½èª¿æ•´ï¼‰
            // ç­–ç•¥ï¼šé™ä½0è©ç¶´æ©Ÿç‡ï¼Œæé«˜æœ‰è©ç¶´æ©Ÿç‡
            const noAffixReduction = Math.min(0.5, (regionMultiplier - 1.0) * 0.5); // æœ€å¤šé™ä½50%
            chances[0] = Math.max(0, baseChances[0] - noAffixReduction);
            
            // å°‡é™ä½çš„æ©Ÿç‡åˆ†é…çµ¦æœ‰è©ç¶´çš„æƒ…æ³
            const redistributed = baseChances[0] - chances[0];
            chances[1] = Math.min(1.0, baseChances[1] + redistributed * 0.4);
            chances[2] = Math.min(1.0, baseChances[2] + redistributed * 0.35);
            chances[3] = Math.min(1.0, baseChances[3] + redistributed * 0.25);
            
            // æ­¸ä¸€åŒ–æ©Ÿç‡ï¼ˆç¢ºä¿ç¸½å’Œç‚º1ï¼‰
            const total = chances[0] + chances[1] + chances[2] + chances[3];
            for (let i = 0; i <= 3; i++) {
                chances[i] = chances[i] / total;
            }
            
            // æ ¹æ“šæ©Ÿç‡æ±ºå®šè©ç¶´æ•¸é‡
            let affixCount = 0;
            const random = Math.random();
            let cumulative = 0;
            
            for (let count = 0; count <= 3; count++) {
                cumulative += chances[count];
                if (random < cumulative) {
                    affixCount = count;
                    break;
                }
            }
            
            if (affixCount === 0) return;
            
            // é¸æ“‡è©ç¶´ï¼ˆå‰ä¸­å¾Œç¶´ç³»çµ±ï¼‰
            let prefix = null;
            let infix = null;
            let suffix = null;
            const selectedAffixes = [];
            
            // ç¯©é¸å¯ç”¨è©ç¶´ï¼ˆæ ¹æ“šæ€ªç‰©é¡å‹ï¼‰
            const filterByTier = (affixes) => {
                if (monsterType === 'specialBoss') {
                    return affixes; // ç‰¹æ®ŠBosså¯ç”¨æ‰€æœ‰è©ç¶´
                } else if (monsterType === 'boss') {
                    return affixes.filter(a => a.tier !== 'special');
                } else if (monsterType === 'elite') {
                    return affixes.filter(a => a.tier === 'basic' || a.tier === 'advanced');
                } else {
                    return affixes.filter(a => a.tier === 'basic');
                }
            };
            
            // æ ¹æ“šè©ç¶´æ•¸é‡é¸æ“‡
            if (affixCount === 1) {
                // 1è©ç¶´ï¼š50%å‰ç¶´ï¼Œ50%å¾Œç¶´
                if (Math.random() < 0.5) {
                    const available = filterByTier(PREFIX_AFFIXES);
                    if (available.length > 0) {
                        prefix = available[Math.floor(Math.random() * available.length)];
                        if (prefix) selectedAffixes.push(prefix);
                    }
                } else {
                    const available = filterByTier(SUFFIX_AFFIXES);
                    if (available.length > 0) {
                        suffix = available[Math.floor(Math.random() * available.length)];
                        if (suffix) selectedAffixes.push(suffix);
                    }
                }
            } else if (affixCount === 2) {
                // 2è©ç¶´ï¼šå‰ç¶´+å¾Œç¶´
                const availablePrefix = filterByTier(PREFIX_AFFIXES);
                const availableSuffix = filterByTier(SUFFIX_AFFIXES);
                if (availablePrefix.length > 0) {
                    prefix = availablePrefix[Math.floor(Math.random() * availablePrefix.length)];
                    if (prefix) selectedAffixes.push(prefix);
                }
                if (availableSuffix.length > 0) {
                    suffix = availableSuffix[Math.floor(Math.random() * availableSuffix.length)];
                    if (suffix) selectedAffixes.push(suffix);
                }
            } else if (affixCount === 3 && isBossType) {
                // 3è©ç¶´ï¼ˆåƒ¥Bossï¼‰ï¼šå‰ç¶´+ä¸­ç¶´+å¾Œç¶´
                const availablePrefix = filterByTier(PREFIX_AFFIXES);
                const availableInfix = filterByTier(INFIX_AFFIXES);
                const availableSuffix = filterByTier(SUFFIX_AFFIXES);
                if (availablePrefix.length > 0) {
                    prefix = availablePrefix[Math.floor(Math.random() * availablePrefix.length)];
                    if (prefix) selectedAffixes.push(prefix);
                }
                if (availableInfix.length > 0) {
                    infix = availableInfix[Math.floor(Math.random() * availableInfix.length)];
                    if (infix) selectedAffixes.push(infix);
                }
                if (availableSuffix.length > 0) {
                    suffix = availableSuffix[Math.floor(Math.random() * availableSuffix.length)];
                    if (suffix) selectedAffixes.push(suffix);
                }
            }
            
            // æ‡‰ç”¨è©ç¶´æ•ˆæœ
            enemy.affixes = selectedAffixes;
            enemy.affixEffects = {};
            
            let totalGoldMult = 1;
            let totalExpMult = 1;
            let totalDropBonus = 0;
            
            selectedAffixes.forEach(affix => {
                // å®‰å…¨æª¢æŸ¥
                if (!affix || !affix.effect) return;
                
                // æ‡‰ç”¨æ•ˆæœ
                const effect = affix.effect;
                
                if (effect.atkMultiplier) {
                    enemy.atk = Math.floor(enemy.atk * effect.atkMultiplier);
                }
                if (effect.defMultiplier) {
                    enemy.def = Math.floor(enemy.def * effect.defMultiplier);
                }
                if (effect.hpMultiplier) {
                    enemy.maxHp = Math.floor(enemy.maxHp * effect.hpMultiplier);
                    enemy.hp = enemy.maxHp;
                }
                if (effect.allStatsMultiplier) {
                    enemy.atk = Math.floor(enemy.atk * effect.allStatsMultiplier);
                    enemy.def = Math.floor(enemy.def * effect.allStatsMultiplier);
                    enemy.maxHp = Math.floor(enemy.maxHp * effect.allStatsMultiplier);
                    enemy.hp = enemy.maxHp;
                }
                if (effect.critRate) {
                    enemy.crit = (enemy.crit || 0) + effect.critRate * 100;
                }
                if (effect.critDamage) {
                    enemy.critDmg = (enemy.critDmg || 150) + effect.critDamage * 100;
                }
                
                // å„²å­˜ç‰¹æ®Šæ•ˆæœä¾›æˆ°é¬¥ä¸­ä½¿ç”¨
                if (effect.lifeSteal) enemy.affixEffects.lifeSteal = effect.lifeSteal;
                if (effect.damageReduction) enemy.affixEffects.damageReduction = effect.damageReduction;
                if (effect.reflect) enemy.affixEffects.reflect = effect.reflect;
                if (effect.regen) enemy.affixEffects.regen = effect.regen;
                if (effect.dodgeChance) enemy.affixEffects.dodgeChance = effect.dodgeChance;
                if (effect.armorPen) enemy.affixEffects.armorPen = effect.armorPen;
                if (effect.doubleAttackChance) enemy.affixEffects.doubleAttackChance = effect.doubleAttackChance;
                if (effect.lowHpAtkBonus) {
                    enemy.affixEffects.lowHpAtkBonus = effect.lowHpAtkBonus;
                    enemy.affixEffects.lowHpThreshold = effect.lowHpThreshold;
                }
                if (effect.lowHpDefBonus) {
                    enemy.affixEffects.lowHpDefBonus = effect.lowHpDefBonus;
                    enemy.affixEffects.lowHpDefThreshold = effect.lowHpThreshold;
                }
                if (effect.lowHpDefMultiplier) {
                    enemy.affixEffects.lowHpDefMultiplier = effect.lowHpDefMultiplier;
                    enemy.affixEffects.lowHpDefThreshold = effect.lowHpThreshold;
                }
                if (effect.revive) {
                    enemy.affixEffects.revive = true;
                    enemy.affixEffects.revivePercent = effect.revivePercent;
                }
                if (effect.damageVariance) enemy.affixEffects.damageVariance = effect.damageVariance;
                if (effect.stackingAtk) {
                    enemy.affixEffects.stackingAtk = effect.stackingAtk;
                    enemy.affixEffects.maxStacks = effect.maxStacks;
                    enemy.affixEffects.currentStacks = 0;
                }
                if (effect.elementalAttack) {
                    enemy.affixEffects.elementalAttack = true;
                }
                if (effect.resetChance) {
                    enemy.affixEffects.resetChance = effect.resetChance;
                }
                
                // ç´¯è¨ˆçå‹µ
                if (affix.reward) {
                    if (affix.reward.goldMultiplier) totalGoldMult *= affix.reward.goldMultiplier;
                    if (affix.reward.expMultiplier) totalExpMult *= affix.reward.expMultiplier;
                    if (affix.reward.dropBonus) totalDropBonus += affix.reward.dropBonus;
                }
            });
            
            // å„²å­˜çå‹µä¿‚æ•¸
            enemy.rewardMultipliers = {
                gold: totalGoldMult,
                exp: totalExpMult,
                drop: totalDropBonus
            };
            
            // æ›´æ–°æ€ªç‰©åç¨±ï¼ˆå‰ä¸­å¾Œç¶´æ ¼å¼ï¼‰
            const baseName = enemy.name;
            let newName = '';
            let icons = '';
            
            if (prefix) {
                newName += prefix.name;
                icons += prefix.icon;
            }
            if (infix) {
                newName += infix.name;
                icons += infix.icon;
            }
            newName += baseName;
            if (suffix) {
                newName += suffix.name;
                icons += suffix.icon;
            }
            
            enemy.baseName = baseName;  // ä¿å­˜åŸºç¤åç¨±ä¾›åœ–é‘‘ä½¿ç”¨
            enemy.name = newName;
            enemy.affixIcons = icons;
            enemy.prefix = prefix;
            enemy.infix = infix;
            enemy.suffix = suffix;
        }

        function generateEnemy(region, isBoss) {
            // æª¢æŸ¥regionæ˜¯å¦å­˜åœ¨
            if (!region) {
                console.error('generateEnemy: regionä¸å­˜åœ¨');
                region = REGIONS[0]; // ä½¿ç”¨é è¨­å€åŸŸ
            }
            
            // ğŸ¯ å€åŸŸæ¼¸é€²é›£åº¦ç³»çµ±ï¼šæ ¹æ“šå€åŸŸæ±ºå®šå€ç‡
            const regionIndex = REGIONS.indexOf(region);
            const REGION_MULTIPLIERS = [1.0, 1.3, 1.6, 2.0]; // 4å€‹å€åŸŸçš„å€ç‡
            const regionMultiplier = REGION_MULTIPLIERS[regionIndex] || 1.0;
            
            // ğŸ¯ ç²¾è‹±æ€ªç”Ÿæˆæ©Ÿåˆ¶ï¼ˆéBossæ™‚æ‰åˆ¤å®šï¼‰
            let isElite = false;
            if (!isBoss) {
                const baseEliteChance = 0.10; // åŸºç¤10%æ©Ÿç‡
                const eliteChance = baseEliteChance * regionMultiplier; // æ‡‰ç”¨å€åŸŸå€ç‡
                isElite = Math.random() < eliteChance;
            }
            
            // æ–°çš„æ€ªç‰©åŸºç¤æ•¸å€¼å…¬å¼ï¼ˆæå‡é›£åº¦ï¼‰
            const baseHp = 100 + gameState.player.level * 15; // 12 â†’ 15 (+25%)
            const baseAtk = 8 + gameState.player.level * 2.5; // 2 â†’ 2.5 (+25%)
            const baseDef = 3 + gameState.player.level * 1.3; // 1 â†’ 1.3 (+30%)

            
            let enemyName = '';
            let enemyIcon = '';
            let isSpecialBoss = false;
            
            if (isBoss) {
                // 5%æ©Ÿç‡ç”Ÿæˆç‰¹æ®ŠBossï¼ˆå€åŸŸå°ˆå±¬ï¼‰
                if (Math.random() < 0.05) {
                    const specialBoss = SPECIAL_BOSSES[region.name];
                    if (specialBoss) {
                        enemyName = specialBoss.name;
                        enemyIcon = specialBoss.icon;
                        isSpecialBoss = true;
                    } else {
                        // å¦‚æœæ²’æœ‰å®šç¾©ç‰¹æ®ŠBossï¼Œç”Ÿæˆæ™®é€šå€åŸŸBoss
                        const regionBoss = REGION_BOSSES[region.name];
                        if (regionBoss) {
                            enemyName = regionBoss.name;
                            enemyIcon = regionBoss.icon;
                        }
                    }
                } else {
                    // ç”Ÿæˆæ™®é€šå€åŸŸBossï¼ˆåªæœ‰ç•¶æ²’æœ‰ç”Ÿæˆç‰¹æ®ŠBossæ™‚ï¼‰
                    const regionBoss = REGION_BOSSES[region.name];
                    if (regionBoss) {
                        enemyName = regionBoss.name;
                        enemyIcon = regionBoss.icon;
                    } else {
                        // å¦‚æœæ²’æœ‰å®šç¾©ï¼Œä½¿ç”¨é è¨­åç¨±
                        enemyName = `${region.name}Boss`;
                        enemyIcon = 'âš¡';
                    }
                }
            } else {
                // ğŸ¯ åˆ¤æ–·æ˜¯å¦ç”Ÿæˆç²¾è‹±æ€ª
                if (isElite) {
                    // å¾ç²¾è‹±æ€ªç‰©è³‡æ–™åº«é¸æ“‡
                    const eliteMonsters = ELITE_MONSTERS[region.name] || [];
                    if (eliteMonsters.length > 0) {
                        const eliteMonster = eliteMonsters[Math.floor(Math.random() * eliteMonsters.length)];
                        enemyName = eliteMonster.name;
                        enemyIcon = eliteMonster.icon;
                    } else {
                        // å¦‚æœæ²’æœ‰ç²¾è‹±æ€ªè³‡æ–™ï¼Œé™ç´šç‚ºæ™®é€šæ€ª
                        isElite = false;
                        const monsters = MONSTERS[region.name] || [];
                        if (monsters.length > 0) {
                            const monster = monsters[Math.floor(Math.random() * monsters.length)];
                            enemyName = monster.name;
                            enemyIcon = monster.icon;
                        }
                    }
                } else {
                    // å¾æ™®é€šæ€ªç‰©è³‡æ–™åº«éš¨æ©Ÿé¸æ“‡
                    const monsters = MONSTERS[region.name] || [];
                    if (monsters.length > 0) {
                        const monster = monsters[Math.floor(Math.random() * monsters.length)];
                        enemyName = monster.name;
                        enemyIcon = monster.icon;
                    } else {
                        enemyName = `${region.name}Bug`;
                        enemyIcon = 'ğŸ›';
                    }
                }
            }
            
            // å¢å¼·ä¿‚æ•¸
            const hpEnhance = 1.2; // è¡€é‡å¢å¼· 20%
            const defEnhance = 1.5; // é˜²ç¦¦å¢å¼· 50%
            
            // èè‹±æ€ªç‰©ç‰¹æ®Šå±¬æ€§
            let eliteMultiplier = { hp: 1, atk: 1, def: 1 };
            let eliteCrit = 0;
            let eliteCritDmg = 0;
            
            // ğŸ¯ ç²¾è‹±æ€ªç‰©å±¬æ€§åŠ æˆ
            if (isElite) {
                eliteMultiplier = { hp: 1.8, atk: 1.4, def: 1.3 };
                eliteCrit = 15;
                eliteCritDmg = 25;
            }
            
            // ğŸ¯ ç‰¹æ®ŠBosså±¬æ€§è¨­å®š
            if (isSpecialBoss) {
                const specialBoss = SPECIAL_BOSSES[region.name];
                if (specialBoss && specialBoss.stats) {
                    eliteMultiplier = {
                        hp: specialBoss.stats.hpMultiplier,
                        atk: specialBoss.stats.atkMultiplier,
                        def: specialBoss.stats.defMultiplier
                    };
                    eliteCrit = specialBoss.stats.critRate * 100;
                    eliteCritDmg = specialBoss.stats.critDamage * 100;
                } else {
                    // é è¨­ç‰¹æ®ŠBosså±¬æ€§
                    eliteMultiplier = { hp: 5.0, atk: 2.5, def: 2.0 };
                    eliteCrit = 20;
                    eliteCritDmg = 50;
                }
            }
            
            // æ€ªç‰©é¡å‹ä¿‚æ•¸ï¼ˆæå‡é›£åº¦ï¼‰
            const typeMultiplier = {
                hp: isSpecialBoss ? eliteMultiplier.hp : (isBoss ? 4.0 : (isElite ? eliteMultiplier.hp : 1.3)),
                atk: isSpecialBoss ? eliteMultiplier.atk : (isBoss ? 1.8 : (isElite ? eliteMultiplier.atk : 1.2)),
                def: isSpecialBoss ? eliteMultiplier.def : (isBoss ? 1.6 : (isElite ? eliteMultiplier.def : 1.4))
            };
            
            // è¨ˆç®—æœ€çµ‚å±¬æ€§
            const baseHpValue = Math.floor(baseHp * region.difficulty * typeMultiplier.hp * hpEnhance);
            const baseAtkValue = Math.floor(baseAtk * region.difficulty * typeMultiplier.atk);
            const baseDefValue = Math.floor(baseDef * region.difficulty * typeMultiplier.def * defEnhance);
            
            // æ·»åŠ éš¨æ©Ÿæµ®å‹•ï¼ˆè®“æ¯å€‹æ€ªç‰©éƒ½æœ‰äº›è¨±å·®ç•°ï¼‰
            const hpVariance = 0.85 + Math.random() * 0.3; // Â±15%
            const atkVariance = 0.9 + Math.random() * 0.2; // Â±10%
            const defVariance = 0.9 + Math.random() * 0.2; // Â±10%
            
            const finalHp = Math.floor(baseHpValue * hpVariance);
            const finalAtk = Math.floor(baseAtkValue * atkVariance);
            const finalDef = Math.floor(baseDefValue * defVariance);
            
            // æš´æ“Šå±¬æ€§ä¹Ÿæ·»åŠ éš¨æ©Ÿæµ®å‹•
            const critVariance = 0.8 + Math.random() * 0.4; // Â±20%
            const critDmgVariance = 0.8 + Math.random() * 0.4; // Â±20%
            
            const finalCrit = Math.floor(eliteCrit * critVariance);
            const finalCritDmg = Math.floor((150 + eliteCritDmg) * critDmgVariance);
            
            const enemy = {
                name: enemyName,
                icon: enemyIcon,
                level: gameState.player.level, // æ€ªç‰©ç­‰ç´šèˆ‡ç©å®¶ç›¸åŒ
                hp: finalHp,
                maxHp: finalHp,
                atk: finalAtk,
                def: finalDef,
                crit: finalCrit,
                critDmg: Math.max(150, finalCritDmg), // æœ€ä½150%
                isBoss: isBoss,
                isSpecialBoss: isSpecialBoss,
                isElite: isElite, // ğŸ¯ æ¨™è¨˜ç²¾è‹±æ€ªç‰©
                regionMultiplier: regionMultiplier // ğŸ¯ å„²å­˜å€åŸŸå€ç‡ä¾›è©ç¶´ç³»çµ±ä½¿ç”¨
            };
            
            // ========== ç”Ÿæˆæ€ªç‰©è©ç¶´ ==========
            if (isSpecialBoss) {
                // ç‰¹æ®ŠBossä½¿ç”¨å›ºå®šèƒ½åŠ›
                const specialBoss = SPECIAL_BOSSES[region.name];
                if (specialBoss && specialBoss.abilities) {
                    enemy.affixes = specialBoss.abilities;
                    enemy.affixEffects = {};
                    
                    let totalGoldMult = 1;
                    let totalExpMult = 1;
                    let totalDropBonus = 0;
                    
                    // æ‡‰ç”¨æ¯å€‹èƒ½åŠ›çš„æ•ˆæœ
                    specialBoss.abilities.forEach(ability => {
                        const effect = ability.effect;
                        
                        // æ‡‰ç”¨å±¬æ€§å€ç‡
                        if (effect.atkMultiplier) enemy.atk = Math.floor(enemy.atk * effect.atkMultiplier);
                        if (effect.defMultiplier) enemy.def = Math.floor(enemy.def * effect.defMultiplier);
                        if (effect.hpMultiplier) {
                            enemy.maxHp = Math.floor(enemy.maxHp * effect.hpMultiplier);
                            enemy.hp = enemy.maxHp;
                        }
                        if (effect.critRate) enemy.crit = (enemy.crit || 0) + effect.critRate * 100;
                        if (effect.critDamage) enemy.critDmg = (enemy.critDmg || 150) + effect.critDamage * 100;
                        
                        // å„²å­˜ç‰¹æ®Šæ•ˆæœä¾›æˆ°é¬¥ä¸­ä½¿ç”¨
                        if (effect.lifeSteal) enemy.affixEffects.lifeSteal = effect.lifeSteal;
                        if (effect.damageReduction) enemy.affixEffects.damageReduction = effect.damageReduction;
                        if (effect.reflect) enemy.affixEffects.reflect = effect.reflect;
                        if (effect.regen) enemy.affixEffects.regen = effect.regen;
                        if (effect.dodgeChance) enemy.affixEffects.dodgeChance = effect.dodgeChance;
                        if (effect.armorPen) enemy.affixEffects.armorPen = effect.armorPen;
                        if (effect.doubleAttackChance) enemy.affixEffects.doubleAttackChance = effect.doubleAttackChance;
                        if (effect.lowHpAtkBonus) {
                            enemy.affixEffects.lowHpAtkBonus = effect.lowHpAtkBonus;
                            enemy.affixEffects.lowHpThreshold = effect.lowHpThreshold;
                        }
                        if (effect.lowHpDefMultiplier) {
                            enemy.affixEffects.lowHpDefMultiplier = effect.lowHpDefMultiplier;
                            enemy.affixEffects.lowHpThreshold = effect.lowHpThreshold;
                        }
                        if (effect.revive) {
                            enemy.affixEffects.revive = true;
                            enemy.affixEffects.revivePercent = effect.revivePercent;
                        }
                        if (effect.stackingAtk) {
                            enemy.affixEffects.stackingAtk = effect.stackingAtk;
                            enemy.affixEffects.maxStacks = effect.maxStacks;
                            enemy.affixEffects.currentStacks = 0;
                        }
                        if (effect.resetChance) {
                            enemy.affixEffects.resetChance = effect.resetChance;
                        }
                        
                        // ç´¯è¨ˆçå‹µ
                        if (ability.reward) {
                            if (ability.reward.goldMultiplier) totalGoldMult *= ability.reward.goldMultiplier;
                            if (ability.reward.expMultiplier) totalExpMult *= ability.reward.expMultiplier;
                            if (ability.reward.dropBonus) totalDropBonus += ability.reward.dropBonus;
                        }
                    });
                    
                    // æ‡‰ç”¨ç‰¹æ®ŠBossçš„ç¸½çå‹µå€ç‡
                    enemy.goldMultiplier = specialBoss.rewardMultiplier;
                    enemy.expMultiplier = specialBoss.rewardMultiplier;
                    enemy.dropBonus = totalDropBonus;
                }
            } else {
                // æ™®é€šæ€ªç‰©ã€ç²¾è‹±æ€ªç‰©ã€å€åŸŸBossä½¿ç”¨éš¨æ©Ÿè©ç¶´
                generateMonsterAffixes(enemy, regionMultiplier);
            }
            
            // ========== æ·»åŠ æ€ªç‰©å…ƒç´ å±¬æ€§ ==========
            const monsterType = isSpecialBoss ? 'boss' : (isBoss ? 'boss' : 'normal');
            const elementChance = MONSTER_ELEMENT_CHANCE[monsterType] || 0;
            if (Math.random() * 100 < elementChance) {
                const elementTypes = Object.keys(ELEMENTS);
                const randomElement = elementTypes[Math.floor(Math.random() * elementTypes.length)];
                enemy.element = randomElement;
                enemy.elementRes = 30; // å°æ‡‰å…ƒç´ æŠ—æ€§30%
            }
            
            return enemy;
        }

        
        // æ›´æ–°Buffè¨ˆæ™‚
        function updateBuffs() {
            if (!gameState.player.buffs) return;
            
            gameState.player.buffs = gameState.player.buffs.filter(buff => {
                buff.duration--;
                if (buff.duration <= 0) {
                    addLog('ç³»çµ±', `${buff.name} æ•ˆæœçµæŸ`);
                    recalculateStats();
                    return false;
                }
                return true;
            });
        }
        
        // å˜—è©¦è§¸ç™¼ç©å®¶æŠ€èƒ½
        function tryTriggerPlayerSkill(trigger, baseDmg) {
            if (!gameState.player.skill) {
                return { triggered: false };
            }
            
            const skill = SKILLS[gameState.player.skill];
            if (!skill || skill.trigger !== trigger) {
                return { triggered: false };
            }
            
            // æª¢æŸ¥å†·å»
            if (skill.lastTrigger && Date.now() - skill.lastTrigger < skill.cooldown * 1000) {
                return { triggered: false };
            }
            
            // æª¢æŸ¥è§¸ç™¼æ©Ÿç‡
            if (Math.random() * 100 > skill.chance) {
                return { triggered: false };
            }
            
            // è¨˜éŒ„è§¸ç™¼æ™‚é–“
            skill.lastTrigger = Date.now();
            
            // æ”»æ“ŠæŠ€èƒ½
            if (skill.type === 'attack') {
                const damage = Math.floor(baseDmg * skill.damageMultiplier);
                return {
                    triggered: true,
                    skillName: gameState.player.skill,
                    damage: damage
                };
            }
            
            // é˜²ç¦¦æŠ€èƒ½ï¼ˆåæ“Šï¼‰
            if (skill.type === 'counter') {
                const damage = Math.floor(gameState.player.atk * skill.damageMultiplier);
                return {
                    triggered: true,
                    skillName: gameState.player.skill,
                    damage: damage
                };
            }
            
            // å¢ç›ŠæŠ€èƒ½
            if (skill.type === 'buff') {
                // æª¢æŸ¥æ˜¯å¦å·²æœ‰åŒåBuff
                if (!gameState.player.buffs) {
                    gameState.player.buffs = [];
                }
                
                const existingBuff = gameState.player.buffs.find(b => b.name === gameState.player.skill);
                if (existingBuff) {
                    // åˆ·æ–°æŒçºŒæ™‚é–“
                    existingBuff.duration = skill.duration;
                } else {
                    // æ–°å¢Buff
                    gameState.player.buffs.push({
                        name: gameState.player.skill,
                        effects: skill.effects,
                        duration: skill.duration
                    });
                }
                
                let buffDesc = '';
                if (skill.effects.atk) buffDesc += `æ”»æ“Š+${skill.effects.atk}% `;
                if (skill.effects.def) buffDesc += `è­·ç”²+${skill.effects.def} `;
                if (skill.effects.crit) buffDesc += `æš´æ“Šç‡+${skill.effects.crit}% `;
                buffDesc += `æŒçºŒ${skill.duration}å›åˆ`;
                
                return {
                    triggered: true,
                    skillName: gameState.player.skill,
                    buff: buffDesc
                };
            }
            
            return { triggered: false };
        }


        // è™•ç†æˆ°é¬¥é–‹å§‹æ™‚çš„ç‰¹æ®Šæ•ˆæœ
        function applyBattleStartSpecialEffects() {
            const player = gameState.player;
            const equipment = player.equipment;
            
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item) continue;
                
                // æª¢æŸ¥å¾Œç¶´æ•ˆæœ
                if (item.equipmentAffix && item.equipmentAffix.suffix && item.equipmentAffix.suffix.effect) {
                    const effect = item.equipmentAffix.suffix.effect;
                    
                    // é­”ç›¾æ•ˆæœ
                    if (effect.type === 'onBattleStart' && effect.shieldPercent) {
                        const shieldAmount = Math.floor(player.maxHp * effect.shieldPercent);
                        if (!player.shield) player.shield = 0;
                        player.shield += shieldAmount;
                        addLog('è­·ç›¾', `ğŸ›¡ï¸ é­”ç›¾æ•ˆæœï¼ç²å¾— ${shieldAmount} é»è­·ç›¾`);
                    }
                }
                
                // æª¢æŸ¥ç‰¹æ®Šè©ç¶´ï¼ˆé£¾å“ï¼‰
                if (item.equipmentAffix && item.equipmentAffix.type === 'special' && item.equipmentAffix.data) {
                    const effect = item.equipmentAffix.data.effect;
                    
                    // å½©è™¹æ•ˆæœï¼šéš¨æ©ŸBuff
                    if (effect && effect.type === 'onBattleStart' && effect.randomBuff) {
                        const buffs = [
                            { name: 'åŠ›é‡', stat: 'atk', value: 0.2 },
                            { name: 'æ•æ·', stat: 'crit', value: 10 },
                            { name: 'å …éŸŒ', stat: 'def', value: 0.3 },
                            { name: 'æš´æ“Š', stat: 'critDmg', value: 50 }
                        ];
                        const randomBuff = buffs[Math.floor(Math.random() * buffs.length)];
                        
                        player.buffs.push({
                            name: `å½©è™¹ï¼š${randomBuff.name}`,
                            stat: randomBuff.stat,
                            value: randomBuff.value,
                            duration: effect.duration,
                            startTime: Date.now()
                        });
                        
                        addLog('Buff', `ğŸŒˆ å½©è™¹æ•ˆæœï¼ç²å¾—${randomBuff.name}Buffï¼`);
                        recalculateStats();
                    }
                }
            }
        }

        function battle(enemy) {
            // æ•™å­¸ç³»çµ±å·²ç§»é™¤
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šèˆ‡éš¨å¾/å¯µç‰©æˆ°é¬¥
            if (gameState.companions && gameState.companions.active) {
                updateQuestProgress('battle_with_companion', 1);
            }
            if (gameState.pets && gameState.pets.active) {
                updateQuestProgress('battle_with_pet', 1);
            }
            
            // è¨­å®šæˆ°é¬¥é€²è¡Œä¸­æ¨™è¨˜
            isBattleInProgress = true;
            
            // é‡ç½®æ¯å ´æˆ°é¬¥çš„å¾©æ´»æ©Ÿæœƒ
            if (!gameState.player.battleReviveUsed) {
                gameState.player.battleReviveUsed = false;
            } else {
                gameState.player.battleReviveUsed = false;
            }
            
            // æ‡‰ç”¨æˆ°é¬¥é–‹å§‹æ™‚çš„ç‰¹æ®Šæ•ˆæœ
            applyBattleStartSpecialEffects();
            
            // è™•ç†ç…™éœ§å½ˆæ•ˆæœï¼ˆé™ä½æ•µäººæ”»æ“ŠåŠ›ï¼‰
            if (gameState.player.buffs) {
                const smokeDebuff = gameState.player.buffs.find(b => b.type === 'enemy_atk_debuff');
                if (smokeDebuff) {
                    const reduction = Math.floor(smokeDebuff.value * 100);
                    enemy.atk = Math.floor(enemy.atk * (1 - smokeDebuff.value));
                    addLog('é“å…·', `ğŸ’¨ ç…™éœ§å½ˆç”Ÿæ•ˆï¼æ•µäººæ”»æ“ŠåŠ›é™ä½${reduction}%ï¼`);
                }
            }
            
            // è§¸ç™¼éš¨å¾æˆ°é¬¥é–‹å§‹æŠ€èƒ½ï¼ˆæ¸›ç›Šå‹ï¼‰
            const companionBattleStart = triggerCompanionSkill('battle_start', {enemy});
            if (companionBattleStart) {
                companionBattleStart.forEach(result => {
                    if (result.type === 'debuff') {
                        if (result.skillType === 'debuff_atk') {
                            enemy.atk = Math.floor(enemy.atk * (1 - result.value / 100));
                        } else if (result.skillType === 'debuff_def') {
                            enemy.def = Math.floor(enemy.def * (1 - result.value / 100));
                        } else if (result.skillType === 'debuff_crit') {
                            enemy.crit = Math.max(0, (enemy.crit || 0) * (1 - result.value / 100));
                        }
                        addLog('éš¨å¾', result.message);
                    }
                });
            }
            
            // é¡¯ç¤ºæ€ªç‰©HPæ¢
            showEnemyHP(enemy);

            let playerHp = gameState.player.hp;
            let enemyHp = enemy.hp;
            const enemyMaxHp = enemy.hp; // ä¿å­˜æ€ªç‰©æœ€å¤§è¡€é‡
            let round = 0;
            
            const battleInterval = setInterval(() => {
                round++;
                
                // æ¸›å°‘éš¨å¾æŠ€èƒ½å†·å»
                reduceCompanionCooldowns();
                
                // è§¸ç™¼éš¨å¾å›åˆé–‹å§‹æŠ€èƒ½ï¼ˆæŒçºŒæ²»ç™‚ï¼‰
                const companionTurnStart = triggerCompanionSkill('turn_start');
                if (companionTurnStart) {
                    companionTurnStart.forEach(result => {
                        if (result.type === 'heal') {
                            addLog('éš¨å¾', result.message);
                        }
                    });
                }
                
                // ç²å–éš¨å¾è£å‚™çµ„åˆæ•ˆæœ
                const comboEffects = getCompanionEquipmentCombo();
                
                // ä¿å­˜åŸå§‹æœ€å¤§ç”Ÿå‘½å€¼åˆ°gameStateï¼ˆç”¨æ–¼æˆ°é¬¥çµæŸå¾Œæ¢å¾©ï¼‰
                gameState.originalMaxHpBeforeCombat = gameState.player.maxHp;
                
                // æ‡‰ç”¨æœ€å¤§ç”Ÿå‘½çµ„åˆæ•ˆæœ
                if (comboEffects.hp > 0) {
                    gameState.player.maxHp = Math.floor(gameState.player.maxHp * (1 + comboEffects.hp));
                    // å¦‚æœç”Ÿå‘½å€¼æ˜¯æ»¿çš„,ä¹Ÿè¦å¢åŠ ç•¶å‰ç”Ÿå‘½
                    if (gameState.player.hp === gameState.originalMaxHpBeforeCombat) {
                        gameState.player.hp = gameState.player.maxHp;
                    }
                }
                
                // ç©å®¶æ”»æ“Šï¼ˆæ‡‰ç”¨çµ„åˆæ•ˆæœï¼‰
                const playerAtkWithCombo = Math.floor(gameState.player.atk * (1 + comboEffects.atk));
                let playerDmg = calculateDamage(playerAtkWithCombo, enemy.def, gameState.player.armorPen);
                let playerCrit = gameState.player.crit + (comboEffects.crit * 100);
                // åŠ ä¸Šå¥—è£æš´æ“Šç‡
                if (gameState.player.setEffects) {
                    playerCrit += gameState.player.setEffects.crit;
                }
                
                // é›·å…ƒç´ è¢«å‹•ï¼šæš´æ“Šç‡+10%
                let playerElement = null;
                if (gameState.player.equipment.weapon && gameState.player.equipment.weapon.element) {
                    playerElement = gameState.player.equipment.weapon.element;
                } else if (gameState.player.equipment.armor && gameState.player.equipment.armor.element) {
                    playerElement = gameState.player.equipment.armor.element;
                } else if (gameState.player.equipment.accessory1 && gameState.player.equipment.accessory1.element) {
                    playerElement = gameState.player.equipment.accessory1.element;
                } else if (gameState.player.equipment.accessory2 && gameState.player.equipment.accessory2.element) {
                    playerElement = gameState.player.equipment.accessory2.element;
                }
                if (playerElement === 'thunder') {
                    playerCrit += 10;
                }
                
                const isCrit = Math.random() * 100 < playerCrit;
                if (isCrit) trackCrit();
                let playerCritDmg = gameState.player.critDmg + (comboEffects.critDmg * 100);
                // åŠ ä¸Šå¥—è£æš´æ“Šå‚·å®³
                if (gameState.player.setEffects) {
                    playerCritDmg += gameState.player.setEffects.critDmg;
                }
                let finalDmg = isCrit ? Math.floor(playerDmg * playerCritDmg / 100) : playerDmg;
                
                // æ‡‰ç”¨è£å‚™è©ç¶´æ•ˆæœ
                const affixExtraDmg = applyEquipmentAffixEffects(finalDmg, isCrit, enemy);
                finalDmg += affixExtraDmg;
                
                // æ‡‰ç”¨è£å‚™ç‰¹æ®Šæ•ˆæœ
                const specialEffectResult = applyPlayerSpecialEffects(finalDmg, isCrit, enemy);
                finalDmg += specialEffectResult.extraDamage;
                if (specialEffectResult.message) {
                    addLog('ç‰¹æ®Š', specialEffectResult.message);
                }
                
                // å°é¦–é ˜å‚·å®³åŠ æˆ
                if ((enemy.isBoss || enemy.isSpecialBoss) && gameState.player.bossDmg > 0) {
                    const bossDmgBonus = Math.min(gameState.player.bossDmg, 100);
                    finalDmg = Math.floor(finalDmg * (1 + bossDmgBonus / 100));
                }
                
                // ========== å…ƒç´ å…‹åˆ¶è¨ˆç®— ==========
                // ä½¿ç”¨ä¹‹å‰å·²ç¶“å®£å‘Šçš„playerElementè®Šæ•¸
                
                if (playerElement && enemy.element) {
                    const playerElem = ELEMENTS[playerElement];
                    const enemyElem = ELEMENTS[enemy.element];
                    
                    // å…‹åˆ¶é—œä¿‚
                    if (playerElem.strongAgainst === enemy.element) {
                        finalDmg = Math.floor(finalDmg * 1.3);
                        addLog('å…ƒç´ ', `${playerElem.icon} ${playerElem.name}å…‹åˆ¶${enemyElem.icon} ${enemyElem.name}ï¼é¡å¤–å‚·å®³ï¼`);
                    } else if (playerElem.weakAgainst === enemy.element) {
                        finalDmg = Math.floor(finalDmg * 0.7);
                        addLog('å…ƒç´ ', `${playerElem.icon} ${playerElem.name}è¢«${enemyElem.icon} ${enemyElem.name}å…‹åˆ¶ï¼å‚·å®³é™ä½ï¼`);
                    }
                }
                
                // å…ƒç´ ç‰¹æ•ˆè§¸ç™¼
                if (playerElement) {
                    const elem = ELEMENTS[playerElement];
                    if (Math.random() < elem.effectChance) {
                        if (elem.effect === 'burn') {
                            const burnDmg = Math.floor(enemy.maxHp * elem.effectValue);
                            if (!enemy.burns) enemy.burns = [];
                            enemy.burns.push({ damage: burnDmg, duration: elem.effectDuration });
                            addLog('å…ƒç´ ', `${elem.icon} ç¼ç‡’æ•ˆæœï¼ç›®æ¨™æ¯å›åˆå—åˆ°${burnDmg}é»å‚·å®³ï¼`);
                        } else if (elem.effect === 'freeze') {
                            if (!enemy.iceDebuff) {
                                enemy.iceDebuff = { duration: elem.effectDuration };
                                enemy.atk = Math.floor(enemy.atk * (1 - elem.effectValue));
                                addLog('å…ƒç´ ', `${elem.icon} å†°å‡æ•ˆæœï¼ç›®æ¨™æ”»æ“ŠåŠ›é™ä½20%ï¼`);
                            }
                        } else if (elem.effect === 'shock' && isCrit) {
                            finalDmg = Math.floor(finalDmg * elem.effectValue);
                            addLog('å…ƒç´ ', `${elem.icon} é›·é³´æš´æ“Šï¼é€ æˆé›™å€å‚·å®³ï¼`);
                        } else if (elem.effect === 'poison') {
                            const poisonDmg = Math.floor(enemy.maxHp * elem.effectValue);
                            const duration = enemy.isBoss ? 3 : elem.effectDuration;
                            if (!enemy.poisons) enemy.poisons = [];
                            enemy.poisons.push({ damage: poisonDmg, duration: duration });
                            addLog('å…ƒç´ ', `${elem.icon} ä¸­æ¯’æ•ˆæœï¼ç›®æ¨™æ¯å›åˆå—åˆ°${poisonDmg}é»æ¯’å‚·å®³ï¼`);
                        }
                    }
                    
                }
                
                // æ‡‰ç”¨æ€ªç‰©è©ç¶´æ•ˆæœï¼ˆå—æ“Šæ™‚ï¼‰
                const monsterHitResult = applyMonsterAffixOnHit(enemy, finalDmg);
                
                // æª¢æŸ¥æ˜¯å¦é–ƒé¿
                if (monsterHitResult.dodged) {
                    addLog('è©ç¶´', `âš¡ æ€ªç‰©é–ƒé¿äº†æ”»æ“Šï¼`);
                    updateEnemyHP(enemyHp, enemyMaxHp);
                    // é–ƒé¿å¾Œä¸åŸ·è¡Œå¾ŒçºŒå‚·å®³è¨ˆç®—
                } else {
                    finalDmg = monsterHitResult.damage;
                
                // è§¸ç™¼å¡ç‰Œæ•ˆæœï¼ˆæ”»æ“Šæ™‚ï¼‰
                const cardAttackResult = triggerCardEffectsOnAttack(finalDmg, enemy);
                finalDmg = cardAttackResult.damage;
                
                // é¡¯ç¤ºå¡ç‰Œè§¸ç™¼æ•ˆæœ
                if (cardAttackResult.effects && cardAttackResult.effects.length > 0) {
                    cardAttackResult.effects.forEach(effect => {
                        if (effect.type === 'extraDamage') {
                            addLog('å¡ç‰Œ', `${effect.icon} è§¸ç™¼ï¼é¡å¤–é€ æˆ ${effect.value} é»å‚·å®³ï¼`);
                        } else if (effect.type === 'chain') {
                            addLog('å¡ç‰Œ', `${effect.icon} è§¸ç™¼ï¼é€£é£ ${effect.count} æ¬¡ï¼Œé€ æˆ ${effect.value} é»å‚·å®³ï¼`);
                        }
                    });
                }
                
                enemyHp -= finalDmg;
                enemy.hp = enemyHp; // åŒæ­¥enemy.hp
                
                // åå½ˆå‚·å®³
                if (monsterHitResult.reflect > 0) {
                    gameState.player.hp -= monsterHitResult.reflect;
                    playerHp -= monsterHitResult.reflect;
                    addLog('è©ç¶´', `ğŸ›¡ï¸ æ€ªç‰©åå½ˆäº† ${monsterHitResult.reflect} é»å‚·å®³`);
                }
                
                // å¸è¡€å›å¾©
                if (gameState.player.lifeSteal > 0 || comboEffects.lifeSteal > 0) {
                    const totalLifeSteal = gameState.player.lifeSteal + (comboEffects.lifeSteal * 100);
                    const lifeStealCap = Math.min(totalLifeSteal, 30);
                    const healAmount = Math.floor(finalDmg * lifeStealCap / 100);
                    if (healAmount > 0) {
                        gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                        addLog('æˆ°é¬¥', `ğŸ©¸ å¸è¡€å›å¾© ${healAmount} é»ç”Ÿå‘½å€¼`);
                    }
                }
                

                // å˜—è©¦è§¸ç™¼ç©å®¶æŠ€èƒ½ï¼ˆæ”»æ“Šæ™‚ï¼‰
                const skillResult = tryTriggerPlayerSkill('onAttack', playerDmg);
                if (skillResult.triggered) {
                    playSound('skill'); // æŠ€èƒ½éŸ³æ•ˆ
                    if (skillResult.damage > 0) {
                        enemyHp -= skillResult.damage;
                        addLog('æŠ€èƒ½', `âš¡ ${skillResult.skillName} è§¸ç™¼ï¼é€ æˆ ${skillResult.damage} é»å‚·å®³`);
                    } else if (skillResult.buff) {
                        addLog('æŠ€èƒ½', `âœ¨ ${skillResult.skillName} è§¸ç™¼ï¼${skillResult.buff}`);
                        recalculateStats();
                    }
                }
                
                // å¥—è£ç‰¹æ®Šæ•ˆæœè§¸ç™¼
                if (gameState.player.setEffects && gameState.player.setEffects.specialEffects) {
                    gameState.player.setEffects.specialEffects.forEach(effect => {
                        // ç ”ç™¼è€…å¥—è£ï¼šæš´æ“Šé€£æ“Š
                        if (effect === 'crit_chain' && isCrit && Math.random() < 0.60) {
                            const chainDmg = Math.floor(finalDmg * 1.0);
                            enemyHp -= chainDmg;
                            addLog('å¥—è£', `âš”ï¸ å®Œç¾ä»£ç¢¼ï¼æš´æ“Šé€£æ“Šé€ æˆ ${chainDmg} é»é¡å¤–å‚·å®³ï¼`);
                        }
                        
                        // é‡å­åŒæ­¥å¥—è£ï¼šé‡å­å´©å¡‰
                        if (effect === 'quantum_collapse' && Math.random() < 0.40) {
                            const collapseDmg = Math.floor(finalDmg * 4.0); // 500%ç¸½å‚·å®³ = é¡å¤–4.0å€
                            enemyHp -= collapseDmg;
                            // æ·»åŠ é˜²ç¦¦é™ä½buffåˆ°æ€ªç‰©
                            if (!enemy.debuffs) enemy.debuffs = [];
                            enemy.debuffs.push({ type: 'def_down', value: 50, duration: 2 });
                            addLog('å¥—è£', `ğŸŒŒ å¥‡é»çˆ†ç™¼ï¼é€ æˆ ${collapseDmg} é»å·¨é¡å‚·å®³ï¼Œæ•µäººé˜²ç¦¦é™ä½50%ï¼`);
                        }
                    });
                }
                
                addLog('æˆ°é¬¥', `ä½ é€ æˆäº† ${Math.floor(finalDmg)} é»å‚·å®³${isCrit ? ' (æš´æ“Šï¼)' : ''}`);
                playSound(isCrit ? 'crit' : 'attack'); // æ”»æ“ŠéŸ³æ•ˆ
                
                // æ›´æ–°æ€ªç‰©HPé¡¯ç¤º
                updateEnemyHP(enemyHp, enemyMaxHp);
                } // é–‰åˆé–ƒé¿æª¢æŸ¥çš„ else
                
                if (enemyHp <= 0) {
                    // æª¢æŸ¥ä¸æ»…è©ç¶´ï¼šå¾©æ´»æ©Ÿåˆ¶
                    if (enemy.affixEffects && enemy.affixEffects.revive && !enemy.hasRevived) {
                        enemy.hasRevived = true;
                        const reviveHp = Math.floor(enemy.maxHp * enemy.affixEffects.revivePercent);
                        enemy.hp = reviveHp;
                        enemyHp = reviveHp;
                        addLog('è©ç¶´', `â° ${enemy.name} ä¸æ»…å¾©æ´»ï¼å›å¾©äº† ${reviveHp} é»ç”Ÿå‘½å€¼`);
                        updateEnemyHP(enemyHp, enemyMaxHp);
                        playSound('heal');
                    } else {
                     // å•Ÿå‹•è€…å¥—è£ï¼šæ“Šæ®ºå›è¡€
                     if (gameState.player.setEffects && gameState.player.setEffects.specialEffects) {
                         gameState.player.setEffects.specialEffects.forEach(effect => {
                             if (effect === 'kill_heal' && Math.random() < 0.50) {
                                 const healAmount = Math.floor(gameState.player.maxHp * 0.20);
                                gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                                addLog('å¥—è£', `ğŸ’š ç³»çµ±åŠ é€Ÿï¼æ“Šæ®ºå›å¾© ${healAmount} é»ç”Ÿå‘½å€¼ï¼`);
                            }
                        });
                    }
                    
                    clearInterval(battleInterval);
                    victory(enemy);
                    return;
                    } // é–‰åˆä¸æ»…è©ç¶´æª¢æŸ¥çš„ else
                }
                
                // æ€ªç‰©å›åˆé–‹å§‹æ•ˆæœ
                const monsterHealAmount = applyMonsterAffixOnTurn(enemy);
                if (monsterHealAmount > 0) {
                    // ä½¿ç”¨enemy.hpè€Œä¸æ˜¯enemyHpï¼Œå› ç‚ºapplyMonsterAffixOnTurnå·²ç¶“æ­£ç¢ºè™•ç†äº†ä¸Šé™
                    enemyHp = enemy.hp;
                    addLog('è©ç¶´', `ğŸ’š æ€ªç‰©å›å¾©äº† ${monsterHealAmount} é»ç”Ÿå‘½å€¼`);
                    // æ›´æ–°æ€ªç‰©HPé¡¯ç¤º
                    updateEnemyHP(enemyHp, enemyMaxHp);
                }
                
                // æ•µäººæ”»æ“Šï¼ˆèè‹±æ€ªç‰©å¯èƒ½æš´æ“Šï¼‰
                // æ‡‰ç”¨ç²¾æº–è©ç¶´ï¼ˆç„¡è¦–é˜²ç¦¦ï¼‰
                let enemyArmorPen = 0;
                if (enemy.affixEffects && enemy.affixEffects.armorPen) {
                    enemyArmorPen = enemy.affixEffects.armorPen * 100;
                }
                let enemyDmg = calculateDamage(enemy.atk, gameState.player.def, enemyArmorPen);
                
                // æ‡‰ç”¨æ€ªç‰©è©ç¶´æ•ˆæœï¼ˆæ”»æ“Šæ™‚ï¼‰
                const monsterAttackResult = applyMonsterAffixOnAttack(enemy, enemyDmg);
                enemyDmg = monsterAttackResult.damage;
                
                // å…ƒç´ æ”¿æ“Šï¼šéš¨æ©Ÿè§¸ç™¼å…ƒç´ æ•ˆæœ
                if (enemy.affixEffects && enemy.affixEffects.elementalAttack) {
                    const elements = ['fire', 'ice', 'thunder', 'poison', 'earth'];
                    const randomElement = elements[Math.floor(Math.random() * elements.length)];
                    const elementData = ELEMENTS[randomElement];
                    
                    if (elementData.effect.type === 'burn' || elementData.effect.type === 'poison') {
                        // ç‡ƒç‡’/ä¸­æ¯’æ•ˆæœ
                        if (!gameState.player.elementalEffects) gameState.player.elementalEffects = {};
                        gameState.player.elementalEffects[randomElement] = {
                            duration: elementData.effect.duration,
                            damagePercent: elementData.effect.damagePercent
                        };
                        addLog('å…ƒç´ ', `${elementData.icon} æ€ªç‰©è§¸ç™¼äº†${elementData.name}ï¼`);
                    } else if (elementData.effect.type === 'weaken') {
                        // å†°å‡æ•ˆæœï¼ˆé™ä½ç©å®¶æ”»æ“Šï¼‰
                        if (!gameState.player.elementalEffects) gameState.player.elementalEffects = {};
                        gameState.player.elementalEffects.ice = {
                            duration: elementData.effect.duration,
                            weakenPercent: elementData.effect.weakenPercent
                        };
                        addLog('å…ƒç´ ', `${elementData.icon} æ€ªç‰©è§¸ç™¼äº†${elementData.name}ï¼ä½ çš„æ”»æ“ŠåŠ›é™ä½äº†ï¼`);
                    }
                }
                
                // è™•ç†å˜—è¡€æ•ˆæœ
                if (monsterAttackResult.lifeSteal > 0) {
                    enemy.hp = Math.min(enemy.hp + monsterAttackResult.lifeSteal, enemy.maxHp);
                    enemyHp = enemy.hp;
                    addLog('è©ç¶´', `ğŸ©¸ æ€ªç‰©å˜—è¡€å›å¾©äº† ${monsterAttackResult.lifeSteal} é»ç”Ÿå‘½å€¼`);
                    updateEnemyHP(enemyHp, enemyMaxHp);
                }
                
                let enemyCrit = false;
                if (enemy.crit && enemy.crit > 0) {
                    enemyCrit = Math.random() * 100 < enemy.crit;
                    if (enemyCrit) {
                        enemyDmg = Math.floor(enemyDmg * enemy.critDmg / 100);
                    }
                }
                
                // å˜—è©¦è§¸ç™¼ç©å®¶æŠ€èƒ½ï¼ˆå—æ“Šæ™‚ï¼‰
                const counterResult = tryTriggerPlayerSkill('onHitTaken', enemyDmg);
                if (counterResult.triggered) {
                    playSound('skill'); // æŠ€èƒ½éŸ³æ•ˆ
                    if (counterResult.damage > 0) {
                        enemyHp -= counterResult.damage;
                        addLog('æŠ€èƒ½', `âš¡ ${counterResult.skillName} è§¸ç™¼ï¼åæ“Šé€ æˆ ${counterResult.damage} é»å‚·å®³`);
                        // æ›´æ–°æ€ªç‰©HPé¡¯ç¤º
                        updateEnemyHP(enemyHp, enemyMaxHp);
                    } else if (counterResult.buff) {
                        addLog('æŠ€èƒ½', `âœ¨ ${counterResult.skillName} è§¸ç™¼ï¼${counterResult.buff}`);
                        recalculateStats();
                    }
                }
                
                // æ‡‰ç”¨é˜²ç¦¦å‹ç‰¹æ®Šæ•ˆæœ
                const defenseResult = applyPlayerDefenseSpecialEffects(enemyDmg, enemy);
                enemyDmg -= defenseResult.damageReduction;
                
                // è§¸ç™¼å¡ç‰Œæ•ˆæœï¼ˆå—æ“Šæ™‚ï¼‰
                const cardHitResult = triggerCardEffectsOnHit(enemyDmg, enemy);
                if (cardHitResult.counterDamage > 0) {
                    enemyHp -= cardHitResult.counterDamage;
                    // é¡¯ç¤ºå¡ç‰Œåæ“Šæ•ˆæœ
                    if (cardHitResult.effects && cardHitResult.effects.length > 0) {
                        cardHitResult.effects.forEach(effect => {
                            if (effect.type === 'counter') {
                                addLog('å¡ç‰Œ', `${effect.icon} è§¸ç™¼ï¼åæ“Šé€ æˆ ${effect.value} é»å‚·å®³ï¼`);
                            }
                        });
                    }
                    // æ›´æ–°æ€ªç‰©HPé¡¯ç¤º
                    updateEnemyHP(enemyHp, enemyMaxHp);
                }
                if (defenseResult.reflectDamage > 0) {
                    enemyHp -= defenseResult.reflectDamage;
                    updateEnemyHP(enemyHp, enemyMaxHp);
                }
                if (defenseResult.message) {
                    addLog('ç‰¹æ®Š', defenseResult.message);
                }
                
                // æ¸›å‚·è¨ˆç®—
                if (gameState.player.dmgRed > 0 || comboEffects.dmgRed > 0) {
                    const totalDmgRed = gameState.player.dmgRed + (comboEffects.dmgRed * 100);
                    const dmgRedCap = Math.min(totalDmgRed, 75);
                    enemyDmg = Math.floor(enemyDmg * (1 - dmgRedCap / 100));
                }
                
                playerHp -= enemyDmg;
                gameState.player.hp = Math.max(0, playerHp);
                
                 // æ©Ÿæ«ƒé˜²ç¦¦å¥—è£ï¼šåæ“Šå›è¡€
                 if (gameState.player.setEffects && gameState.player.setEffects.specialEffects) {
                     gameState.player.setEffects.specialEffects.forEach(effect => {
                         if (effect === 'counter_heal' && Math.random() < 0.50) {
                             const counterDmg = Math.floor(gameState.player.atk * 1.5);
                             const healAmount = Math.floor(counterDmg * 1.0);
                            enemyHp -= counterDmg;
                            gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                            addLog('å¥—è£', `ğŸ›¡ï¸ é˜²ç«ç‰†åæ“Šï¼é€ æˆ ${counterDmg} é»å‚·å®³ä¸¦å›å¾© ${healAmount} é»ç”Ÿå‘½ï¼`);
                            updateEnemyHP(enemyHp, enemyMaxHp);
                        }
                    });
                }
                
                if (enemyCrit) {
                    addLog('æˆ°é¬¥', `${enemy.name} é€ æˆäº† ${Math.floor(enemyDmg)} é»å‚·å®³ ğŸ’¥æš´æ“Šï¼`);
                    playSound('crit'); // æš´æ“ŠéŸ³æ•ˆ
                } else {
                    addLog('æˆ°é¬¥', `${enemy.name} é€ æˆäº† ${Math.floor(enemyDmg)} é»å‚·å®³`);
                    playSound('hit'); // å—æ“ŠéŸ³æ•ˆ
                }
                
                // è™•ç†é€£æ“Šæ•ˆæœ
                if (monsterAttackResult.doubleAttack) {
                    // ç¬¬äºŒæ¬¡æ”»æ“Šï¼Œå‚·å®³æ¸›å°‘åˆ°50%
                    let secondAttackDmg = Math.floor(enemyDmg * 0.5);
                    if (gameState.player.dmgRed > 0) {
                        const dmgRedCap = Math.min(gameState.player.dmgRed, 75);
                        secondAttackDmg = Math.floor(secondAttackDmg * (1 - dmgRedCap / 100));
                    }
                    playerHp -= secondAttackDmg;
                    gameState.player.hp = Math.max(0, playerHp);
                    addLog('è©ç¶´', `âš¡ æ€ªç‰©é€£æ“Šï¼å†æ¬¡é€ æˆ ${secondAttackDmg} é»å‚·å®³`);
                }
                
                // æª¢æŸ¥æ˜¯å¦è§¸ç™¼ç·Šæ€¥æ²»ç™‚ï¼ˆç”Ÿå‘½ä½æ–¼30%ï¼‰
                const hpPercentAfterHit = (gameState.player.hp / gameState.player.maxHp) * 100;
                if (hpPercentAfterHit < 30 && gameState.player.hp > 0) {
                    const companionEmergency = triggerCompanionSkill('low_hp', {hpPercent: hpPercentAfterHit});
                    if (companionEmergency) {
                        companionEmergency.forEach(result => {
                            if (result.type === 'heal') {
                                addLog('éš¨å¾', result.message);
                                playerHp = gameState.player.hp; // æ›´æ–°playerHpè®Šæ•¸
                            }
                        });
                    }
                }
                
                // ========== å…ƒç´ æŒçºŒæ•ˆæœè™•ç† ==========
                // ç¼ç‡’å‚·å®³
                if (enemy.burns && enemy.burns.length > 0) {
                    enemy.burns.forEach(burn => {
                        enemyHp -= burn.damage;
                        enemy.hp = enemyHp; // åŒæ­¥enemy.hp
                        burn.duration--;
                        addLog('å…ƒç´ ', `ğŸ”¥ ç¼ç‡’ï¼š${enemy.name}å—åˆ°${burn.damage}é»ç«ç„°å‚·å®³ï¼(å‰©é¤˜${burn.duration}å›åˆ)`);
                    });
                    enemy.burns = enemy.burns.filter(b => b.duration > 0);
                    updateEnemyHP(enemyHp, enemyMaxHp);
                }
                
                // ä¸­æ¯’å‚·å®³
                if (enemy.poisons && enemy.poisons.length > 0) {
                    enemy.poisons.forEach(poison => {
                        enemyHp -= poison.damage;
                        enemy.hp = enemyHp; // åŒæ­¥enemy.hp
                        poison.duration--;
                        addLog('å…ƒç´ ', `ğŸŒ¿ ä¸­æ¯’ï¼š${enemy.name}å—åˆ°${poison.damage}é»æ¯’å‚·å®³ï¼(å‰©é¤˜${poison.duration}å›åˆ)`);
                    });
                    enemy.poisons = enemy.poisons.filter(p => p.duration > 0);
                    updateEnemyHP(enemyHp, enemyMaxHp);
                }
                
                // å†°å‡æ•ˆæœæ¸›å°‘
                if (enemy.iceDebuff && enemy.iceDebuff.duration > 0) {
                    enemy.iceDebuff.duration--;
                    if (enemy.iceDebuff.duration === 0) {
                        enemy.atk = Math.floor(enemy.atk / 0.8); // æ¢å¾©æ”»æ“ŠåŠ›
                        addLog('å…ƒç´ ', `â„ï¸ ${enemy.name}çš„å†°å‡æ•ˆæœæ¶ˆå¤±äº†ï¼`);
                        delete enemy.iceDebuff;
                    }
                }
                
                // ========== ç©å®¶å…ƒç´ æ•ˆæœè™•ç† ==========
                if (gameState.player.elementalEffects) {
                    const effects = gameState.player.elementalEffects;
                    
                    // è™•ç†ç«å…ƒç´ (ç‡ƒç‡’)
                    if (effects.fire) {
                        const burnDamage = Math.floor(gameState.player.maxHp * effects.fire.damagePercent);
                        playerHp -= burnDamage;
                        gameState.player.hp = Math.max(0, playerHp);
                        effects.fire.duration--;
                        addLog('å…ƒç´ ', `ğŸ”¥ ç‡ƒç‡’ï¼šä½ å—åˆ°${burnDamage}é»ç«ç„°å‚·å®³ï¼(å‰©é¤˜${effects.fire.duration}å›åˆ)`);
                        if (effects.fire.duration <= 0) {
                            delete effects.fire;
                            addLog('å…ƒç´ ', `ğŸ”¥ ç‡ƒç‡’æ•ˆæœæ¶ˆå¤±äº†ï¼`);
                        }
                    }
                    
                    // è™•ç†æ¯’å…ƒç´ (ä¸­æ¯’)
                    if (effects.poison) {
                        const poisonDamage = Math.floor(gameState.player.maxHp * effects.poison.damagePercent);
                        playerHp -= poisonDamage;
                        gameState.player.hp = Math.max(0, playerHp);
                        effects.poison.duration--;
                        addLog('å…ƒç´ ', `ğŸŒ¿ ä¸­æ¯’ï¼šä½ å—åˆ°${poisonDamage}é»æ¯’å‚·å®³ï¼(å‰©é¤˜${effects.poison.duration}å›åˆ)`);
                        if (effects.poison.duration <= 0) {
                            delete effects.poison;
                            addLog('å…ƒç´ ', `ğŸŒ¿ ä¸­æ¯’æ•ˆæœæ¶ˆå¤±äº†ï¼`);
                        }
                    }
                    
                    // è™•ç†å†°å…ƒç´ (æ”»æ“ŠåŠ›é™ä½)
                    if (effects.ice) {
                        effects.ice.duration--;
                        if (effects.ice.duration <= 0) {
                            delete effects.ice;
                            addLog('å…ƒç´ ', `â„ï¸ å†°å‡æ•ˆæœæ¶ˆå¤±äº†ï¼ä½ çš„æ”»æ“ŠåŠ›æ¢å¾©æ­£å¸¸ï¼`);
                        }
                    }
                    
                    // è™•ç†åœŸå…ƒç´ (æ¸›é€Ÿ)
                    if (effects.earth) {
                        effects.earth.duration--;
                        if (effects.earth.duration <= 0) {
                            delete effects.earth;
                            addLog('å…ƒç´ ', `ğŸª¨ çŸ³åŒ–æ•ˆæœæ¶ˆå¤±äº†ï¼`);
                        }
                    }
                }
                
                // ç”Ÿå‘½å›å¾©æ©Ÿåˆ¶ï¼ˆæ¯å›åˆçµæŸæ™‚ï¼‰
                if (gameState.player.hpRegen && gameState.player.hpRegen > 0) {
                    const regenAmount = Math.floor(gameState.player.maxHp * gameState.player.hpRegen / 100);
                    if (regenAmount > 0 && playerHp > 0) {
                        playerHp = Math.min(playerHp + regenAmount, gameState.player.maxHp);
                        gameState.player.hp = playerHp;
                        addLog('å›å¾©', `ğŸ’š ç”Ÿå‘½å›å¾© ${regenAmount} é»ç”Ÿå‘½å€¼`);
                    }
                }
                
                // æŒçºŒå›å¾©è—¥æ°´buffè™•ç†
                if (gameState.player.buffs && playerHp > 0) {
                    const regenBuffs = gameState.player.buffs.filter(b => 
                        b.type === 'hp_regen_potion' || b.type === 'both_regen_potion'
                    );
                    
                    regenBuffs.forEach(buff => {
                        if (buff.type === 'hp_regen_potion') {
                            const healAmount = Math.floor(gameState.player.maxHp * buff.value);
                            playerHp = Math.min(playerHp + healAmount, gameState.player.maxHp);
                            gameState.player.hp = playerHp;
                            addLog('è—¥æ°´', `ğŸ’š ${buff.name} å›å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
                        } else if (buff.type === 'both_regen_potion') {
                            const healAmount = Math.floor(gameState.player.maxHp * buff.hpValue);
                            playerHp = Math.min(playerHp + healAmount, gameState.player.maxHp);
                            gameState.player.hp = playerHp;
                            gameState.player.ap = Math.min(gameState.player.ap + buff.apValue, gameState.player.maxAp);
                            addLog('è—¥æ°´', `ğŸ’š ${buff.name} å›å¾©äº† ${healAmount} HP + ${buff.apValue} APï¼`);
                        }
                    });
                }
                
                if (playerHp <= 0) {
                    // æª¢æŸ¥è­·èº«ç¬¦ä¿è­·
                    const guardianBuff = gameState.player.buffs ? gameState.player.buffs.find(b => b.type === 'guardian') : null;
                    if (guardianBuff) {
                        playerHp = 1;
                        gameState.player.hp = 1;
                        gameState.player.buffs = gameState.player.buffs.filter(b => b.type !== 'guardian');
                        addLog('ä¿è­·', 'ğŸ›¡ï¸ è­·èº«ç¬¦è§¸ç™¼ï¼ä¿ç•™1é»ç”Ÿå‘½ï¼');
                        playSound('heal');
                        updateUI();
                    } else {
                        // æª¢æŸ¥è£å‚™è©ç¶´ä¸­çš„æ™‚å…‰è©ç¶´ï¼ˆå¾©æ´»æ©Ÿåˆ¶ï¼‰
                        let revived = false;
                        if (!gameState.player.battleReviveUsed) {
                        for (const slot in gameState.player.equipment) {
                            const item = gameState.player.equipment[slot];
                            if (!item || !item.equipmentAffix) continue;
                            
                            // æª¢æŸ¥å¾Œç¶´è©ç¶´
                            if (item.equipmentAffix.suffix && item.equipmentAffix.suffix.effect) {
                                const effect = item.equipmentAffix.suffix.effect;
                                if (effect.type === 'onDeath' && effect.chance && effect.revivePercent) {
                                    if (Math.random() < effect.chance) {
                                        // è§¸ç™¼å¾©æ´»
                                        const reviveHp = Math.floor(gameState.player.maxHp * effect.revivePercent);
                                        gameState.player.hp = reviveHp;
                                        playerHp = reviveHp;
                                        gameState.player.battleReviveUsed = true;
                                        revived = true;
                                        addLog('è©ç¶´', `âœ¨ æ™‚å…‰è©ç¶´è§¸ç™¼ï¼å¾©æ´»ä¸¦å›å¾© ${reviveHp} é»ç”Ÿå‘½å€¼ï¼`);
                                        playSound('heal');
                                        updateUI();
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                        if (!revived) {
                            clearInterval(battleInterval);
                            defeat();
                            return;
                        }
                    }
                }
                
                // å˜—è©¦è‡ªå‹•å–è—¥
                if (tryAutoPotion()) {
                    updateUI();
                }
                
                // æ›´æ–°Buffè¨ˆæ™‚
                updateBuffs();
                
                // ========== å¯µç‰©è¡Œå‹• ==========
                const equippedPet = getEquippedPet();
                if (equippedPet && enemyHp > 0) {
                    // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æŠ€èƒ½
                    if (equippedPet.skills && equippedPet.skills.length > 0) {
                        const skill = equippedPet.skills[Math.floor(Math.random() * equippedPet.skills.length)];
                        
                        // åˆ¤å®šè§¸ç™¼æ©Ÿç‡
                        if (Math.random() < skill.chance) {
                            // æŠ€èƒ½è§¸ç™¼ï¼
                            let skillMessage = `${equippedPet.icon} ${equippedPet.name} ä½¿ç”¨äº† ${skill.name}ï¼`;
                            
                            if (skill.type === 'damage') {
                                // å‚·å®³æŠ€èƒ½
                                const petDamage = Math.floor(equippedPet.stats.atk * skill.multiplier);
                                enemyHp -= petDamage;
                                enemy.hp = enemyHp;
                                skillMessage += ` é€ æˆ ${petDamage} é»å‚·å®³ï¼`;
                                updateEnemyHP(enemyHp, enemyMaxHp);
                                
                                // é¡å¤–æ•ˆæœ
                                if (skill.effect) {
                                    if (skill.effect.type === 'burn') {
                                        const burnDmg = Math.floor(enemy.maxHp * skill.effect.value);
                                        if (!enemy.burns) enemy.burns = [];
                                        enemy.burns.push({ damage: burnDmg, duration: skill.effect.duration });
                                        skillMessage += ` é™„åŠ ç¼ç‡’æ•ˆæœï¼`;
                                    } else if (skill.effect.type === 'weaken') {
                                        if (!enemy.debuffs) enemy.debuffs = [];
                                        enemy.debuffs.push({ type: 'atk_down', value: skill.effect.value * 100, duration: skill.effect.duration });
                                        enemy.atk = Math.floor(enemy.atk * (1 - skill.effect.value));
                                        skillMessage += ` é™ä½æ•µäººæ”»æ“ŠåŠ›ï¼`;
                                    }
                                }
                            } else if (skill.type === 'heal') {
                                // æ²»ç™‚æŠ€èƒ½
                                const healAmount = Math.floor(gameState.player.maxHp * skill.value);
                                const actualHeal = Math.min(healAmount, gameState.player.maxHp - gameState.player.hp);
                                gameState.player.hp += actualHeal;
                                playerHp = gameState.player.hp;
                                skillMessage += ` å›å¾© ${actualHeal} é»ç”Ÿå‘½å€¼ï¼`;
                            } else if (skill.type === 'buff') {
                                // å¢ç›ŠæŠ€èƒ½
                                if (skill.stat === 'atk') {
                                    const buffValue = Math.floor(gameState.player.atk * skill.value);
                                    gameState.player.atk += buffValue;
                                    skillMessage += ` æå‡æ”»æ“ŠåŠ›ï¼`;
                                } else if (skill.stat === 'def') {
                                    const buffValue = Math.floor(gameState.player.def * skill.value);
                                    gameState.player.def += buffValue;
                                    skillMessage += ` æå‡é˜²ç¦¦åŠ›ï¼`;
                                }
                            } else if (skill.type === 'aoe') {
                                // AOEå‚·å®³
                                const aoeDamage = Math.floor(equippedPet.stats.atk * skill.multiplier);
                                enemyHp -= aoeDamage;
                                enemy.hp = enemyHp;
                                skillMessage += ` ç¾¤é«”æ”»æ“Šé€ æˆ ${aoeDamage} é»å‚·å®³ï¼`;
                                updateEnemyHP(enemyHp, enemyMaxHp);
                            } else if (skill.type === 'true_damage') {
                                // çœŸå¯¦å‚·å®³
                                const trueDamage = Math.floor(enemy.maxHp * skill.value);
                                enemyHp -= trueDamage;
                                enemy.hp = enemyHp;
                                skillMessage += ` é€ æˆ ${trueDamage} é»çœŸå¯¦å‚·å®³ï¼`;
                                updateEnemyHP(enemyHp, enemyMaxHp);
                            } else if (skill.type === 'devour') {
                                // åå™¬
                                const devourDamage = Math.floor(enemy.maxHp * skill.value);
                                enemyHp -= devourDamage;
                                enemy.hp = enemyHp;
                                const healAmount = Math.floor(devourDamage * 0.5);
                                gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                                playerHp = gameState.player.hp;
                                skillMessage += ` åå™¬é€ æˆ ${devourDamage} é»å‚·å®³ä¸¦å›å¾© ${healAmount} é»ç”Ÿå‘½ï¼`;
                                updateEnemyHP(enemyHp, enemyMaxHp);
                            }
                            
                            addLog('å¯µç‰©', skillMessage);
                            playSound('skill');
                            
                            // å¯µç‰©ç²å¾—ç¶“é©—
                            addPetExp(equippedPet.instanceId, 5);
                            
                            // æª¢æŸ¥æ•µäººæ˜¯å¦æ­»äº¡
                            if (enemyHp <= 0) {
                                clearInterval(battleInterval);
                                victory(enemy);
                                return;
                            }
                        } else {
                            // æŠ€èƒ½æœªè§¸ç™¼ï¼Œæ™®é€šæ”»æ“Š
                            const petAttack = Math.floor(equippedPet.stats.atk * 0.5);
                            enemyHp -= petAttack;
                            enemy.hp = enemyHp;
                            addLog('å¯µç‰©', `${equippedPet.icon} ${equippedPet.name} é€²è¡Œæ™®é€šæ”»æ“Šï¼Œé€ æˆ ${petAttack} é»å‚·å®³`);
                            updateEnemyHP(enemyHp, enemyMaxHp);
                            
                            // å¯µç‰©ç²å¾—å°‘é‡ç¶“é©—
                            addPetExp(equippedPet.instanceId, 2);
                            
                            // æª¢æŸ¥æ•µäººæ˜¯å¦æ­»äº¡
                            if (enemyHp <= 0) {
                                clearInterval(battleInterval);
                                victory(enemy);
                                return;
                            }
                        }
                    }
                }
                
                // æ™‚ç©ºè©ç¶´ï¼šæœ‰æ©Ÿç‡é‡ç½®å›åˆï¼ˆæ€ªç‰©å†æ¬¡æ”»æ“Šï¼‰
                if (enemy.affixEffects && enemy.affixEffects.resetChance && enemyHp > 0) {
                    if (Math.random() < enemy.affixEffects.resetChance) {
                        addLog('è©ç¶´', `â±ï¸ æ™‚ç©ºè©ç¶´è§¸ç™¼ï¼æ€ªç‰©é‡ç½®äº†å›åˆï¼`);
                        // ä¸æ›´æ–°UIï¼Œè®“æˆ°é¬¥ç¹¼çºŒä¸‹ä¸€è¼ª
                        return; // ä¸æ›´æ–°UIï¼Œç›´æ¥é€²å…¥ä¸‹ä¸€å›åˆ
                    }
                }
                
                updateUI();
            }, 1000);
        }

        // ========== æ€ªç‰©HPé¡¯ç¤ºç³»çµ± ==========
        
        function showEnemyHP(enemy) {
            const container = document.getElementById('enemy-hp-container');
            const nameDisplay = document.getElementById('enemy-name-display');
            
            // çµ„åˆæ€ªç‰©åç¨±ï¼ˆåŒ…å«è©ç¶´ã€Bossæ¨™èªŒï¼‰
            let displayName = '';
            
            // Bossæ¨™èªŒ
            if (enemy.isSpecialBoss) {
                displayName += 'ğŸ‘‘ [èè‹±Boss] ';
            } else if (enemy.isBoss) {
                displayName += 'ğŸ‘‘ [Boss] ';
            } else if (enemy.isElite) {
                displayName += 'â­ [èè‹±] ';
            } else {
                displayName += 'ğŸ‘¾ ';
            }
            
            // è©ç¶´åœ–ç¤º
            if (enemy.affixes && enemy.affixes.length > 0) {
                enemy.affixes.forEach(affix => {
                    displayName += affix.icon + ' ';
                });
            }
            
            // æ€ªç‰©åç¨±å’Œç­‰ç´š
            displayName += `${enemy.name} Lv.${enemy.level}`;
            
            nameDisplay.innerHTML = displayName;
            
            // é¡¯ç¤ºHPæ¢ï¼ˆæ»¿è¡€ï¼‰
            updateEnemyHP(enemy.hp, enemy.hp);
            
            // é¡¯ç¤ºæ€ªç‰©å±¬æ€§å’Œè©æ¢æ•ˆæœ
            displayEnemyStats(enemy);
            
            // é¡¯ç¤ºå®¹å™¨
            container.style.display = 'block';
        }
        
        function displayEnemyStats(enemy) {
            // æŸ¥æ‰¾æˆ–å‰µå»ºå±¬æ€§é¡¯ç¤ºå€åŸŸ
            let statsDisplay = document.getElementById('enemy-stats-display');
            if (!statsDisplay) {
                // å¦‚æœä¸å­˜åœ¨ï¼Œå‰µå»ºæ–°å…ƒç´ 
                const container = document.getElementById('enemy-hp-container');
                statsDisplay = document.createElement('div');
                statsDisplay.id = 'enemy-stats-display';
                statsDisplay.style.cssText = 'margin-top: 10px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 0.85rem; line-height: 1.6;';
                container.appendChild(statsDisplay);
            }
            
            // æ§‹å»ºå±¬æ€§é¡¯ç¤ºå…§å®¹
            let statsHTML = '<div style="color: #00d9ff; font-weight: bold; margin-bottom: 6px;">ğŸ“Š æ€ªç‰©å±¬æ€§</div>';
            
            // åŸºç¤å±¬æ€§
            statsHTML += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px; margin-bottom: 8px;">';
            statsHTML += `<div style="color: #ff6b6b;">âš”ï¸ æ”»æ“ŠåŠ›: <span style="color: #fff; font-weight: bold;">${enemy.atk}</span></div>`;
            statsHTML += `<div style="color: #4dabf7;">ğŸ›¡ï¸ é˜²ç¦¦åŠ›: <span style="color: #fff; font-weight: bold;">${enemy.def}</span></div>`;
            
            // æš´æ“Šå±¬æ€§ï¼ˆå¦‚æœæœ‰ï¼‰
            if (enemy.crit && enemy.crit > 0) {
                statsHTML += `<div style="color: #ffd43b;">ğŸ’¥ æš´æ“Šç‡: <span style="color: #fff; font-weight: bold;">${enemy.crit}%</span></div>`;
            }
            if (enemy.critDmg && enemy.critDmg > 150) {
                statsHTML += `<div style="color: #ff8787;">ğŸ’¢ æš´æ“Šå‚·å®³: <span style="color: #fff; font-weight: bold;">${enemy.critDmg}%</span></div>`;
            }
            statsHTML += '</div>';
            
            // å…ƒç´ å±¬æ€§
            if (enemy.element && ELEMENTS[enemy.element]) {
                const elem = ELEMENTS[enemy.element];
                statsHTML += '<div style="color: #ffd700; font-weight: bold; margin-top: 8px; margin-bottom: 6px; border-top: 1px solid rgba(255, 215, 0, 0.3); padding-top: 8px;">âœ¨ å…ƒç´ å±¬æ€§</div>';
                statsHTML += `<div style="color: ${elem.color}; font-weight: bold;">${elem.icon} ${elem.name}å…ƒç´ </div>`;
                statsHTML += `<div style="color: #b0b0b0; font-size: 0.9em; margin-top: 2px;">${elem.description}</div>`;
            }
            
            // è©æ¢æ•ˆæœ
            if (enemy.affixes && enemy.affixes.length > 0) {
                statsHTML += '<div style="color: #ffd700; font-weight: bold; margin-top: 8px; margin-bottom: 6px; border-top: 1px solid rgba(255, 215, 0, 0.3); padding-top: 8px;">âœ¨ è©æ¢æ•ˆæœ</div>';
                
                enemy.affixes.forEach(affix => {
                    statsHTML += `<div style="color: #c0c0c0; margin-bottom: 3px;">`;
                    statsHTML += `${affix.icon} <span style="color: ${affix.color};">${affix.name}</span>: ${affix.description || affix.desc || ''}`;
                    statsHTML += `</div>`;
                });
            }
            
            statsDisplay.innerHTML = statsHTML;
        }
        
        function updateEnemyHP(currentHP, maxHP) {
            const hpFill = document.getElementById('enemy-hp-fill');
            const hpText = document.getElementById('enemy-hp-text');
            
            // ç¢ºä¿HPä¸ç‚ºè² æ•¸
            currentHP = Math.max(0, currentHP);
            
            // è¨ˆç®—ç™¾åˆ†æ¯”
            const hpPercent = (currentHP / maxHP) * 100;
            
            // æ›´æ–°è¡€æ¢å¯¬åº¦
            hpFill.style.width = hpPercent + '%';
            
            // æ ¹æ“šè¡€é‡ç™¾åˆ†æ¯”æ›´æ–°é¡è‰²
            let color, shadowColor;
            if (hpPercent > 70) {
                // å¥åº·ï¼šç¶ è‰²
                color = 'linear-gradient(90deg, #4CAF50 0%, #66BB6A 100%)';
                shadowColor = 'rgba(76, 175, 80, 0.5)';
            } else if (hpPercent > 40) {
                // è­¦æˆ’ï¼šé»ƒè‰²
                color = 'linear-gradient(90deg, #ffd700 0%, #ffed4e 100%)';
                shadowColor = 'rgba(255, 215, 0, 0.5)';
            } else if (hpPercent > 20) {
                // å±éšªï¼šæ©™è‰²
                color = 'linear-gradient(90deg, #ff9800 0%, #ffb74d 100%)';
                shadowColor = 'rgba(255, 152, 0, 0.5)';
            } else {
                // ç€•æ­»ï¼šç´…è‰²
                color = 'linear-gradient(90deg, #ff4444 0%, #ff6b6b 100%)';
                shadowColor = 'rgba(255, 68, 68, 0.5)';
            }
            
            hpFill.style.background = color;
            hpFill.style.boxShadow = `0 0 10px ${shadowColor}`;
            
            // æ›´æ–°æ–‡å­—é¡¯ç¤º
            // æ‰‹æ©Ÿç‰ˆï¼šåªé¡¯ç¤ºç™¾åˆ†æ¯”
            // æ¡Œé¢ç‰ˆï¼šé¡¯ç¤ºå®Œæ•´è³‡è¨Š
            if (window.innerWidth <= 767) {
                hpText.textContent = `${Math.round(hpPercent)}%`;
            } else {
                hpText.textContent = `${currentHP}/${maxHP} (${Math.round(hpPercent)}%)`;
            }
        }
        
        function hideEnemyHP() {
            const container = document.getElementById('enemy-hp-container');
            container.style.display = 'none';
        }

        function calculateDamage(atk, def, armorPen = 0) {
            const effectiveDef = Math.floor(def * (1 - armorPen / 100));
            const baseDmg = Math.max(1, atk - effectiveDef);
            return Math.floor(baseDmg * (0.9 + Math.random() * 0.2));
        }

        // æ·»åŠ æ¶ˆè€—å“åˆ°èƒŒåŒ…ï¼ˆå †ç–Šç³»çµ±ï¼‰
        function addConsumableToInventory(consumable) {
            // å˜—è©¦æ‰¾åˆ°ç›¸åŒçš„æ¶ˆè€—å“
            const existing = gameState.inventory.find(item => {
                if (item.type !== 'consumable' || item.subtype !== consumable.subtype || item.name !== consumable.name) {
                    return false;
                }
                
                // å±¬æ€§å·éœ€è¦æ•ˆæœç›¸åŒ
                if (consumable.subtype === 'buff') {
                    return item.effect?.stat === consumable.effect?.stat;
                }
                
                // å›ºå®šæ•¸å€¼HPè—¥æ°´éœ€è¦å›å¾©é‡ç›¸åŒ
                if (consumable.subtype === 'hp_fixed') {
                    return item.recovery === consumable.recovery;
                }
                
                // å›ºå®šæ•¸å€¼APè—¥æ°´éœ€è¦å›å¾©é‡ç›¸åŒ
                if (consumable.subtype === 'ap_fixed') {
                    return item.recovery === consumable.recovery;
                }
                
                // ä¾¿ç•¶éœ€è¦HPå’ŒAPå›å¾©é‡éƒ½ç›¸åŒ
                if (consumable.subtype === 'both_fixed') {
                    return item.hpRecovery === consumable.hpRecovery && item.apRecovery === consumable.apRecovery;
                }
                
                return true;
            });
            
            if (existing) {
                // å †ç–Šï¼Œå¢åŠ æ•¸é‡
                // ç›¸å®¹æ€§è™•ç†ï¼šå¦‚æœèˆŠå­˜æª”æ²’æœ‰quantityï¼Œå‰‡è¦–ç‚º1
                existing.quantity = (existing.quantity || 1) + 1;
                return existing;
            } else {
                // æ–°æ¶ˆè€—å“ï¼Œè¨­å®šæ•¸é‡ç‚º1
                consumable.quantity = 1;
                gameState.inventory.push(consumable);
                return consumable;
            }
        }
        
        // ç›¸å®¹æ€§è™•ç†ï¼šä¿®å¾©èˆŠå­˜æª”ä¸­æ²’æœ‰quantityçš„è—¥æ°´
        function fixLegacyConsumables() {
            gameState.inventory.forEach(item => {
                // ä¿®å¾©æ‰€æœ‰æ¶ˆè€—å“çš„æ•¸æ“šçµæ§‹
                const isConsumable = item.type === 'consumable' || 
                    item.subtype === 'hp' || item.subtype === 'ap' || 
                    item.subtype === 'hp_fixed' || item.subtype === 'ap_fixed' || 
                    item.subtype === 'both_fixed' || item.subtype === 'buff' || 
                    item.subtype === 'exp' || item.subtype === 'skill_reset' || 
                    item.subtype === 'bag_expand' ||
                    // æ ¹æ“šåç¨±åˆ¤æ–·ï¼ˆå…¼å®¹èˆŠå­˜æª”ï¼‰
                    (item.name && (
                        item.name.includes('è—¥') || item.name.includes('èƒ¶å›Š') || 
                        item.name.includes('å·') || item.name.includes('æ†‘è­‰') ||
                        item.name.includes('åŒ…') || item.name.includes('ç“¶') ||
                        item.name.includes('å¥—ä»¶') || item.name.includes('å™´éœ§') ||
                        item.name.includes('æ³¨å°„') || item.name.includes('æ³¨å…¥')
                    ));
                
                if (isConsumable) {
                    // ç¢ºä¿ type æ­£ç¢º
                    if (item.type !== 'consumable') {
                        item.type = 'consumable';
                    }
                    
                    // ç¢ºä¿ id å­˜åœ¨
                    if (!item.id) {
                        item.id = Date.now() + Math.random();
                    }
                    
                    // ç¢ºä¿ quantity å­˜åœ¨
                    if (!item.quantity) {
                        item.quantity = 1;
                    }
                    
                    // æ ¹æ“šåç¨±æ¨æ¸¬ subtypeï¼ˆå¦‚æœæ²’æœ‰ï¼‰
                    if (!item.subtype) {
                        if (item.name.includes('HP') || item.name.includes('æ€¥æ•‘') || item.name.includes('ä¿®å¾©') || item.name.includes('ç¶­è­·') || item.name.includes('ç©©å®š')) {
                            item.subtype = 'hp';
                        } else if (item.name.includes('AP') || item.name.includes('èƒ½é‡') || item.name.includes('ç›¸ä½') || item.name.includes('å†—é¤˜') || item.name.includes('ç›¸å¹²')) {
                            item.subtype = 'ap';
                        } else if (item.name.includes('èª¿æ ¡') || item.name.includes('æ ¡æº–') || item.name.includes('æŒ‡ä»¤') || item.name.includes('ç–ŠåŠ ')) {
                            item.subtype = 'buff';
                        } else if (item.name.includes('ç¶“é©—') || item.name.includes('æ†‘è­‰') || item.name.includes('å ±å‘Š') || item.name.includes('ç´€éŒ„')) {
                            item.subtype = 'exp';
                        }
                    }
                    
                    // ç‚ºbuffé¡å‹ç”Ÿæˆeffectï¼ˆå¦‚æœæ²’æœ‰ï¼‰
                    if (item.subtype === 'buff' && !item.effect) {
                        // æ ¹æ“šåç¨±æ¨æ¸¬å±¬æ€§ï¼ˆç™¾åˆ†æ¯”åŠ æˆï¼‰
                        if (item.name.includes('è¼•è³ª')) {
                            // è¼•è³ªèª¿æ ¡å·ï¼šæ”»æ“Š+3%
                            item.effect = { stat: 'atk', value: 3, isPercent: true, label: 'æ”»æ“Š+3%' };
                        } else if (item.name.includes('è‡¨ç•Œæ ¡æº–')) {
                            // è‡¨ç•Œæ ¡æº–å·ï¼šæ”»æ“Š+5%
                            item.effect = { stat: 'atk', value: 5, isPercent: true, label: 'æ”»æ“Š+5%' };
                        } else if (item.name.includes('ç¡¬åŒ–')) {
                            // ç¡¬åŒ–æŒ‡ä»¤å·ï¼šé˜²ç¦¦+8%
                            item.effect = { stat: 'def', value: 8, isPercent: true, label: 'é˜²ç¦¦+8%' };
                        } else if (item.name.includes('è‡¨ç•Œç–ŠåŠ ')) {
                            // è‡¨ç•Œç–ŠåŠ å·ï¼šæ”»æ“Š+10%
                            item.effect = { stat: 'atk', value: 10, isPercent: true, label: 'æ”»æ“Š+10%' };
                        } else {
                            // é è¨­ï¼šæ”»æ“Š+3%
                            item.effect = { stat: 'atk', value: 3, isPercent: true, label: 'æ”»æ“Š+3%' };
                        }
                    }
                }
            });
        }

        function victory(enemy) {
            playSound('victory');
            trackWinStreak(); // å‹åˆ©éŸ³æ•ˆ
            gameState.stats.kills++;
            gameState.battleProgress++;
            
            // æ‡‰ç”¨æ“Šæ®ºè©ç¶´æ•ˆæœ
            applyKillSpecialEffects();
            
            // è§¸ç™¼éš¨å¾æˆ°é¬¥çµæŸæŠ€èƒ½ï¼ˆæˆ°å¾Œæ²»ç™‚ï¼‰
            const companionBattleEnd = triggerCompanionSkill('battle_end');
            if (companionBattleEnd) {
                companionBattleEnd.forEach(result => {
                    if (result.type === 'heal') {
                        addLog('éš¨å¾', result.message);
                    }
                });
            }
            
            // çå‹±ï¼ˆç‰¹æ®ŠBossçå‹±5å€ï¼‰
            const region = REGIONS[gameState.region];
            if (!region) {
                console.error('å€åŸŸä¸å­˜åœ¨:', gameState.region);
                return;
            }
            // ğŸ¯ ç²¾è‹±æ€ªç‰©çå‹±1.5å€
            const rewardMultiplier = enemy.isSpecialBoss ? 5 : (enemy.isBoss ? 3 : (enemy.isElite ? 1.5 : 1));
            
            // æ‡‰ç”¨æ€ªç‰©è©ç¶´çå‹µåŠ æˆ
            let affixGoldMult = 1;
            let affixExpMult = 1;
            let affixDropBonus = 0;
            if (enemy.rewardMultipliers) {
                affixGoldMult = enemy.rewardMultipliers.gold;
                affixExpMult = enemy.rewardMultipliers.exp;
                affixDropBonus = enemy.rewardMultipliers.drop;
            }
            
            // é™ä½é‡‘å¹£å’Œç¶“é©—çå‹µï¼ˆæå‡é›£åº¦ï¼‰
            const goldReward = Math.floor((10 + gameState.player.level * 1.2) * region.reward * rewardMultiplier * affixGoldMult); // 2 â†’ 1.2 (-40%)
            let expReward = Math.floor((20 + gameState.player.level * 3.5) * region.reward * rewardMultiplier * affixExpMult); // 5 â†’ 3.5 (-30%)
            
            // æ‡‰ç”¨è£å‚™ç¶“é©—åŠ æˆ
            if (gameState.player.expBonus && gameState.player.expBonus > 0) {
                const bonusExp = Math.floor(expReward * gameState.player.expBonus / 100);
                expReward += bonusExp;
                if (bonusExp > 0) {
                    addLog('åŠ æˆ', `â­ ç¶“é©—åŠ æˆ +${bonusExp} (ç¸½è¨ˆ ${expReward})`);
                }
            }
            
            // æ‡‰ç”¨é‡‘å¹£åŠ æˆ
            let finalGoldReward = goldReward;
            if (gameState.player.goldBonus && gameState.player.goldBonus > 0) {
                const bonusGold = Math.floor(goldReward * gameState.player.goldBonus / 100);
                finalGoldReward += bonusGold;
                if (bonusGold > 0) {
                    addLog('åŠ æˆ', `ğŸ’° é‡‘å¹£åŠ æˆ +${bonusGold} (ç¸½è¨ˆ ${finalGoldReward})`);
                }
            }
            
            gameState.player.gold += finalGoldReward;
            trackGoldGain(finalGoldReward);
            // é€£å‹ç¶“é©—åŠ æˆ
            gameState.winStreak = (gameState.winStreak || 0) + 1;
            gameState.maxWinStreak = Math.max(gameState.maxWinStreak || 0, gameState.winStreak);
            
            let streakBonus = 0;
            if (gameState.winStreak >= 10) {
                streakBonus = Math.floor(expReward * 0.5);  // 10é€£å‹ï¼š+50%
            } else if (gameState.winStreak >= 5) {
                streakBonus = Math.floor(expReward * 0.3);  // 5é€£å‹ï¼š+30%
            } else if (gameState.winStreak >= 3) {
                streakBonus = Math.floor(expReward * 0.1);  // 3é€£å‹ï¼š+10%
            }
            
            if (streakBonus > 0) {
                gameState.player.exp += streakBonus;
                addLog('é€£å‹', `ğŸ”¥ ${gameState.winStreak}é€£å‹ï¼é¡å¤–ç²å¾— ${streakBonus} ç¶“é©—ï¼`);
            }
            
            // æª¢æŸ¥é›™å€ç¶“é©—å·buff
            if (gameState.buffs && gameState.buffs.expBoost) {
                expReward = expReward * 2;
                addLog('ç‰¹æ®Š', `âœ¨ é›™å€ç¶“é©—å·ç”Ÿæ•ˆï¼ç¶“é©—ç²å¾—ç¿»å€ï¼`);
                delete gameState.buffs.expBoost; // æ¶ˆè€—buff
            }
            
            gameState.player.exp += expReward;
            trackExpGain(expReward);
            
            // éš¨å¾ç²å¾—ç¶“é©—ï¼ˆç©å®¶ç¶“é©—çš„50%ï¼‰
            if (gameState.companions && gameState.companions.active) {
                const companionExpGain = Math.floor(expReward * 0.5);
                addCompanionExp(companionExpGain);
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—é‡‘å¹£å’Œç¶“é©—
            updateQuestProgress('collect_gold', goldReward);
            updateQuestProgress('gain_exp', expReward);
            
            // è¨˜éŒ„æ€ªç‰©åœ–é‘‘ï¼ˆä½¿ç”¨åŸºç¤åç¨±ï¼Œå»é™¤è©ç¶´ï¼‰
            recordMonsterKill(enemy.name, enemy.baseName);
            
            addLog('å‹åˆ©', `æ“Šæ•—äº† ${enemy.name}ï¼ç²å¾— ${goldReward} é‡‘å¹£ã€${expReward} ç¶“é©—`, enemy.isSpecialBoss);
                    // æ¢å¾©åŸå§‹æœ€å¤§ç”Ÿå‘½å€¼
                    if (gameState.originalMaxHpBeforeCombat) { gameState.player.maxHp = gameState.originalMaxHpBeforeCombat; delete gameState.originalMaxHpBeforeCombat; }
            playSound('reward'); // çå‹µéŸ³æ•ˆ
            
            // æ‰è½è£å‚™ï¼ˆç‰¹æ®ŠBosså¿…å®šæ‰2ä»¶ï¼‰
            if (enemy.isSpecialBoss) {
                // ç‰¹æ®ŠBosså¿…å®šæ‰2ä»¶è£å‚™
                for (let i = 0; i < 2; i++) {
                const item = generateItem('boss');
                if (item && addToInventory(item)) {
                    gameState.stats.items++;
                    
                    // è¨˜éŒ„è£å‚™åœ–é‘‘
                    recordEquipmentObtained(item);
                    
                    // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
                    updateQuestProgress('collect_equipment', 1);
                    if (item.rarity === 'rare' || item.rarity === 'epic' || item.rarity === 'legendary' || item.rarity === 'set') {
                        updateQuestProgress('collect_rare', 1);
                    }
                    if (item.rarity === 'legendary') {
                        updateQuestProgress('collect_legendary', 1);
                    }
                    
                    // çµ±è¨ˆå‚³èªªè£å‚™
                    if (item.rarity === 'legendary') {
                            gameState.stats.legendaryItems = (gameState.stats.legendaryItems || 0) + 1;
                        }
                        addLog('æ‰è½', `ç‰¹æ®ŠBossæ‰è½ï¼ç²å¾—äº† ${item.name}ï¼`);
                    }
                }
            } else {
                // æ”¶é›†æ‰€æœ‰ dropBonus ä¾†æº
                let totalDropBonus = 0;
                
                // 1. è£å‚™è©ç¶´çš„ dropBonus
                const passiveBonuses = getPassiveBonuses();
                if (passiveBonuses.dropBonus) {
                    totalDropBonus += passiveBonuses.dropBonus;
                }
                
                // 2. éš¨å¾æŠ€èƒ½çš„ dropBonus
                if (gameState.player.dropBonus) {
                    totalDropBonus += gameState.player.dropBonus;
                }
                
                // 3. Buff çš„æ‰è½åŠ æˆ
                if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                    gameState.player.buffs.forEach(buff => {
                        if (buff.type === 'drop' && buff.value) {
                            totalDropBonus += buff.value;
                        }
                    });
                }
                
                // é™ä½æ‰è½ç‡ï¼ˆæå‡é›£åº¦ï¼‰
                let baseDropRate = 0.25 + affixDropBonus + totalDropBonus; // 0.35 â†’ 0.25 (-30%)
                let finalDropRate = baseDropRate;
                
                // æ‡‰ç”¨å¹¸é‹å€¼ï¼ˆå€å¢æ•ˆæœï¼‰
                if (gameState.player.luck && gameState.player.luck > 0) {
                    finalDropRate = baseDropRate * (1 + gameState.player.luck / 100);
                }
                
                if (Math.random() < finalDropRate) {
                    const enemyType = enemy.isElite ? 'elite' : 'normal';
                    const item = generateItem(enemyType);
                    if (item && addToInventory(item)) {
                        gameState.stats.items++;
                        
                        // è¨˜éŒ„è£å‚™åœ–é‘‘
                        recordEquipmentObtained(item);
                        
                        // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
                        updateQuestProgress('collect_equipment', 1);
                        if (item.rarity === 'rare' || item.rarity === 'epic' || item.rarity === 'legendary' || item.rarity === 'set') {
                            updateQuestProgress('collect_rare', 1);
                        }
                        if (item.rarity === 'legendary') {
                            updateQuestProgress('collect_legendary', 1);
                        }
                        
                        // çµ±è¨ˆå‚³èªªè£å‚™
                        if (item.rarity === 'legendary') {
                            gameState.stats.legendaryItems = (gameState.stats.legendaryItems || 0) + 1;
                        }
                        addLog('æ‰è½', `ç²å¾—äº† ${item.name}ï¼`);
                        
                        // æ•™å­¸ç³»çµ±å·²ç§»é™¤
                    }
                }
            }
            
            // æ‰è½éš¨å¾ï¼ˆèè‹±/Boss/ç‰¹æ®ŠBossï¼‰
            let companionDropChance = 0;
            let companionRarityWeights = {};
            
            if (enemy.isSpecialBoss) {
                // ç‰¹æ®ŠBossï¼š30%æ©Ÿç‡æ‰è½éš¨å¾ï¼Œå“è³ªæ¬Šé‡ï¼šCommon 40%, Fine 30%, Rare 20%, Epic 10%
                companionDropChance = 0.3;
                companionRarityWeights = {
                    'Common': 0.40,
                    'Fine': 0.30,
                    'Rare': 0.20,
                    'Epic': 0.10
                };
            } else if (enemy.isBoss) {
                // Bossï¼š25%æ©Ÿç‡æ‰è½éš¨å¾ï¼Œå“è³ªæ¬Šé‡ï¼šCommon 50%, Fine 35%, Rare 15%
                companionDropChance = 0.25;
                companionRarityWeights = {
                    'Common': 0.50,
                    'Fine': 0.35,
                    'Rare': 0.15
                };
            } else if (enemy.isElite) {
                // èè‹±ï¼š20%æ©Ÿç‡æ‰è½éš¨å¾ï¼Œå“è³ªæ¬Šé‡ï¼šCommon 60%, Fine 40%
                companionDropChance = 0.2;
                companionRarityWeights = {
                    'Common': 0.60,
                    'Fine': 0.40
                };
            }
            
            // æª¢æŸ¥æ˜¯å¦æ‰è½éš¨å¾
            if (companionDropChance > 0 && Math.random() < companionDropChance) {
                // æ ¹æ“šæ¬Šé‡é¸æ“‡å“è³ª
                const rand = Math.random();
                let cumulativeWeight = 0;
                let selectedRarity = null;
                
                for (const [rarity, weight] of Object.entries(companionRarityWeights)) {
                    cumulativeWeight += weight;
                    if (rand < cumulativeWeight) {
                        selectedRarity = rarity;
                        break;
                    }
                }
                
                if (selectedRarity) {
                    // ç²å–è©²å“è³ªçš„éš¨å¾åˆ—è¡¨
                    const availableCompanions = Object.values(COMPANIONS).filter(c => c.rarity === selectedRarity);
                    if (availableCompanions.length > 0) {
                        const randomCompanion = availableCompanions[Math.floor(Math.random() * availableCompanions.length)];
                        const alreadyOwned = gameState.companions.owned.find(c => c.id === randomCompanion.id);
                        
                        if (!alreadyOwned) {
                            obtainCompanion(randomCompanion.id);
                            const rarityColor = getRarityColor(selectedRarity);
                            const enemyType = enemy.isSpecialBoss ? 'ç‰¹æ®ŠBoss' : (enemy.isBoss ? 'Boss' : 'èè‹±');
                            addLog('éš¨å¾', `ğŸ‰ ${enemyType}æ‰è½ï¼ç²å¾—<span style="color: ${rarityColor}">${selectedRarity}</span>éš¨å¾ï¼š${randomCompanion.name}ï¼`, enemy.isSpecialBoss || enemy.isBoss);
                        }
                    }
                }
            }
            
            // æ°¸æ†éšç´šæ‰è½ï¼ˆåƒ…ç¬¬4å€åŸŸï¼‰
            if (gameState.region === 3) {
                // ç¬¬4å€åŸŸï¼šæ·±äº•è‡¨ç•Œå±¤
                const enemyLevel = enemy.level || gameState.player.level;
                
                // éš¨å¾æ‰è½æ©Ÿç‡ï¼š0.001 + (enemyLevel * 0.0001)
                const eternalCompanionChance = 0.001 + (enemyLevel * 0.0001);
                if (Math.random() < eternalCompanionChance) {
                    obtainCompanion('eternal_guardian');
                    addLog('æ°¸æ†', `ğŸŒŒ æ°¸æ†é™è‡¨ï¼ç²å¾—<span style="color: #E040FB">æ°¸æ†</span>éš¨å¾ï¼šğŸŒŒ æ™‚ç©ºå®ˆè­·è€…ï¼`, true);
                    playSound('levelup');
                }
                
                // å¡ç‰Œæ‰è½æ©Ÿç‡ï¼š0.002 + (enemyLevel * 0.0002)
                const eternalCardChance = 0.002 + (enemyLevel * 0.0002);
                if (Math.random() < eternalCardChance) {
                    getCard('eternal_thunder');
                    addLog('æ°¸æ†', `âš¡ æ°¸æ†é™è‡¨ï¼ç²å¾—<span style="color: #E040FB">æ°¸æ†</span>å¡ç‰Œï¼šâš¡ æ°¸æ†é›·éœ†ï¼`, true);
                    playSound('levelup');
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦æ‰è½éš¨å¾è£å‚™
            let equipmentDropChance = 0;
            let equipmentId = null;
            
            if (enemy.isElite) {
                // ç²¾è‹±æ€ªï¼š5%æ©Ÿç‡æ‰è½Commonè£å‚™
                equipmentDropChance = 0.05;
                if (Math.random() < equipmentDropChance) {
                    const commonEquipment = ['attack_chip', 'defense_chip', 'heal_chip'];
                    equipmentId = commonEquipment[Math.floor(Math.random() * commonEquipment.length)];
                }
            } else if (enemy.isBoss && !enemy.isSpecialBoss) {
                // æ™®é€šBossï¼š10%æ©Ÿç‡æ‰è½Rareè£å‚™
                equipmentDropChance = 0.10;
                if (Math.random() < equipmentDropChance) {
                    const rareEquipment = ['attack_core', 'defense_core', 'heal_core'];
                    equipmentId = rareEquipment[Math.floor(Math.random() * rareEquipment.length)];
                }
            } else if (enemy.isSpecialBoss) {
                // ç‰¹æ®ŠBossï¼š20%æ©Ÿç‡æ‰è½Epicè£å‚™
                equipmentDropChance = 0.20;
                if (Math.random() < equipmentDropChance) {
                    const epicEquipment = ['attack_engine', 'defense_wall', 'heal_fountain'];
                    equipmentId = epicEquipment[Math.floor(Math.random() * epicEquipment.length)];
                }
            }
            
            if (equipmentId) {
                obtainEquipment(equipmentId);
                const equipment = COMPANION_EQUIPMENT[equipmentId];
                const rarityColor = getRarityColor(equipment.rarity);
                const enemyType = enemy.isSpecialBoss ? 'ç‰¹æ®ŠBoss' : (enemy.isBoss ? 'Boss' : 'èè‹±');
                addLog('éš¨å¾', `ğŸ‰ ${enemyType}æ‰è½ï¼ç²å¾—<span style="color: ${rarityColor}">${equipment.rarity}</span>è£å‚™ï¼š${equipment.icon}${equipment.name}ï¼`, enemy.isSpecialBoss || enemy.isBoss);
            }
            
            // æ‰è½å¡ç‰Œï¼ˆæ™®é€š/èè‹±/Boss/ç‰¹æ®ŠBossï¼‰
            let cardDropChance = 0;
            let cardRarityWeights = {};
            
            if (enemy.isSpecialBoss) {
                // ç‰¹æ®ŠBossï¼š35%æ©Ÿç‡æ‰è½å¡ç‰Œ
                cardDropChance = 0.35;
                cardRarityWeights = {
                    'Common': 0.25,
                    'Fine': 0.30,
                    'Rare': 0.25,
                    'Epic': 0.15,
                    'Legendary': 0.05
                };
            } else if (enemy.isBoss) {
                // Bossï¼š25%æ©Ÿç‡æ‰è½å¡ç‰Œ
                cardDropChance = 0.25;
                cardRarityWeights = {
                    'Common': 0.40,
                    'Fine': 0.35,
                    'Rare': 0.20,
                    'Epic': 0.05
                };
            } else if (enemy.isElite) {
                // èè‹±ï¼š15%æ©Ÿç‡æ‰è½å¡ç‰Œ
                cardDropChance = 0.15;
                cardRarityWeights = {
                    'Common': 0.60,
                    'Fine': 0.35,
                    'Rare': 0.05
                };
            } else {
                // æ™®é€šæ€ªç‰©ï¼š5%æ©Ÿç‡æ‰è½å¡ç‰Œ
                cardDropChance = 0.05;
                cardRarityWeights = {
                    'Common': 0.90,
                    'Fine': 0.10
                };
            }
            
            // æª¢æŸ¥æ˜¯å¦æ‰è½å¡ç‰Œ
            if (cardDropChance > 0 && Math.random() < cardDropChance) {
                // æ ¹æ“šæ¬Šé‡é¸æ“‡å“è³ª
                const rand = Math.random();
                let cumulativeWeight = 0;
                let selectedRarity = null;
                
                for (const [rarity, weight] of Object.entries(cardRarityWeights)) {
                    cumulativeWeight += weight;
                    if (rand < cumulativeWeight) {
                        selectedRarity = rarity;
                        break;
                    }
                }
                
                if (selectedRarity) {
                    // ç²å–è©²å“è³ªçš„å¡ç‰Œåˆ—è¡¨
                    const availableCards = Object.values(CARDS).filter(c => c.rarity === selectedRarity);
                    if (availableCards.length > 0) {
                        const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
                        const alreadyOwned = gameState.cards.collection.find(c => c.id === randomCard.id);
                        
                        if (!alreadyOwned) {
                            getCard(randomCard.id);
                            const rarityColor = getRarityColor(selectedRarity);
                            const enemyType = enemy.isSpecialBoss ? 'ç‰¹æ®ŠBoss' : (enemy.isBoss ? 'Boss' : (enemy.isElite ? 'èè‹±' : 'æ™®é€šæ€ªç‰©'));
                            addLog('å¡ç‰Œ', `ğŸ´ ${enemyType}æ‰è½ï¼ç²å¾—<span style="color: ${rarityColor}">${selectedRarity}</span>å¡ç‰Œï¼š${randomCard.icon} ${randomCard.name}ï¼`, enemy.isSpecialBoss || enemy.isBoss);
                        } else {
                            // å·²æ“æœ‰ï¼Œè½‰æ›ç‚ºç¢ç‰‡
                            const shardAmount = getShardAmount(selectedRarity);
                            gameState.cards.shards[selectedRarity] = (gameState.cards.shards[selectedRarity] || 0) + shardAmount;
                            const rarityColor = getRarityColor(selectedRarity);
                            addLog('å¡ç‰Œ', `å·²æ“æœ‰ ${randomCard.icon} ${randomCard.name}ï¼Œè½‰æ›ç‚º <span style="color: ${rarityColor}">${shardAmount}</span> å€‹ç¢ç‰‡ï¼`);
                        }
                    }
                }
            }
            
            // æ‰è½å¯µç‰©è›‹ï¼ˆåªåœ¨å€åŸŸ3å’Œå€åŸŸ4ï¼‰
            if (gameState.region >= 2) { // å€åŸŸ3æ˜¯ index 2ï¼Œå€åŸŸ4æ˜¯ index 3
                let petEggDropChance = 0;
                
                if (gameState.region === 2) { // å€åŸŸ3ï¼šè³‡æ–™è£‚ç¸«
                    if (enemy.isSpecialBoss || enemy.isBoss) {
                        petEggDropChance = 0.025; // 2.5%
                    } else if (enemy.isElite) {
                        petEggDropChance = 0.005; // 0.5%
                    } else {
                        petEggDropChance = 0.0005; // 0.05%
                    }
                } else if (gameState.region === 3) { // å€åŸŸ4ï¼šæ·±äº•è‡¨ç•Œå±¤
                    if (enemy.isSpecialBoss || enemy.isBoss) {
                        petEggDropChance = 0.05; // 5.0%
                    } else if (enemy.isElite) {
                        petEggDropChance = 0.015; // 1.5%
                    } else {
                        petEggDropChance = 0.0015; // 0.15%
                    }
                }
                
                // æª¢æŸ¥æ˜¯å¦æ‰è½å¯µç‰©è›‹
                if (petEggDropChance > 0 && Math.random() < petEggDropChance) {
                    // éš¨æ©Ÿé¸æ“‡å¯µç‰©å®¶æ—
                    const families = ['dragon', 'mecha', 'void'];
                    const randomFamily = families[Math.floor(Math.random() * families.length)];
                    
                    // æ·»åŠ å¯µç‰©è›‹åˆ°èƒŒåŒ…
                    gameState.pets.eggs.push({
                        family: randomFamily,
                        hatchTime: null // ç«‹å³å­µåŒ–ï¼Œç„¡éœ€ç­‰å¾…
                    });
                    
                    const familyNames = {
                        'dragon': 'ğŸ² é¾æ—',
                        'mecha': 'ğŸ¤– æ©Ÿæ¢°æ—',
                        'void': 'ğŸ‘ï¸ è™›ç©ºæ—'
                    };
                    
                    const enemyType = enemy.isSpecialBoss ? 'ç‰¹æ®ŠBoss' : (enemy.isBoss ? 'Boss' : (enemy.isElite ? 'èè‹±' : 'æ™®é€šæ€ªç‰©'));
                    addLog('å¯µç‰©', `ğŸ¥š ${enemyType}æ‰è½ï¼ç²å¾— ${familyNames[randomFamily]} å¯µç‰©è›‹ï¼`, enemy.isSpecialBoss || enemy.isBoss);
                    
                    // æ›´æ–°ä»»å‹™é€²åº¦ï¼šæ”¶é›†å¯µç‰©ææ–™ï¼ˆå¯µç‰©è›‹è¦–ç‚ºææ–™ï¼‰
                    updateQuestProgress('collect_pet_material', 1);
                }
            }
            
            // æ‰è½æ¶ˆè€—å“
            const regionConsumables = REGION_CONSUMABLES[region.name];
            if (regionConsumables) {
                // æª¢æŸ¥å¹¸é‹ç¡¬å¹£buff
                let dropRateMultiplier = 1;
                if (gameState.buffs && gameState.buffs.luckyBoost) {
                    dropRateMultiplier = 2;
                    addLog('ç‰¹æ®Š', `ğŸ€ å¹¸é‹ç¡¬å¹£ç”Ÿæ•ˆï¼æ‰è½ç‡æå‡100%ï¼`);
                    delete gameState.buffs.luckyBoost; // æ¶ˆè€—buff
                }
                
                // HPè—¥æ°´
                if (Math.random() < regionConsumables.hp.dropRate * dropRateMultiplier) {
                    const potion = {
                        id: Date.now() + Math.random(),
                        type: 'consumable',
                        subtype: 'hp',
                        name: regionConsumables.hp.name,
                        recovery: regionConsumables.hp.recovery,
                        description: `[ç«‹å³] æ¢å¾©${Math.floor(regionConsumables.hp.recovery * 100)}%æœ€å¤§ç”Ÿå‘½å€¼`
                    };
                    const result = addConsumableToInventory(potion);
                    addLog('æ‰è½', `ç²å¾—äº† ${potion.name}ï¼ï¼ˆç¸½è¨ˆ: ${result.quantity}ï¼‰`);
                }
                
                // APè—¥æ°´
                if (Math.random() < regionConsumables.ap.dropRate * dropRateMultiplier) {
                    const potion = {
                        id: Date.now() + Math.random(),
                        type: 'consumable',
                        subtype: 'ap',
                        name: regionConsumables.ap.name,
                        recovery: regionConsumables.ap.recovery,
                        description: `[ç«‹å³] æ¢å¾©${regionConsumables.ap.recovery}é»è¡Œå‹•åŠ›`
                    };
                    const result = addConsumableToInventory(potion);
                    addLog('æ‰è½', `ç²å¾—äº† ${potion.name}ï¼ï¼ˆç¸½è¨ˆ: ${result.quantity}ï¼‰`);
                }
                
                // ç¶“é©—å·è»¸
                if (Math.random() < regionConsumables.exp.dropRate * dropRateMultiplier) {
                    const expScroll = {
                        id: Date.now() + Math.random(),
                        type: 'consumable',
                        subtype: 'exp',
                        name: regionConsumables.exp.name,
                        exp: regionConsumables.exp.exp,
                        description: `[ç«‹å³] ç²å¾—${regionConsumables.exp.exp}é»ç¶“é©—å€¼`
                    };
                    const result = addConsumableToInventory(expScroll);
                    addLog('æ‰è½', `ç²å¾—äº† ${expScroll.name}ï¼ï¼ˆç¸½è¨ˆ: ${result.quantity}ï¼‰`);
                }
                
                // å¹¸é‹ç¡¬å¹£
                if (regionConsumables.lucky && Math.random() < regionConsumables.lucky.dropRate * dropRateMultiplier) {
                    const lucky = {
                        id: Date.now() + Math.random(),
                        type: 'consumable',
                        subtype: 'lucky',
                        name: regionConsumables.lucky.name,
                        description: '[ä¸€æ¬¡æ€§] ä¸‹æ¬¡æˆ°é¬¥æ‰è½ç‡æå‡100%'
                    };
                    const result = addConsumableToInventory(lucky);
                    addLog('æ‰è½', `ç²å¾—äº† ${lucky.name}ï¼ï¼ˆç¸½è¨ˆ: ${result.quantity}ï¼‰`);
                }
                
                // é›™å€ç¶“é©—å·
                if (regionConsumables.expBoost && Math.random() < regionConsumables.expBoost.dropRate * dropRateMultiplier) {
                    const expBoost = {
                        id: Date.now() + Math.random(),
                        type: 'consumable',
                        subtype: 'expBoost',
                        name: regionConsumables.expBoost.name,
                        description: '[ä¸€æ¬¡æ€§] ä¸‹æ¬¡æˆ°é¬¥ç²å¾—é›™å€ç¶“é©—'
                    };
                    const result = addConsumableToInventory(expBoost);
                    addLog('æ‰è½', `ç²å¾—äº† ${expBoost.name}ï¼ï¼ˆç¸½è¨ˆ: ${result.quantity}ï¼‰`);
                }
                
                // ä¿è­·ç¬¦å’’
                if (regionConsumables.protection && Math.random() < regionConsumables.protection.dropRate * dropRateMultiplier) {
                    const protection = {
                        id: Date.now() + Math.random(),
                        type: 'consumable',
                        subtype: 'protection',
                        name: regionConsumables.protection.name,
                        description: '[ä¸€æ¬¡æ€§] æ­»äº¡æ™‚ä¿ç•50%ç¶“é©—å’Œé‡‘å¹£'
                    };
                    const result = addConsumableToInventory(protection);
                    addLog('æ‰è½', `ç²å¾—äº† ${protection.name}ï¼ï¼ˆç¸½è¨ˆ: ${result.quantity}ï¼‰`);
                }
            }
            
            // ç¢ç‰‡æ‰è½
            let shardsDrop = 0;
            if (enemy.isSpecialBoss) {
                // èè‹±Bossï¼š10-15 ç¢ç‰‡
                shardsDrop = Math.floor(Math.random() * 6) + 10;
            } else if (enemy.isBoss) {
                // æ™®é€šBossï¼š5-8 ç¢ç‰‡
                shardsDrop = Math.floor(Math.random() * 4) + 5;
            } else if (enemy.isElite) {
                // èè‹±æ€ªç‰©ï¼š20%æ©Ÿç‡æ‰2-3ç¢ç‰‡
                if (Math.random() < 0.2) {
                    shardsDrop = Math.floor(Math.random() * 2) + 2;
                }
            } else {
                // æ™®é€šæ€ªç‰©ï¼š5%æ©Ÿç‡æ‰1ç¢ç‰‡
                if (Math.random() < 0.05) {
                    shardsDrop = 1;
                }
            }
            
            if (shardsDrop > 0) {
                gameState.player.shards += shardsDrop;
                addLog('æ‰è½', `ç²å¾—äº† ${shardsDrop} ğŸ”· ç¢ç‰‡ï¼`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—ç¢ç‰‡
                updateQuestProgress('collect_shards', shardsDrop);
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šæ“Šæ®º
            updateQuestProgress('kill', 1);
            if (enemy.isBoss || enemy.isSpecialBoss) {
                updateQuestProgress('kill_boss', 1);
                // å€åŸŸBoss
                if (enemy.isBoss) {
                    updateQuestProgress('region_boss', 1);
                }
            }
            if (enemy.isElite) {
                updateQuestProgress('kill_elite', 1);
            }
            
            // å®Œç¾æˆ°é¬¥ï¼šæ»¿è¡€æ“Šæ•—
            if (gameState.player.hp === gameState.player.maxHp) {
                updateQuestProgress('perfect_battle', 1);
            }
            
            // æˆ°é¬¥æ¬¡æ•¸
            updateQuestProgress('battles', 1);
            updateQuestProgress('battles_same_region', 1);
            
            // é€£å‹è¿½è¹¤
            if (!gameState.stats.currentWinStreak) gameState.stats.currentWinStreak = 0;
            if (!gameState.stats.maxWinStreak) gameState.stats.maxWinStreak = 0;
            gameState.stats.currentWinStreak++;
            if (gameState.stats.currentWinStreak > gameState.stats.maxWinStreak) {
                gameState.stats.maxWinStreak = gameState.stats.currentWinStreak;
            }
            // æ›´æ–°é€£å‹ä»»å‹™é€²åº¦
            updateQuestProgress('win_streak', gameState.stats.currentWinStreak);
            
            // æª¢æŸ¥ç¨±è™Ÿè§£é–
            checkTitleUnlocks();
            
            // æ¸›å°‘æ‰€æœ‰æœ‰ duration çš„ Buff æŒçºŒæ™‚é–“
            if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                gameState.player.buffs = gameState.player.buffs.filter(buff => {
                    if (buff.duration !== undefined && buff.duration > 0) {
                        buff.duration--;
                        if (buff.duration <= 0) {
                            addLog('ç³»çµ±', `${buff.name} çš„æ•ˆæœå·²çµæŸï¼`);
                            return false; // ç§»é™¤Buff
                        }
                    }
                    return true; // ä¿ç•™Buff
                });
                // é‡æ–°è¨ˆç®—å±¬æ€§ï¼ˆå› ç‚ºBuffå¯èƒ½æœ‰è®ŠåŒ–ï¼‰
                recalculateStats();
            }
            
            // æª¢æŸ¥å‡ç´š
            if (gameState.player.exp >= gameState.player.expToNext) {
                levelUp();
            }
            
            // æ•™å­¸ç³»çµ±å·²ç§»é™¤
            
            // Bossé‡ç½®é€²åº¦
            if (enemy.isBoss) {
                gameState.battleProgress = 0;
                addLog('ç³»çµ±', 'å·²å®Œæˆæœ¬å±¤æŒ‘æˆ°ï¼é€²åº¦é‡ç½®ã€‚');
            }
            
            // æ¶ˆè€—buffæŒçºŒæ™‚é–“
            if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                gameState.player.buffs = gameState.player.buffs.map(buff => {
                    buff.duration -= 1;
                    return buff;
                }).filter(buff => buff.duration > 0);
            }
            
            updateUI();
            
            // æˆ°é¬¥å‹åˆ©å¾Œç«‹å³å­˜æª”
            saveGame();
            
            // è¨­å®šæˆ°é¬¥çµæŸå›èª¿ï¼šç­‰å¾…æ‰€æœ‰æ—¥èªŒé¡¯ç¤ºå®Œç•¢å¾ŒåŸ·è¡Œ
            battleEndCallback = () => {
                isBattleInProgress = false;
                // éš±è—æ€ªç‰©HPé¡¯ç¤º
                hideEnemyHP();
            };
            
            // å»¶é²100msæª¢æŸ¥ä½‡åˆ—ï¼Œçµ¦æ—¥èªŒæ™‚é–“åŠ å…¥ä½‡åˆ—
            setTimeout(() => {
                // å¦‚æœæ—¥èªŒä½‡åˆ—å·²ç©ºä¸”æ²’æœ‰æ­£åœ¨è™•ç†ï¼ŒåŸ·è¡Œå›èª¿
                if (logQueue.length === 0 && !isProcessingLog) {
                    const callback = battleEndCallback;
                    battleEndCallback = null;
                    if (callback) callback();
                }
            }, 100);
        }

        function defeat() {
            resetWinStreak();
            playSound('defeat'); // å¤±æ•—éŸ³æ•ˆ
            const healAmount = Math.floor(gameState.player.maxHp * 0.1);
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
            addLog('å¤±æ•—', `ä½ è¢«æ“Šæ•—äº†ï¼ç”Ÿå‘½å€¼æ™å¾©äº† ${healAmount} é» (10%)ã€‚`);
            
            // å›åˆ°å€åŸŸç¬¬ä¸€å±¤
            const currentRegion = REGIONS[gameState.region];
            if (currentRegion && gameState.battleProgress > 0) {
                addLog('ç³»çµ±', `æˆ°æ•—å¾Œå›åˆ° ${currentRegion.name} ç¬¬1å±¤`);
                gameState.battleProgress = 0;
            }
            
            // é‡ç½®é€£å‹
            if (gameState.stats.currentWinStreak && gameState.stats.currentWinStreak > 0) {
                addLog('ç³»çµ±', `é€£å‹ä¸­æ–·ï¼ä¹‹å‰é€£å‹ ${gameState.stats.currentWinStreak} å ´`);
                gameState.stats.currentWinStreak = 0;
            }
            
            // åœæ­¢è‡ªå‹•æˆ°é¬¥
            if (gameState.autoExplore) {
                stopAutoExplore();
            }
            
            // æ¶ˆè€—buffæŒçºŒæ™‚é–“
            if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                gameState.player.buffs = gameState.player.buffs.map(buff => {
                    buff.duration -= 1;
                    return buff;
                }).filter(buff => buff.duration > 0);
            }
            
            updateUI();
            
            // æˆ°é¬¥å‹åˆ©å¾Œç«‹å³å­˜æª”
            saveGame();
            
            // è¨­å®šæˆ°é¬¥çµæŸå›èª¿ï¼šç­‰å¾…æ‰€æœ‰æ—¥èªŒé¡¯ç¤ºå®Œç•¢å¾ŒåŸ·è¡Œ
            battleEndCallback = () => {
                isBattleInProgress = false;
                // éš±è—æ€ªç‰©HPé¡¯ç¤º
                hideEnemyHP();
            };
            
            // å»¶é²100msæª¢æŸ¥ä½‡åˆ—ï¼Œçµ¦æ—¥èªŒæ™‚é–“åŠ å…¥ä½‡åˆ—
            setTimeout(() => {
                // å¦‚æœæ—¥èªŒä½‡åˆ—å·²ç©ºä¸”æ²’æœ‰æ­£åœ¨è™•ç†ï¼ŒåŸ·è¡Œå›èª¿
                if (logQueue.length === 0 && !isProcessingLog) {
                    const callback = battleEndCallback;
                    battleEndCallback = null;
                    if (callback) callback();
                }
            }, 100);
        }

        function levelUp() {
            // æª¢æŸ¥ç­‰ç´šä¸Šé™
            if (gameState.player.level >= 100) {
                addLog('ç³»çµ±', 'â­ å·²é”åˆ°æœ€é«˜ç­‰ç´š Lv.100ï¼');
                gameState.player.exp = gameState.player.expToNext - 1; // é–å®šç¶“é©—å€¼
                return;
            }
            
            playSound('levelup'); // å‡ç´šéŸ³æ•ˆ
            gameState.player.level++;
            gameState.player.exp -= gameState.player.expToNext;
            // æé«˜ç¶“é©—æˆé•·ä¿‚æ•¸ï¼ˆæå‡é›£åº¦ï¼‰
            let growthRate;
            if (gameState.player.level <= 25) {
                growthRate = 1.15;  // å…¥é–€é–‹ç™¼å±¤ï¼ˆ1-25ç´šï¼‰ 1.12 â†’ 1.15
            } else if (gameState.player.level <= 50) {
                growthRate = 1.10;  // ç ”ç™¼æ ¸å¿ƒå±¤ï¼ˆ26-50ç´šï¼‰ 1.07 â†’ 1.10
            } else if (gameState.player.level <= 75) {
                growthRate = 1.08;  // è³‡æ–™è£‚ç¸«ï¼ˆ51-75ç´šï¼‰ 1.05 â†’ 1.08
            } else {
                growthRate = 1.06;  // æ·±äº•è‡¨ç•Œå±¤ï¼ˆ76-100ç´šï¼‰ 1.03 â†’ 1.06
            }
            gameState.player.expToNext = Math.floor(gameState.player.expToNext * growthRate);
            
            // é™ä½å±¬æ€§æˆé•·ï¼ˆæå‡é›£åº¦ï¼‰
            gameState.player.maxHp += 8; // 10 â†’ 8 (-20%)
            gameState.player.hp = gameState.player.maxHp;
            gameState.player.atk += 1.5; // 2 â†’ 1.5 (-25%)
            gameState.player.def += 0.8; // 1 â†’ 0.8 (-20%)
            
            addLog('å‡ç´š', `æ­å–œï¼å‡ç´šåˆ° Lv.${gameState.player.level}ï¼`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç­‰ç´š
            updateQuestProgress('level', gameState.player.level);
            
            // æª¢æŸ¥ç¨±è™Ÿè§£é–
            checkTitleUnlocks();
            
            // æª¢æŸ¥ç„¡ç›¡æ¨¡å¼è§£é–
            checkEndlessModeUnlock();
            
            updateUI();
            
            // å‡ç´šå¾Œç«‹å³å­˜æª”
            saveGame();
        }

        // ========== è£å‚™ç³»çµ± ==========
        
        // ========== è£å‚™è©ç¶´ç³»çµ± ==========
        const EQUIPMENT_AFFIXES = {
            // å‰ç¶´è©ç¶´ï¼ˆé€²æ”»å‹ï¼‰
            prefix: [
                {
                    id: 'fiery',
                    name: 'ç†¾ç†±çš„',
                    color: '#ff9800',
                    minRarity: 'Fine',
                    equipTypes: ['weapon'],
                    effect: { type: 'onHit', chance: 0.15, damageMultiplier: 0.5, element: 'fire' },
                    description: 'æ”»æ“Šæ™‚æœ‰15%æ©Ÿç‡é€ æˆé¡å¤–50%å‚·å®³ï¼ˆç¼ç‡’ï¼‰'
                },
                {
                    id: 'lightning',
                    name: 'é–ƒé›»çš„',
                    color: '#ff9800',
                    minRarity: 'Rare',
                    equipTypes: ['weapon'],
                    effect: { type: 'onHit', chance: 0.20, chainCount: 2, chainDamage: 0.3, element: 'lightning' },
                    description: 'æ”»æ“Šæ™‚æœ‰20%æ©Ÿç‡é€ æˆé€£é–å‚·å®³ï¼ˆ30%å‚·å®³Ã—2æ¬¡ï¼‰'
                },
                {
                    id: 'frost',
                    name: 'å†°éœœçš„',
                    color: '#ff9800',
                    minRarity: 'Fine',
                    equipTypes: ['weapon'],
                    effect: { type: 'onHit', chance: 0.25, slowAmount: 0.1, element: 'frost' },
                    description: 'æ”»æ“Šæ™‚æœ‰25%æ©Ÿç‡æ¸›ç·©æ•µäººï¼ˆé™ä½æ•µäºº10%æ”»æ“Šï¼‰'
                },
                {
                    id: 'bloodthirsty',
                    name: 'å—œè¡€çš„',
                    color: '#ff9800',
                    minRarity: 'Rare',
                    equipTypes: ['weapon'],
                    effect: { type: 'onKill', healPercent: 0.15 },
                    description: 'æ“Šæ®ºæ•µäººæ™‚å›å¾©15%æœ€å¤§ç”Ÿå‘½'
                },
                {
                    id: 'lethal',
                    name: 'è‡´å‘½çš„',
                    color: '#ff9800',
                    minRarity: 'Epic',
                    equipTypes: ['weapon'],
                    effect: { type: 'onLowHpEnemy', threshold: 0.3, damageBonus: 0.3 },
                    description: 'å°ç”Ÿå‘½ä½æ–¼30%çš„æ•µäººé€ æˆé¡å¤–30%å‚·å®³'
                },
                {
                    id: 'precise',
                    name: 'ç²¾æº–çš„',
                    color: '#ff9800',
                    minRarity: 'Fine',
                    equipTypes: ['weapon'],
                    effect: { type: 'onCrit', damageBonus: 0.2 },
                    description: 'æš´æ“Šæ™‚é¡å¤–é€ æˆ20%å‚·å®³'
                },
                {
                    id: 'furious',
                    name: 'ç‹‚æš´çš„',
                    color: '#ff9800',
                    minRarity: 'Rare',
                    equipTypes: ['weapon'],
                    effect: { type: 'onLowHp', threshold: 0.5, atkBonus: 0.2 },
                    description: 'ç”Ÿå‘½ä½æ–¼50%æ™‚æ”»æ“ŠåŠ›æå‡20%'
                },
                {
                    id: 'divine',
                    name: 'ç¥è–çš„',
                    color: '#ff9800',
                    minRarity: 'Legendary',
                    equipTypes: ['weapon'],
                    effect: { type: 'onHit', chance: 0.10, damageMultiplier: 1.0 },
                    description: 'æ”»æ“Šæ™‚æœ‰10%æ©Ÿç‡é€ æˆ200%å‚·å®³'
                }
            ],
            
            // å¾Œç¶´è©ç¶´ï¼ˆé˜²ç¦¦å‹ï¼‰
            suffix: [
                {
                    id: 'guardian',
                    name: 'å®ˆè­·',
                    color: '#2196f3',
                    minRarity: 'Epic',
                    equipTypes: ['armor'],
                    effect: { type: 'onLethal', chance: 0.3, cooldown: 60000 },
                    description: 'å—åˆ°è‡´å‘½å‚·å®³æ™‚æœ‰30%æ©Ÿç‡åªæ‰£1é»ç”Ÿå‘½ï¼ˆå†·å»60ç§’ï¼‰'
                },
                {
                    id: 'regeneration',
                    name: 'å†ç”Ÿ',
                    color: '#2196f3',
                    minRarity: 'Fine',
                    equipTypes: ['armor'],
                    effect: { type: 'passive', regenPercent: 0.02, interval: 5000 },
                    description: 'æ¯5ç§’å›å¾©2%æœ€å¤§ç”Ÿå‘½'
                },
                {
                    id: 'reflection',
                    name: 'åå°„',
                    color: '#2196f3',
                    minRarity: 'Rare',
                    equipTypes: ['armor'],
                    effect: { type: 'onHit', reflectPercent: 0.1 },
                    description: 'å—åˆ°å‚·å®³æ™‚åå½ˆ10%å‚·å®³çµ¦æ•µäºº'
                },
                {
                    id: 'icearmor',
                    name: 'å†°ç”²',
                    color: '#2196f3',
                    minRarity: 'Rare',
                    equipTypes: ['armor'],
                    effect: { type: 'onHit', chance: 0.2, damageReduction: 0.5 },
                    description: 'å—åˆ°æ”»æ“Šæ™‚æœ‰20%æ©Ÿç‡æ¸›å°‘50%å‚·å®³'
                },
                {
                    id: 'tide',
                    name: 'æ½®æ±',
                    color: '#2196f3',
                    minRarity: 'Epic',
                    equipTypes: ['armor'],
                    effect: { type: 'onLowHp', threshold: 0.3, defBonus: 0.5 },
                    description: 'ç”Ÿå‘½ä½æ–¼30%æ™‚é˜²ç¦¦åŠ›æå‡50%'
                },
                {
                    id: 'resilience',
                    name: 'å …éŸŒ',
                    color: '#2196f3',
                    minRarity: 'Fine',
                    equipTypes: ['armor'],
                    effect: { type: 'passive', damageReduction: 0.05 },
                    description: 'æ¸›å°‘æ‰€æœ‰å—åˆ°çš„å‚·å®³5%'
                },
                {
                    id: 'magicshield',
                    name: 'é­”ç›¾',
                    color: '#2196f3',
                    minRarity: 'Legendary',
                    equipTypes: ['armor'],
                    effect: { type: 'onBattleStart', shieldPercent: 0.2 },
                    description: 'æ¯å ´æˆ°é¬¥é–‹å§‹æ™‚ç²å¾—20%æœ€å¤§ç”Ÿå‘½çš„è­·ç›¾'
                },
                {
                    id: 'time',
                    name: 'æ™‚å…‰',
                    color: '#2196f3',
                    minRarity: 'Mythic',
                    equipTypes: ['armor'],
                    effect: { type: 'onDeath', chance: 0.15, revivePercent: 0.5, cooldown: 'perBattle' },
                    description: 'æ­»äº¡æ™‚æœ‰15%æ©Ÿç‡å¾©æ´»ä¸¦å›å¾©50%ç”Ÿå‘½ï¼ˆæ¯å ´æˆ°é¬¥1æ¬¡ï¼‰'
                }
            ],
            
            // ç‰¹æ®Šè©ç¶´ï¼ˆé£¾å“å°ˆå±¬ï¼‰
            special: [
                {
                    id: 'greedy',
                    name: 'è²ªå©ª',
                    color: '#9c27b0',
                    minRarity: 'Fine',
                    equipTypes: ['accessory'],
                    effect: { type: 'passive', goldBonus: 0.5 },
                    description: 'æ“Šæ®ºæ•µäººç²å¾—é¡å¤–50%é‡‘å¹£'
                },
                {
                    id: 'experience',
                    name: 'ç¶“é©—',
                    color: '#9c27b0',
                    minRarity: 'Fine',
                    equipTypes: ['accessory'],
                    effect: { type: 'passive', expBonus: 0.3 },
                    description: 'ç²å¾—é¡å¤–30%ç¶“é©—å€¼'
                },
                {
                    id: 'lucky',
                    name: 'å¹¸é‹',
                    color: '#9c27b0',
                    minRarity: 'Rare',
                    equipTypes: ['accessory'],
                    effect: { type: 'passive', dropBonus: 0.2 },
                    description: 'è£å‚™æ‰è½æ©Ÿç‡æå‡20%'
                },
                {
                    id: 'combo',
                    name: 'é€£æ“Š',
                    color: '#9c27b0',
                    minRarity: 'Epic',
                    equipTypes: ['accessory'],
                    effect: { type: 'onCombo', comboCount: 3, damageMultiplier: 1.0 },
                    description: 'é€£çºŒæ“Šæ®º3å€‹æ•µäººå¾Œä¸‹æ¬¡æ”»æ“Šé€ æˆé›™å€å‚·å®³'
                },
                {
                    id: 'hunter',
                    name: 'çµæ®º',
                    color: '#9c27b0',
                    minRarity: 'Rare',
                    equipTypes: ['accessory'],
                    effect: { type: 'passive', bossDamageBonus: 0.25 },
                    description: 'å°Bossé€ æˆé¡å¤–25%å‚·å®³'
                },
                {
                    id: 'stellar',
                    name: 'æ˜Ÿè¾°',
                    color: '#9c27b0',
                    minRarity: 'Legendary',
                    equipTypes: ['accessory'],
                    effect: { type: 'onKill', stackCount: 10, statBonus: 1 },
                    description: 'æ¯æ“Šæ®º10å€‹æ•µäººç²å¾—1é»å…¨å±¬æ€§ï¼ˆæœ€å¤š10å±¤ï¼‰'
                },
                {
                    id: 'alchemy',
                    name: 'ç…‰é‡‘',
                    color: '#9c27b0',
                    minRarity: 'Fine',
                    equipTypes: ['accessory'],
                    effect: { type: 'passive', potionBonus: 0.2 },
                    description: 'ä½¿ç”¨è—¥æ°´æ™‚é¡å¤–å›å¾©20%æ•ˆæœ'
                },
                {
                    id: 'rainbow',
                    name: 'å½©è™¹',
                    color: '#9c27b0',
                    minRarity: 'Mythic',
                    equipTypes: ['accessory'],
                    effect: { type: 'onBattleStart', randomBuff: true, duration: 30000 },
                    description: 'éš¨æ©Ÿç²å¾—ä¸€å€‹è‡¨æ™‚Buffï¼ˆæŒçºŒ30ç§’ï¼‰'
                }
            ]
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        
        // è£å‚™å“è³ªæ¬Šé‡ç³»çµ±
        const RARITY_WEIGHTS = {
            'normal': {  // æ™®é€šå°æ€ª
                'Common': 48,
                'Uncommon': 28,
                'Fine': 14,
                'Rare': 6,
                'Epic': 3,
                'Legendary': 0.8,
                'Mythic': 0.15,
                'Eternal': 0.05,
                'Set': 0.02
            },
            'elite': {  // èè‹±å°æ€ª
                'Common': 30,
                'Uncommon': 26,
                'Fine': 20,
                'Rare': 12,
                'Epic': 7,
                'Legendary': 3,
                'Mythic': 1.5,
                'Eternal': 0.3,
                'Set': 0.2
            },
            'boss': {  // Boss
                'Common': 10,
                'Uncommon': 18,
                'Fine': 24,
                'Rare': 22,
                'Epic': 14,
                'Legendary': 8,
                'Mythic': 3,
                'Eternal': 0.5,
                'Set': 0.5
            }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        
        // æ ¹æ“šæ¬Šé‡é¸æ“‡ç¨€æœ‰åº¦
        function selectRarityByWeight(enemyType) {
            const weights = RARITY_WEIGHTS[enemyType] || RARITY_WEIGHTS['normal'];
            const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);
            let random = Math.random() * totalWeight;
            
            let selectedRarity = 'Common';
            for (const [rarity, weight] of Object.entries(weights)) {
                random -= weight;
                if (random <= 0) {
                    selectedRarity = rarity;
                    break;
                }
            }
            
            return selectedRarity;
        }
        
        // å“è³ªåç¨±å°ç…§è¡¨
        const RARITY_NAME_MAP = {
            'common': 'Common',
            'uncommon': 'Uncommon',
            'fine': 'Fine',
            'rare': 'Rare',
            'epic': 'Epic',
            'legendary': 'Legendary',
            'mythic': 'Mythic',
            'eternal': 'Eternal',
            'set': 'Set'
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±

        // ========== è£å‚™éš¨æ©ŸåŒ–ç³»çµ± ==========
        
        // é»æ•¸è½‰æ›ç‡è¡¨
        const STAT_CONVERSION_RATES = {
            atk: 1,           // 1é» = 1æ”»æ“Š
            def: 1,           // 1é» = 1é˜²ç¦¦
            hp: 5,            // 1é» = 5ç”Ÿå‘½
            crit: 0.5,        // 1é» = 0.5%
            critDmg: 2,       // 1é» = 2%
            dmgRed: 0.3,      // 1é» = 0.3%
            lifeSteal: 0.4,   // 1é» = 0.4%
            armorPen: 0.5,    // 1é» = 0.5%
            bossDmg: 0.67     // 1é» = 0.67%
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        
        // è©æ¢æ•¸é‡ç¯„åœ
        const AFFIX_COUNT_RANGES = {
            'common': { main: [1, 2], sub: [0, 1] },
            'uncommon': { main: [1, 2], sub: [1, 1] },
            'fine': { main: [1, 2], sub: [1, 2] },
            'rare': { main: [1, 2], sub: [2, 2] },
            'epic': { main: [1, 2], sub: [2, 3] },
            'legendary': { main: [1, 2], sub: [3, 3] },
            'mythic': { main: [2, 2], sub: [3, 4] }
        };
        // è¿­ä»£å¤©è³¦ç³»çµ±
        
        // é¸æ“‡è©æ¢æ•¸é‡
        function selectAffixCount(rarity, type) {
            const ranges = AFFIX_COUNT_RANGES[rarity] || AFFIX_COUNT_RANGES['common'];
            
            // ä¸»å±¬æ€§æ•¸é‡
            let mainCount = ranges.main[0] + Math.floor(Math.random() * (ranges.main[1] - ranges.main[0] + 1));
            
            // æ ¹æ“šè£å‚™é¡å‹èª¿æ•´ä¸»å±¬æ€§æ•¸é‡
            if (type === 'weapon') {
                mainCount = 1; // æ­¦å™¨åªæœ‰æ”»æ“Šä¸€å€‹ä¸»å±¬æ€§
            } else if (type === 'armor') {
                mainCount = 2; // é˜²å…·æœ‰é˜²ç¦¦+ç”Ÿå‘½å…©å€‹ä¸»å±¬æ€§
            } else if (type === 'accessory') {
                mainCount = 1; // é£¾å“æœ‰ä¸€å€‹ä¸»å±¬æ€§ï¼ˆæ”»æ“Šæˆ–é˜²ç¦¦ï¼‰
            }
            
            // å‰¯å±¬æ€§æ•¸é‡
            const subCount = ranges.sub[0] + Math.floor(Math.random() * (ranges.sub[1] - ranges.sub[0] + 1));
            
            return { mainCount, subCount };
        }
        
        // ç²å–å¯ç”¨è©æ¢æ± 
        function getAvailableAffixes(type) {
            const attackAffixes = ['crit', 'critDmg', 'armorPen', 'bossDmg'];
            const defenseAffixes = ['dmgRed', 'lifeSteal'];
            
            if (type === 'weapon') {
                return attackAffixes;
            } else if (type === 'armor') {
                return defenseAffixes;
            } else { // accessory
                return [...attackAffixes, ...defenseAffixes];
            }
        }
        
        // é¸æ“‡è©æ¢
        function selectAffixes(type, mainCount, subCount) {
            const affixes = [];
            
            // ä¸»å±¬æ€§ï¼ˆå¿…å®šï¼‰
            if (type === 'weapon') {
                affixes.push('atk');
            } else if (type === 'armor') {
                affixes.push('def', 'hp');
            } else if (type === 'accessory') {
                // é£¾å“éš¨æ©Ÿé¸æ“‡æ”»æ“Šæˆ–é˜²ç¦¦
                affixes.push(Math.random() < 0.5 ? 'atk' : 'def');
            }
            
            // å‰¯å±¬æ€§ï¼ˆéš¨æ©Ÿï¼‰
            const availableAffixes = getAvailableAffixes(type);
            const selectedSubAffixes = [];
            
            // éš¨æ©Ÿé¸æ“‡å‰¯å±¬æ€§ï¼Œä¸é‡è¤‡
            while (selectedSubAffixes.length < subCount && availableAffixes.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableAffixes.length);
                const randomAffix = availableAffixes[randomIndex];
                
                if (!selectedSubAffixes.includes(randomAffix)) {
                    selectedSubAffixes.push(randomAffix);
                }
                
                // ç§»é™¤å·²é¸æ“‡çš„è©æ¢ï¼Œé¿å…ç„¡é™è¿´åœˆ
                availableAffixes.splice(randomIndex, 1);
            }
            
            affixes.push(...selectedSubAffixes);
            
            return affixes;
        }
        
        // åˆ†é…é»æ•¸
        function distributePoints(totalBudget, affixes, type) {
            const distribution = {};
            
            // åˆ†é›¢ä¸»å±¬æ€§å’Œå‰¯å±¬æ€§
            const mainAffixes = affixes.filter(a => ['atk', 'def', 'hp'].includes(a));
            const subAffixes = affixes.filter(a => !mainAffixes.includes(a));
            
            // ä¸»å±¬æ€§åˆ†é… 40-60% çš„é»æ•¸
            const mainBudgetRatio = 0.4 + Math.random() * 0.2; // 40-60%
            const mainBudget = Math.floor(totalBudget * mainBudgetRatio);
            
            // åœ¨ä¸»å±¬æ€§é–“åˆ†é…
            if (mainAffixes.length > 0) {
                let remainingMainBudget = mainBudget;
                
                mainAffixes.forEach((affix, index) => {
                    if (index === mainAffixes.length - 1) {
                        // æœ€å¾Œä¸€å€‹ä¸»å±¬æ€§åˆ†é…å‰©é¤˜é»æ•¸
                        distribution[affix] = remainingMainBudget;
                    } else {
                        // éš¨æ©Ÿåˆ†é…ï¼Œä½†ä¿æŒå‡è¡¡
                        const ratio = 1 / mainAffixes.length + (Math.random() - 0.5) * 0.2;
                        const points = Math.max(1, Math.floor(mainBudget * ratio));
                        distribution[affix] = points;
                        remainingMainBudget -= points;
                    }
                });
            }
            
            // å‰¯å±¬æ€§åˆ†é…å‰©é¤˜é»æ•¸
            const subBudget = totalBudget - mainBudget;
            
            if (subAffixes.length > 0) {
                let remainingSubBudget = subBudget;
                
                subAffixes.forEach((affix, index) => {
                    if (index === subAffixes.length - 1) {
                        // æœ€å¾Œä¸€å€‹å‰¯å±¬æ€§åˆ†é…å‰©é¤˜é»æ•¸
                        distribution[affix] = Math.max(1, remainingSubBudget);
                    } else {
                        // è‡³å°‘åˆ†é… 5% çš„ç¸½é»æ•¸
                        const minPoints = Math.max(1, Math.floor(totalBudget * 0.05));
                        const maxPoints = Math.floor(remainingSubBudget / (subAffixes.length - index));
                        const points = Math.max(minPoints, Math.min(maxPoints, Math.floor(minPoints + Math.random() * (maxPoints - minPoints))));
                        distribution[affix] = points;
                        remainingSubBudget -= points;
                    }
                });
            }
            
            return distribution;
        }
        
        // è½‰æ›é»æ•¸ç‚ºå±¬æ€§æ•¸å€¼
        function convertPointsToStats(pointsDistribution) {
            const stats = {
                atk: 0,
                def: 0,
                hp: 0,
                crit: 0,
                critDmg: 0,
                dmgRed: 0,
                lifeSteal: 0,
                armorPen: 0,
                bossDmg: 0
            };
            
            for (const [affix, points] of Object.entries(pointsDistribution)) {
                const rate = STAT_CONVERSION_RATES[affix] || 1;
                const value = points * rate;
                
                // æ•´æ•¸å±¬æ€§ï¼ˆatk, def, hpï¼‰å–æ•´
                if (['atk', 'def', 'hp'].includes(affix)) {
                    stats[affix] = Math.floor(value);
                } else {
                    // ç™¾åˆ†æ¯”å±¬æ€§ä¿ç•™ä¸€ä½å°æ•¸
                    stats[affix] = Math.floor(value * 10) / 10;
                }
            }
            
            return stats;
        }
        
        // æ‡‰ç”¨éš¨æ©Ÿæ³¢å‹• (Â±10%)
        function applyRandomVariation(stats) {
            const variedStats = {};
            
            for (const [stat, value] of Object.entries(stats)) {
                if (value > 0) {
                    // Â±10% éš¨æ©Ÿæ³¢å‹•
                    const variation = 0.9 + Math.random() * 0.2;
                    const variedValue = value * variation;
                    
                    // æ•´æ•¸å±¬æ€§å–æ•´
                    if (['atk', 'def', 'hp'].includes(stat)) {
                        variedStats[stat] = Math.max(1, Math.floor(variedValue));
                    } else {
                        // ç™¾åˆ†æ¯”å±¬æ€§ä¿ç•™ä¸€ä½å°æ•¸
                        variedStats[stat] = Math.max(0.1, Math.floor(variedValue * 10) / 10);
                    }
                } else {
                    variedStats[stat] = 0;
                }
            }
            
            return variedStats;
        }
        
        // è£å‚™è©ç¶´ç”Ÿæˆå‡½æ•¸
        function generateEquipmentAffix(item, rarityName) {
            // è©ç¶´æ©Ÿç‡è¡¨
            const affixChances = {
                'common': { prefix: 0, suffix: 0, special: 0 },
                'uncommon': { prefix: 0, suffix: 0, special: 0 },
                'fine': { prefix: 0.15, suffix: 0.15, special: 0.10 },
                'rare': { prefix: 0.30, suffix: 0.30, special: 0.20 },
                'epic': { prefix: 0.50, suffix: 0.50, special: 0.35 },
                'legendary': { prefix: 0.70, suffix: 0.70, special: 0.50 },
                'mythic': { prefix: 1.0, suffix: 1.0, special: 0.80 }
            };
            
            const chances = affixChances[rarityName] || affixChances['common'];
            
            // é£¾å“å„ªå…ˆç‰¹æ®Šè©ç¶´
            if (item.type === 'accessory' && Math.random() < chances.special) {
                const availableAffixes = EQUIPMENT_AFFIXES.special.filter(affix => 
                    affix.equipTypes.includes(item.type) && 
                    RARITIES.findIndex(r => r.name === rarityName) >= RARITIES.findIndex(r => r.name === affix.minRarity)
                );
                
                if (availableAffixes.length > 0) {
                    const selectedAffix = availableAffixes[Math.floor(Math.random() * availableAffixes.length)];
                    item.equipmentAffix = {
                        type: 'special',
                        data: selectedAffix
                    };
                    // æ›´æ–°è£å‚™åç¨±
                    item.name = `${selectedAffix.name}${item.name}`;
                    return;
                }
            }
            
            // å‰ç¶´è©ç¶´
            let prefixAffix = null;
            if ((item.type === 'weapon') && Math.random() < chances.prefix) {
                const availableAffixes = EQUIPMENT_AFFIXES.prefix.filter(affix => 
                    affix.equipTypes.includes(item.type) && 
                    RARITIES.findIndex(r => r.name === rarityName) >= RARITIES.findIndex(r => r.name === affix.minRarity)
                );
                
                if (availableAffixes.length > 0) {
                    prefixAffix = availableAffixes[Math.floor(Math.random() * availableAffixes.length)];
                }
            }
            
            // å¾Œç¶´è©ç¶´
            let suffixAffix = null;
            if ((item.type === 'armor') && Math.random() < chances.suffix) {
                const availableAffixes = EQUIPMENT_AFFIXES.suffix.filter(affix => 
                    affix.equipTypes.includes(item.type) && 
                    RARITIES.findIndex(r => r.name === rarityName) >= RARITIES.findIndex(r => r.name === affix.minRarity)
                );
                
                if (availableAffixes.length > 0) {
                    suffixAffix = availableAffixes[Math.floor(Math.random() * availableAffixes.length)];
                }
            }
            
            // æ‡‰ç”¨è©ç¶´
            if (prefixAffix || suffixAffix) {
                item.equipmentAffix = {
                    prefix: prefixAffix,
                    suffix: suffixAffix
                };
                
                // æ›´æ–°è£å‚™åç¨±
                let newName = item.name;
                if (prefixAffix) {
                    newName = `${prefixAffix.name}${newName}`;
                }
                if (suffixAffix) {
                    newName = `${newName} of ${suffixAffix.name}`;
                }
                item.name = newName;
            }
        }

        function generateItem(enemyType = 'normal', forceRarity = null) {
            const region = REGIONS[gameState.region];
            if (!region) {
                console.error('generateItem: regionä¸å­˜åœ¨:', gameState.region);
                return null;
            }
            // éš¨æ©Ÿé¸æ“‡ç¬¬ä¸€å¥—æˆ–ç¬¬äºŒå¥—
            const useSet2 = Math.random() < 0.5; // 50% æ©Ÿç‡é¸æ“‡ç¬¬äºŒå¥—
            const equipmentSet = useSet2 ? EQUIPMENT_SETS_2[region.name] : EQUIPMENT_SETS[region.name];
            
            // æ ¹æ“šæ•µäººé¡å‹é¸æ“‡ç¨€æœ‰åº¦ï¼ˆæˆ–ä½¿ç”¨æŒ‡å®šå“è³ªï¼‰
            const selectedRarity = forceRarity || selectRarityByWeight(enemyType);
            
            // å¦‚æœé¸ä¸­å¥—è£å“è³ªï¼Œæ‰è½å¥—è£è£å‚™
            if (selectedRarity === 'Set' && equipmentSet) {
                // æ‰è½å¥—è£è£å‚™
                const setItem = equipmentSet.items[Math.floor(Math.random() * equipmentSet.items.length)];
                const rarity = RARITIES[8]; // å¥—è£å“è³ªï¼ˆé’è‰²ï¼‰
                
                const item = {
                    id: Date.now() + Math.random(),
                    type: setItem.type,
                    name: setItem.name,
                    setName: equipmentSet.setName,
                    rarity: rarity.name,
                    rarityLabel: rarity.label,
                    color: rarity.color,
                    atk: setItem.atk || 0,
                    def: setItem.def || 0,
                    hp: setItem.hp || 0,
                    crit: setItem.crit || 0,
                    critDmg: setItem.critDmg || 0,
                    dmgRed: setItem.dmgRed || 0,
                    lifeSteal: setItem.lifeSteal || 0,
                    armorPen: setItem.armorPen || 0,
                    bossDmg: setItem.bossDmg || 0,
                    dodge: setItem.dodge || 0,      // âœ… æ–°å¢
                    reflect: setItem.reflect || 0    // âœ… æ–°å¢
                };
                
                // ===== å¥—è£è©ç¶´ç³»çµ± =====
                // å¥—è£è£å‚™æœ‰æ©Ÿç‡ç²å¾— 1-2 å€‹è©ç¶´
                const affixRoll = Math.random() * 100;
                let affixCount = 0;
                
                if (affixRoll < 10) {
                    affixCount = 2;  // 10% æ©Ÿç‡ 2 å€‹è©ç¶´
                } else if (affixRoll < 40) {
                    affixCount = 1;  // 30% æ©Ÿç‡ 1 å€‹è©ç¶´
                }
                // å¦å‰‡ 60% æ©Ÿç‡ 0 å€‹è©ç¶´
                
                if (affixCount > 0) {
                    // æ ¹æ“šè£å‚™é¡å‹æ·»åŠ è©ç¶´
                    if (item.type === 'weapon') {
                        // æ­¦å™¨æ·»åŠ å‰ç¶´
                        const availablePrefixes = EQUIPMENT_AFFIXES.prefix.filter(affix => 
                            affix.equipTypes.includes('weapon')
                        );
                        
                        item.prefixAffix = [];
                        for (let i = 0; i < affixCount && i < availablePrefixes.length; i++) {
                            const randomAffix = availablePrefixes[Math.floor(Math.random() * availablePrefixes.length)];
                            // é¿å…é‡è¤‡è©ç¶´
                            if (!item.prefixAffix.find(a => a.id === randomAffix.id)) {
                                item.prefixAffix.push(randomAffix);
                            }
                        }
                    } else if (item.type === 'armor') {
                        // é˜²å…·æ·»åŠ å¾Œç¶´
                        const availableSuffixes = EQUIPMENT_AFFIXES.suffix.filter(affix => 
                            affix.equipTypes.includes('armor')
                        );
                        
                        item.suffixAffix = [];
                        for (let i = 0; i < affixCount && i < availableSuffixes.length; i++) {
                            const randomAffix = availableSuffixes[Math.floor(Math.random() * availableSuffixes.length)];
                            // é¿å…é‡è¤‡è©ç¶´
                            if (!item.suffixAffix.find(a => a.id === randomAffix.id)) {
                                item.suffixAffix.push(randomAffix);
                            }
                        }
                    } else if (item.type === 'accessory') {
                        // é£¾å“å¯ä»¥æœ‰å‰ç¶´æˆ–å¾Œç¶´
                        const affixType = Math.random() < 0.5 ? 'prefix' : 'suffix';
                        const availableAffixes = EQUIPMENT_AFFIXES[affixType].filter(affix => 
                            affix.equipTypes.includes('weapon') || affix.equipTypes.includes('armor')
                        );
                        
                        if (affixType === 'prefix') {
                            item.prefixAffix = [];
                            for (let i = 0; i < affixCount && i < availableAffixes.length; i++) {
                                const randomAffix = availableAffixes[Math.floor(Math.random() * availableAffixes.length)];
                                if (!item.prefixAffix.find(a => a.id === randomAffix.id)) {
                                    item.prefixAffix.push(randomAffix);
                                }
                            }
                        } else {
                            item.suffixAffix = [];
                            for (let i = 0; i < affixCount && i < availableAffixes.length; i++) {
                                const randomAffix = availableAffixes[Math.floor(Math.random() * availableAffixes.length)];
                                if (!item.suffixAffix.find(a => a.id === randomAffix.id)) {
                                    item.suffixAffix.push(randomAffix);
                                }
                            }
                        }
                    }
                }
                // ===== å¥—è£è©ç¶´ç³»çµ±çµæŸ =====
                
                // ===== æ·»åŠ å…ƒç´ å±¬æ€§ =====
                const elementChance = ELEMENT_CHANCE_BY_RARITY['set'] || 50; // å¥—è£50%æ©Ÿç‡
                if (Math.random() * 100 < elementChance) {
                    const elementTypes = Object.keys(ELEMENTS);
                    const randomElement = elementTypes[Math.floor(Math.random() * elementTypes.length)];
                    item.element = randomElement;
                }
                
                return item;
            } else {
                // æ‰è½æ™®é€šè£å‚™ï¼ˆå€åŸŸå°ˆå±¬ï¼‰
                const regionLoot = REGION_LOOT[region.name];
                if (regionLoot) {
                    // å¾å€åŸŸæ‰è½è¡¨ä¸­éš¨æ©Ÿé¸æ“‡
                    const lootPools = [];
                    if (regionLoot.weapons) lootPools.push(...regionLoot.weapons);
                    if (regionLoot.armors) lootPools.push(...regionLoot.armors);
                    if (regionLoot.accessories) lootPools.push(...regionLoot.accessories);
                    
                    const lootItem = lootPools[Math.floor(Math.random() * lootPools.length)];
                    // ä½¿ç”¨æ¬Šé‡é¸æ“‡çš„ç¨€æœ‰åº¦ï¼ˆæ”¯æŒå¤§å°å¯«ï¼‰
                    const rarityIndex = {
                        'Common': 0, 'common': 0,
                        'Uncommon': 1, 'uncommon': 1,
                        'Fine': 2, 'fine': 2,
                        'Rare': 3, 'rare': 3,
                        'Epic': 4, 'epic': 4,
                        'Legendary': 5, 'legendary': 5,
                        'Mythic': 6, 'mythic': 6,
                        'Eternal': 7, 'eternal': 7
                    }[selectedRarity] || 0;
                    const rarity = RARITIES[rarityIndex];
                    
                    // æ ¹æ“šå€åŸŸé›£åº¦èª¿æ•´å±¬æ€§
                    const difficultyMult = region.difficulty;
                    
                    // åŸºç¤å±¬æ€§ç¯„åœï¼ˆéš¨æ©Ÿ + ç­‰ç´šæˆé•·ï¼‰
                    let baseAtk = 0, baseDef = 0, baseHp = 0;
                    const level = gameState.player.level;
                    if (lootItem.type === 'weapon') {
                        baseAtk = (5 + level * 0.7) + Math.random() * 15;
                    } else if (lootItem.type === 'armor') {
                        baseDef = (3 + level * 0.45) + Math.random() * 12;
                        baseHp = (12 + level * 1.6) + Math.random() * 25;
                    } else if (lootItem.type === 'accessory') {
                        baseAtk = (2 + level * 0.28) + Math.random() * 8;
                        baseDef = (2 + level * 0.28) + Math.random() * 8;
                        baseHp = (10 + level * 1.3) + Math.random() * 35;
                    }
                    
                    // æ‡‰ç”¨å“è³ªä¹˜æ•¸å’Œå€åŸŸé›£åº¦
                    const finalMult = rarity.multiplier * difficultyMult;
                    
                    // ========== ä½¿ç”¨æ–°çš„éš¨æ©ŸåŒ–ç³»çµ± ==========
                    
                    // 1. è¨ˆç®—é»æ•¸é ç®—ï¼ˆæ–°çš„å€åŸŸé»æ•¸ç³»çµ±ï¼‰
                    let regionBaseBudget = 50;  // é è¨­ï¼šå…¥é–€é–‹ç™¼å±¤
                    if (gameState.player.level >= 76) {
                        regionBaseBudget = 200;  // æ·±äº•è‡¨ç•Œå±¤
                    } else if (gameState.player.level >= 51) {
                        regionBaseBudget = 140;  // è³‡æ–™è£‚ç¸«
                    } else if (gameState.player.level >= 26) {
                        regionBaseBudget = 90;   // ç ”ç™¼æ ¸å¿ƒå±¤
                    }
                    
                    const rarityMult = {
                        'common': 0.5,
                        'uncommon': 0.7,
                        'fine': 0.9,
                        'rare': 1.2,
                        'epic': 1.5,
                        'legendary': 2.0,
                        'mythic': 2.5
                    }[rarity.name] || 1.0;
                    
                    const finalBudget = Math.floor(regionBaseBudget * rarityMult);
                    
                    // 2. ç¢ºå®šè©æ¢æ•¸é‡
                    const { mainCount, subCount } = selectAffixCount(rarity.name, lootItem.type);
                    
                    // 3. é¸æ“‡è©æ¢
                    const affixes = selectAffixes(lootItem.type, mainCount, subCount);
                    
                    // 4. åˆ†é…é»æ•¸
                    const pointsDistribution = distributePoints(finalBudget, affixes, lootItem.type);
                    
                    // 5. è½‰æ›ç‚ºæ•¸å€¼
                    const stats = convertPointsToStats(pointsDistribution);
                    
                    // 6. æ‡‰ç”¨æ³¢å‹•
                    const finalStats = applyRandomVariation(stats);
                    
                    // 7. ç”Ÿæˆè£å‚™ç‰©ä»¶
                    const item = {
                        id: Date.now() + Math.random(),
                        type: lootItem.type,
                        name: lootItem.name,
                        region: region.name, // æ·»åŠ å€åŸŸè³‡è¨Šä¾›åœ–é‘‘ä½¿ç”¨
                        rarity: rarity.name,
                        rarityLabel: rarity.label,
                        color: rarity.color,
                        atk: finalStats.atk || 0,
                        def: finalStats.def || 0,
                        hp: finalStats.hp || 0,
                        crit: finalStats.crit || 0,
                        critDmg: finalStats.critDmg || 0,
                        dmgRed: finalStats.dmgRed || 0,
                        lifeSteal: finalStats.lifeSteal || 0,
                        armorPen: finalStats.armorPen || 0,
                        bossDmg: finalStats.bossDmg || 0,
                        hpRegen: Math.random() < 0.15 ? Math.random() * 3 : 0, // 15%æ©Ÿç‡ï¼Œ0-3%
                        expBonus: Math.random() < 0.15 ? Math.random() * 20 : 0, // 15%æ©Ÿç‡ï¼Œ0-20%
                        luck: Math.random() < 0.15 ? Math.random() * 10 : 0, // 15%æ©Ÿç‡ï¼Œ0-10%
                        goldBonus: Math.random() < 0.15 ? Math.random() * 15 : 0, // 15%æ©Ÿç‡ï¼Œ0-15%
                        affixes: affixes, // å„²å­˜è©æ¢åˆ—è¡¨ä¾›é¡¯ç¤ºä½¿ç”¨
                        enhance: 0 // å¼·åŒ–ç­‰ç´š
                    };
                    
                    // ========== ç”Ÿæˆè£å‚™è©ç¶´ ==========
                    generateEquipmentAffix(item, rarity.name);
                    
                    // ========== æ·»åŠ å…ƒç´ å±¬æ€§ ==========
                    const elementChance = ELEMENT_CHANCE_BY_RARITY[rarity.name] || 0;
                    if (Math.random() * 100 < elementChance) {
                        const elementTypes = Object.keys(ELEMENTS);
                        const randomElement = elementTypes[Math.floor(Math.random() * elementTypes.length)];
                        item.element = randomElement;
                    }
                    
                    return item;
                } else {
                    // å‚™ç”¨ï¼šç„¡å€åŸŸæ‰è½è¡¨æ™‚ä½¿ç”¨é€šç”¨è£å‚™
                    const types = ['weapon', 'armor', 'accessory'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    const rarity = RARITIES[Math.floor(Math.random() * RARITIES.length)];
                    
                    const item = {
                        id: Date.now() + Math.random(),
                        type: type,
                        name: `${rarity.label}${type === 'weapon' ? 'æ­¦å™¨' : type === 'armor' ? 'é˜²å…·' : 'é£¾å“'}`,
                        rarity: rarity.name,
                        rarityLabel: rarity.label,
                        color: rarity.color,
                        atk: type === 'weapon' ? Math.floor(5 + Math.random() * 10) : 0,
                        def: type === 'armor' ? Math.floor(3 + Math.random() * 8) : 0,
                        hp: type === 'accessory' ? Math.floor(10 + Math.random() * 20) : 0
                    };
                    
                    return item;
                }
            }
        }

        // æ ¼å¼åŒ–è£å‚™å±¬æ€§é¡¯ç¤ºï¼ˆå¸¶é¡è‰²æ¨™è¨˜ï¼‰
        function formatItemStats(item, currentEquipped = null) {
            const stats = [];
            
            // å®šç¾©å±¬æ€§é¡¯ç¤ºé †åºå’Œæ ¼å¼
            const statConfig = [
                { key: 'atk', label: 'æ”»æ“Š', suffix: '' },
                { key: 'def', label: 'é˜²ç¦¦', suffix: '' },
                { key: 'hp', label: 'ç”Ÿå‘½', suffix: '' },
                { key: 'crit', label: 'æš´æ“Šç‡', suffix: '%' },
                { key: 'critDmg', label: 'æš´æ“Šå‚·å®³', suffix: '%' },
                { key: 'dmgRed', label: 'æ¸›å‚·', suffix: '%' },
                { key: 'lifeSteal', label: 'å¸è¡€', suffix: '%' },
                { key: 'armorPen', label: 'ç„¡è¦–é˜²ç¦¦', suffix: '%' },
                { key: 'bossDmg', label: 'å°é¦–é ˜å‚·å®³', suffix: '%' },
                { key: 'hpRegen', label: 'ç”Ÿå‘½å›å¾©', suffix: '%' },
                { key: 'expBonus', label: 'ç¶“é©—åŠ æˆ', suffix: '%' },
                { key: 'luck', label: 'å¹¸é‹å€¼', suffix: '%' },
                { key: 'goldBonus', label: 'é‡‘å¹£åŠ æˆ', suffix: '%' }
            ];
            
            statConfig.forEach(({ key, label, suffix }) => {
                const baseValue = item[key];
                if (baseValue && baseValue > 0) {
                    let color = '#e0e0e0'; // é è¨­ç™½è‰²
                    let comparison = '';
                    
                    // è¨ˆç®—å¼·åŒ–åŠ æˆ
                    const enhanceLevel = item.enhance || 0;
                    const enhanceBonus = enhanceLevel > 0 ? getEnhanceBonus(baseValue, enhanceLevel, key) : 0;
                    const totalValue = baseValue + enhanceBonus;
                    
                    // å¦‚æœæœ‰ç•¶å‰è£å‚™ï¼Œé¡¯ç¤ºå·®ç•°
                    if (currentEquipped) {
                        const currentEnhanced = getEnhancedStats(currentEquipped);
                        const currentValue = currentEnhanced[key] || 0;
                        const diff = totalValue - currentValue;
                        // åªæœ‰ç•¶å‰è£å‚™ä¹Ÿæœ‰é€™å€‹å±¬æ€§æ™‚æ‰é¡¯ç¤ºæ¯”è¼ƒ
                        if (currentValue > 0 && Math.abs(diff) > 0.01) {
                            const formattedDiff = suffix === '%' ? diff.toFixed(1) : Math.round(diff);
                            if (diff > 0) {
                                comparison = ` <span style="color: #4CAF50;">(+${formattedDiff}${suffix})</span>`;
                            } else if (diff < 0) {
                                comparison = ` <span style="color: #ff4444;">(${formattedDiff}${suffix})</span>`;
                            }
                        }
                    }
                    
                    // æ ¹æ“šæ˜¯å¦ç‚ºä¸»å±¬æ€§æ±ºå®šé¡è‰²
                    const isMainStat = ['atk', 'def', 'hp'].includes(key);
                    if (isMainStat) {
                        color = item.color || '#e0e0e0'; // ä¸»å±¬æ€§ä½¿ç”¨å“è³ªé¡è‰²
                    } else {
                        // å‰¯å±¬æ€§ä½¿ç”¨æ·¡è‰²
                        color = '#b0b0b0';
                    }
                    
                    // æ ¼å¼åŒ–é¡¯ç¤º
                    const formattedBase = suffix === '%' ? baseValue.toFixed(1) : Math.round(baseValue);
                    const formattedTotal = suffix === '%' ? totalValue.toFixed(1) : Math.round(totalValue);
                    
                    let statDisplay = '';
                    if (enhanceBonus > 0) {
                        // æœ‰å¼·åŒ–åŠ æˆï¼šé¡¯ç¤ºåŸºç¤å€¼ + åŠ æˆ = ç¸½å€¼
                        const formattedBonus = suffix === '%' ? enhanceBonus.toFixed(1) : Math.round(enhanceBonus);
                        statDisplay = `<span style="color: ${color};">${label}: ${formattedBase}${suffix}</span> <span style="color: #4CAF50;">+${formattedBonus}${suffix}</span> <span style="color: #e0e0e0;">= ${formattedTotal}${suffix}</span>`;
                    } else {
                        // ç„¡å¼·åŒ–ï¼šåªé¡¯ç¤ºåŸºç¤å€¼
                        statDisplay = `<span style="color: ${color};">${label}: ${formattedBase}${suffix}</span>`;
                    }
                    
                    stats.push(statDisplay + comparison);
                }
            });
            
            // é¡¯ç¤ºå…ƒç´ å±¬æ€§
            if (item.element && ELEMENTS[item.element]) {
                const elem = ELEMENTS[item.element];
                stats.push(`<br><span style="color: ${elem.color}; font-weight: bold;">${elem.icon} ${elem.name}å…ƒç´ </span>`);
                stats.push(`<span style="color: #b0b0b0; font-size: 0.9em;"> - ${elem.description}</span>`);
            }
            
            // é¡¯ç¤ºè£å‚™è©ç¶´
            if (item.equipmentAffix) {
                if (item.equipmentAffix.type === 'special') {
                    // ç‰¹æ®Šè©ç¶´
                    const affix = item.equipmentAffix.data;
                    stats.push(`<br><span style="color: ${affix.color}; font-weight: bold;">â˜… ${affix.description}</span>`);
                } else {
                    // å‰ç¶´/å¾Œç¶´
                    if (item.equipmentAffix.prefix) {
                        const affix = item.equipmentAffix.prefix;
                        stats.push(`<br><span style="color: ${affix.color};">âœ¦ ${affix.description}</span>`);
                    }
                    if (item.equipmentAffix.suffix) {
                        const affix = item.equipmentAffix.suffix;
                        stats.push(`<br><span style="color: ${affix.color};">âœ¦ ${affix.description}</span>`);
                    }
                }
            }
            
            return stats.join(' ');
        }
        
        function openEquipmentModal(slot) {
            currentEquipSlot = slot;
            const modal = document.getElementById('equipment-modal');
            const title = document.getElementById('equipment-modal-title');
            const list = document.getElementById('equipment-list');
            
            let slotType = '';
            if (slot === 'weapon') slotType = 'weapon';
            else if (slot === 'armor') slotType = 'armor';
            else slotType = 'accessory';
            
            title.textContent = `é¸æ“‡${slot === 'weapon' ? 'æ­¦å™¨' : slot === 'armor' ? 'é˜²å…·' : 'é£¾å“'}`;
            
            const items = gameState.inventory.filter(item => item.type === slotType && item.type !== 'consumable');
            const currentEquipped = gameState.player.equipment[slot];
            
            if (items.length === 0) {
                list.innerHTML = '<p style="color: #7a8fb8; text-align: center; padding: 20px;">æ²’æœ‰å¯è£å‚™çš„ç‰©å“</p>';
            } else {
                list.innerHTML = items.map(item => `
                    <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; cursor: pointer;" onclick="equipItem('${item.id}')">
                        <div style="color: ${item.color}; font-weight: bold;">${item.name} [${item.rarityLabel}]</div>
                        ${item.setName ? `<div style="font-size: 0.8rem; color: #FFD700; margin-top: 2px;">âœ¨ ${item.setName}</div>` : ''}
                        <div style="font-size: 0.85rem; margin-top: 5px; line-height: 1.6;">
                            ${formatItemStats(item, currentEquipped)}
                        </div>
                    </div>
                `).join('');
            }
            
            modal.classList.add('active');
        }

        function closeEquipmentModal() {
            document.getElementById('equipment-modal').classList.remove('active');
        }

        function equipItem(itemId) {
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            // å¸ä¸‹èˆŠè£å‚™
            const oldItem = gameState.player.equipment[currentEquipSlot];
            if (oldItem) {
                if (!addToInventory(oldItem, false)) {
                    addLog('ç³»çµ±', 'âš ï¸ èƒŒåŒ…å·²æ»¿ï¼Œç„¡æ³•è£å‚™ï¼è«‹å…ˆæ•´ç†èƒŒåŒ…ã€‚');
                    return;
                }
            }
            
            // è£å‚™æ–°è£å‚™
            gameState.player.equipment[currentEquipSlot] = item;
            gameState.inventory = gameState.inventory.filter(i => i.id != itemId);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šåˆ†è§£è£å‚™
            updateQuestProgress('salvage_equipment', 1);
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            recalculateStats();
            calculateSetEffects(); // è¨ˆç®—å¥—è£æ•ˆæœ
            updateUI();
            closeEquipmentModal();
            addLog('è£å‚™', `è£å‚™äº† ${item.name}`);
            
            // è£å‚™å¾Œç«‹å³å­˜æª”
            saveGame();
        }

        // å¿«é€Ÿè£å‚™ï¼ˆå¾èƒŒåŒ…ç›´æ¥è£å‚™ï¼‰
        function quickEquipItem(itemId, targetSlot) {
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            // å¦‚æœç›®æ¨™æ¬„ä½å·²æœ‰è£å‚™ï¼Œå¸ä¸‹åˆ°èƒŒåŒ…
            const oldItem = gameState.player.equipment[targetSlot];
            if (oldItem) {
                if (!addToInventory(oldItem, false)) {
                    addLog('ç³»çµ±', 'âš ï¸ èƒŒåŒ…å·²æ»¿ï¼Œç„¡æ³•è£å‚™ï¼è«‹å…ˆæ•´ç†èƒŒåŒ…ã€‚');
                    return;
                }
            }
            
            // è£å‚™æ–°è£å‚™
            gameState.player.equipment[targetSlot] = item;
            gameState.inventory = gameState.inventory.filter(i => i.id != itemId);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šåˆ†è§£è£å‚™
            updateQuestProgress('salvage_equipment', 1);
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            recalculateStats();
            calculateSetEffects();
            updateUI();
            closeBagModal();
            addLog("è£å‚™", `è£å‚™äº† ${item.name}`);
            
            // è£å‚™å¾Œç«‹å³å­˜æª”
            saveGame();
        }
        
        // å¸ä¸‹è£å‚™ï¼ˆå¾è£å‚™æ¬„å›åˆ°èƒŒåŒ…ï¼‰
        function unequipItem(slot) {
            const item = gameState.player.equipment[slot];
            if (!item) return;
            
            // å°‡è£å‚™æ”¾å›èƒŒåŒ…
            if (!addToInventory(item, false)) {
                addLog('ç³»çµ±', 'âš ï¸ èƒŒåŒ…å·²æ»¿ï¼Œç„¡æ³•å¸ä¸‹è£å‚™ï¼è«‹å…ˆæ•´ç†èƒŒåŒ…ã€‚');
                return;
            }
            gameState.player.equipment[slot] = null;
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            recalculateStats();
            calculateSetEffects();
            updateUI();
            addLog("è£å‚™", `å¸ä¸‹äº† ${item.name}`);
            
            // å¸ä¸‹è£å‚™å¾Œç«‹å³å­˜æª”
            saveGame();
        }

        function recalculateStats() {
            // é‡ç½®ç‚ºåŸºç¤å±¬æ€§
            const classStats = CLASSES[gameState.player.class];
            let baseAtk = classStats.atk + (gameState.player.level - 1) * 2;
            let baseDef = classStats.def + (gameState.player.level - 1) * 1;
            let baseMaxHp = classStats.hp + (gameState.player.level - 1) * 10;
            let baseCrit = classStats.crit;
            let baseCritDmg = classStats.critDmg;
            
            // åŠ ä¸Šè£å‚™å±¬æ€§ï¼ˆåŒ…å«å¼·åŒ–åŠ æˆï¼‰
            Object.values(gameState.player.equipment).forEach(item => {
                if (item) {
                    // ä½¿ç”¨getEnhancedStatsç²å–åŒ…å«å¼·åŒ–åŠ æˆçš„å±¬æ€§
                    const enhanced = getEnhancedStats(item);
                    baseAtk += enhanced.atk || 0;
                    baseDef += enhanced.def || 0;
                    baseMaxHp += enhanced.hp || 0;
                }
            });
            
            // åŠ ä¸Šå¥—è£æ•ˆæœï¼ˆç™¾åˆ†æ¯”åŠ æˆï¼‰
            if (gameState.player.setEffects) {
                if (gameState.player.setEffects.atkPercent) {
                    baseAtk = Math.floor(baseAtk * (1 + gameState.player.setEffects.atkPercent / 100));
                }
                if (gameState.player.setEffects.defPercent) {
                    baseDef = Math.floor(baseDef * (1 + gameState.player.setEffects.defPercent / 100));
                }
                if (gameState.player.setEffects.hpPercent) {
                    baseMaxHp = Math.floor(baseMaxHp * (1 + gameState.player.setEffects.hpPercent / 100));
                }
            }
            
            // åŠ ä¸Šè·æ¥­è¢«å‹•åŠ æˆ
            if (gameState.player.classBonus) {
                if (gameState.player.classBonus.bonusHp) {
                    baseMaxHp = Math.floor(baseMaxHp * (1 + gameState.player.classBonus.bonusHp / 100));
                }
                if (gameState.player.classBonus.bonusDef) {
                    baseDef = Math.floor(baseDef * (1 + gameState.player.classBonus.bonusDef / 100));
                }
                if (gameState.player.classBonus.bonusAtk) {
                    baseAtk = Math.floor(baseAtk * (1 + gameState.player.classBonus.bonusAtk / 100));
                }
                if (gameState.player.classBonus.bonusCrit) {
                    baseCrit += gameState.player.classBonus.bonusCrit;
                }
                if (gameState.player.classBonus.bonusCritDmg) {
                    baseCritDmg += gameState.player.classBonus.bonusCritDmg;
                }
            }
            
            // åŠ ä¸ŠBuffæ•ˆæœ
            if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                gameState.player.buffs.forEach(buff => {
                    // æŠ€èƒ½Buffï¼ˆç™¾åˆ†æ¯”åŠ æˆï¼‰
                    if (buff.effects) {
                        if (buff.effects.atk) {
                            baseAtk = Math.floor(baseAtk * (1 + buff.effects.atk / 100));
                        }
                        if (buff.effects.def) {
                            baseDef += buff.effects.def;
                        }
                        if (buff.effects.crit) {
                            baseCrit += buff.effects.crit;
                        }
                    }
                    
                // å±¬æ€§å·Buffï¼ˆæ”¯æŒç™¾åˆ†æ¯”å’Œå›ºå®šæ•¸å€¼ï¼‰
                if (buff.source === 'scroll' && buff.stat && buff.value !== undefined) {
                    if (buff.isPercent) {
                        // ç™¾åˆ†æ¯”åŠ æˆ
                        const percent = buff.value / 100;
                        if (buff.stat === 'atk') {
                            baseAtk += Math.floor(baseAtk * percent);
                        } else if (buff.stat === 'def') {
                            baseDef += Math.floor(baseDef * percent);
                        } else if (buff.stat === 'maxHp') {
                            baseMaxHp += Math.floor(baseMaxHp * percent);
                        } else if (buff.stat === 'crit') {
                            baseCrit += buff.value;  // æš´æ“Šç‡ç›´æ¥åŠ 
                        } else if (buff.stat === 'critDmg') {
                            baseCritDmg += buff.value;  // æš´æ“Šå‚·å®³ç›´æ¥åŠ 
                        }
                    } else {
                        // å›ºå®šæ•¸å€¼åŠ æˆï¼ˆå‘ä¸‹ç›¸å®¹ï¼‰
                        if (buff.stat === 'atk') {
                            baseAtk += buff.value;
                        } else if (buff.stat === 'def') {
                            baseDef += buff.value;
                        } else if (buff.stat === 'maxHp') {
                            baseMaxHp += buff.value;
                        } else if (buff.stat === 'crit') {
                            baseCrit += buff.value;
                        } else if (buff.stat === 'critDmg') {
                            baseCritDmg += buff.value;
                        }
                    }
                }
                });
            }
            
            gameState.player.atk = Math.floor(baseAtk);
            gameState.player.def = Math.floor(baseDef);
            gameState.player.maxHp = Math.floor(baseMaxHp);
            gameState.player.crit = baseCrit;
            gameState.player.critDmg = baseCritDmg;
            
            // è¨ˆç®—å…¶ä»–å±¬æ€§ï¼ˆè£å‚™ + å¥—è£æ•ˆæœï¼‰
            let totalDmgRed = 0, totalLifeSteal = 0, totalArmorPen = 0, totalBossDmg = 0, totalHpRegen = 0, totalExpBonus = 0, totalLuck = 0, totalGoldBonus = 0;
            
            // åŠ ä¸Šè£å‚™å±¬æ€§ï¼ˆåŒ…å«å¼·åŒ–åŠ æˆï¼‰
            Object.values(gameState.player.equipment).forEach(item => {
                if (item) {
                    const enhanced = getEnhancedStats(item);
                    if (enhanced.dmgRed) totalDmgRed += enhanced.dmgRed;
                    if (enhanced.lifeSteal) totalLifeSteal += enhanced.lifeSteal;
                    if (enhanced.armorPen) totalArmorPen += enhanced.armorPen;
                    if (enhanced.bossDmg) totalBossDmg += enhanced.bossDmg;
                    if (enhanced.hpRegen) totalHpRegen += enhanced.hpRegen;
                    if (enhanced.expBonus) totalExpBonus += enhanced.expBonus;
                    if (enhanced.luck) totalLuck += enhanced.luck;
                    if (enhanced.goldBonus) totalGoldBonus += enhanced.goldBonus;
                    if (enhanced.crit) gameState.player.crit += enhanced.crit;
                    if (enhanced.critDmg) gameState.player.critDmg += enhanced.critDmg;
                }
            });
            
            // åŠ ä¸Šå¥—è£æ•ˆæœ
            if (gameState.player.setEffects) {
                if (gameState.player.setEffects.crit) {
                    gameState.player.crit += gameState.player.setEffects.crit;
                }
                if (gameState.player.setEffects.critDmg) {
                    gameState.player.critDmg += gameState.player.setEffects.critDmg;
                }
                if (gameState.player.setEffects.dmgRed) {
                    totalDmgRed += gameState.player.setEffects.dmgRed;
                }
                if (gameState.player.setEffects.lifeSteal) {
                    totalLifeSteal += gameState.player.setEffects.lifeSteal;
                }
                if (gameState.player.setEffects.armorPen) {
                    totalArmorPen += gameState.player.setEffects.armorPen;
                }
                if (gameState.player.setEffects.bossDmg) {
                    totalBossDmg += gameState.player.setEffects.bossDmg;
                }
                if (gameState.player.setEffects.hpRegen) {
                    totalHpRegen += gameState.player.setEffects.hpRegen;
                }
                if (gameState.player.setEffects.expBonus) {
                    totalExpBonus += gameState.player.setEffects.expBonus;
                }
            }
            
            // åŠ ä¸Šéš¨å¾è¢«å‹•æŠ€èƒ½åŠ æˆ
            const companionBonuses = applyCompanionPassiveSkills();
            if (companionBonuses) {
                if (companionBonuses.atk) {
                    gameState.player.atk = Math.floor(gameState.player.atk * (1 + companionBonuses.atk / 100));
                }
                if (companionBonuses.def) {
                    gameState.player.def = Math.floor(gameState.player.def * (1 + companionBonuses.def / 100));
                }
                if (companionBonuses.hp) {
                    gameState.player.maxHp = Math.floor(gameState.player.maxHp * (1 + companionBonuses.hp / 100));
                }
                if (companionBonuses.crit) {
                    gameState.player.crit += companionBonuses.crit;
                }
                if (companionBonuses.critDmg) {
                    gameState.player.critDmg += companionBonuses.critDmg;
                }
                if (companionBonuses.dmgRed) {
                    totalDmgRed += companionBonuses.dmgRed;
                }
                if (companionBonuses.lifeSteal) {
                    totalLifeSteal += companionBonuses.lifeSteal;
                }
            }
            
            // åŠ ä¸Šå¡ç‰ŒåŠ æˆ
            const cardBonuses = applyCardBonuses();
            if (cardBonuses) {
                if (cardBonuses.atk) {
                    gameState.player.atk = Math.floor(gameState.player.atk * (1 + cardBonuses.atk / 100));
                }
                if (cardBonuses.def) {
                    gameState.player.def = Math.floor(gameState.player.def * (1 + cardBonuses.def / 100));
                }
                if (cardBonuses.hp) {
                    gameState.player.maxHp = Math.floor(gameState.player.maxHp * (1 + cardBonuses.hp / 100));
                }
                if (cardBonuses.crit) {
                    gameState.player.crit += cardBonuses.crit;
                }
                if (cardBonuses.critDmg) {
                    gameState.player.critDmg += cardBonuses.critDmg;
                }
                if (cardBonuses.dmgRed) {
                    totalDmgRed += cardBonuses.dmgRed;
                }
                if (cardBonuses.lifeSteal) {
                    totalLifeSteal += cardBonuses.lifeSteal;
                }
            }
            
            // æ‡‰ç”¨å±¬æ€§ä¸Šé™ï¼ˆé¿å…ç ´å£å¹³è¡¡ï¼‰
            gameState.player.crit = Math.min(gameState.player.crit, 75); // æš´æ“Šç‡ä¸Šé™ 75%
            gameState.player.dmgRed = Math.min(totalDmgRed, 75); // æ¸›å‚·ä¸Šé™ 75%
            gameState.player.lifeSteal = Math.min(totalLifeSteal, 50); // å¸è¡€ä¸Šé™ 50%
            gameState.player.armorPen = Math.min(totalArmorPen, 75); // ç„¡è¦–é˜²ç¦¦ä¸Šé™ 75%
            gameState.player.bossDmg = Math.min(totalBossDmg, 100); // å°é¦–é ˜å‚·å®³ä¸Šé™ 100%
            gameState.player.hpRegen = Math.min(totalHpRegen, 10); // ç”Ÿå‘½å›å¾©ä¸Šé™ 10%
            gameState.player.expBonus = Math.min(totalExpBonus, 100); // ç¶“é©—åŠ æˆä¸Šé™ 100%
            gameState.player.luck = Math.min(totalLuck, 100); // å¹¸é‹å€¼ä¸Šé™ 100%
            gameState.player.goldBonus = Math.min(totalGoldBonus, 200); // é‡‘å¹£åŠ æˆä¸Šé™ 200%
            
            // ä¿å­˜å±¬æ€§åˆ†è§£æ•¸æ“šï¼ˆç”¨æ–¼UIé¡¯ç¤ºï¼‰
            if (!gameState.player.statsBreakdown) {
                gameState.player.statsBreakdown = {};
            }
            
            // è¨ˆç®—åŸºç¤å±¬æ€§ï¼ˆä¸å«è£å‚™ï¼‰
            const pureBaseAtk = classStats.atk + (gameState.player.level - 1) * 2;
            const pureBaseDef = classStats.def + (gameState.player.level - 1) * 1;
            const pureBaseMaxHp = classStats.hp + (gameState.player.level - 1) * 10;
            const pureBaseCrit = classStats.crit;
            const pureBaseCritDmg = classStats.critDmg;
            
            // è¨ˆç®—è£å‚™åŠ æˆ
            let equipAtk = 0, equipDef = 0, equipHp = 0, equipCrit = 0, equipCritDmg = 0;
            Object.values(gameState.player.equipment).forEach(item => {
                if (item) {
                    equipAtk += item.atk || 0;
                    equipDef += item.def || 0;
                    equipHp += item.hp || 0;
                    equipCrit += item.crit || 0;
                    equipCritDmg += item.critDmg || 0;
                }
            });
            
            gameState.player.statsBreakdown = {
                atk: { base: pureBaseAtk, equipment: equipAtk },
                def: { base: pureBaseDef, equipment: equipDef },
                maxHp: { base: pureBaseMaxHp, equipment: equipHp },
                crit: { base: pureBaseCrit, equipment: equipCrit },
                critDmg: { base: pureBaseCritDmg, equipment: equipCritDmg },
                dmgRed: { base: 0, equipment: totalDmgRed },
                lifeSteal: { base: 0, equipment: totalLifeSteal },
                armorPen: { base: 0, equipment: totalArmorPen },
                bossDmg: { base: 0, equipment: totalBossDmg },
                hpRegen: { base: 0, equipment: totalHpRegen },
                expBonus: { base: 0, equipment: totalExpBonus }
            };
            
            // æ‡‰ç”¨å¤©è³¦åŠ æˆ
            applyTalentBonuses();
            
            // æ‡‰ç”¨ç¨±è™ŸåŠ æˆ
            applyTitleBonuses();
            
            gameState.player.hp = Math.min(gameState.player.hp, gameState.player.maxHp);
        }

        // ========== UIæ›´æ–° ==========
        function updateUI() {
            // æ¯æ¬¡UIæ›´æ–°æ™‚éƒ½æª¢æŸ¥ä¸¦æ¢å¾©è³‡æº
            checkAndRecoverResources();
            
            // è§’è‰²è³‡è¨Š
            document.getElementById('player-name').textContent = gameState.player.name;
            document.getElementById('player-class').textContent = gameState.player.class;
            document.getElementById('player-level').textContent = gameState.player.level;
            
            // æ›´æ–°è·æ¥­è¢«å‹•é¡¯ç¤º
            updateClassBonusDisplay();
            
            // æ›´æ–°æŠ€èƒ½æ•ˆæœé¡¯ç¤º
            updateSkillEffectDisplay();
            
            // ç›®å‰ç¨±è™Ÿé¡¯ç¤º
            const currentTitleBadge = document.getElementById('current-title-badge');
            const currentTitleName = document.getElementById('current-title-name');
            if (gameState.titles && gameState.titles.equipped) {
                const titleData = TITLES_DATA[gameState.titles.equipped];
                if (titleData) {
                    currentTitleName.textContent = titleData.name;
                    currentTitleBadge.style.display = 'block';
                } else {
                    currentTitleBadge.style.display = 'none';
                }
            } else {
                currentTitleBadge.style.display = 'none';
            }
            document.getElementById('player-exp').textContent = `${gameState.player.exp}/${gameState.player.expToNext}`;
            document.getElementById('player-hp').textContent = `${gameState.player.hp}/${gameState.player.maxHp}`;
            document.getElementById('player-hp-bar').style.width = `${(gameState.player.hp / gameState.player.maxHp) * 100}%`;
            document.getElementById('player-ap').textContent = `${gameState.player.ap}/${gameState.player.maxAp}`;
            
            // æ›´æ–°é«”åŠ›æ¢å’Œç¶“é©—æ¢å¯¬åº¦
            const apBar = document.getElementById('player-ap-bar');
            if (apBar) {
                apBar.style.width = `${(gameState.player.ap / gameState.player.maxAp) * 100}%`;
            }
            const expBar = document.getElementById('player-exp-bar');
            if (expBar) {
                expBar.style.width = `${(gameState.player.exp / gameState.player.expToNext) * 100}%`;
            }
            
            // é«”åŠ›å›å¾©å€’æ•¸è¨ˆæ™‚
            const apTimerElement = document.getElementById('ap-timer');
            if (gameState.player.ap < gameState.player.maxAp) {
                const now = Date.now();
                const timeElapsed = now - gameState.apRegenTime;
                const timeRemaining = 120000 - timeElapsed; // 2åˆ†é˜ = 120000æ¯«ç§’
                const minutes = Math.floor(timeRemaining / 60000);
                const seconds = Math.floor((timeRemaining % 60000) / 1000);
                apTimerElement.textContent = `(${minutes}:${seconds.toString().padStart(2, '0')})`;
            } else {
                apTimerElement.textContent = '';
            }
            document.getElementById('player-gold').textContent = gameState.player.gold;
            document.getElementById('player-shards').textContent = gameState.player.shards;
            
            // æ›´æ–°ææ–™é¡¯ç¤º
            if (!gameState.materials) {
                gameState.materials = { enhanceStone: 0, reforgeStone: 0 };
            }
            document.getElementById('player-enhance-stone').textContent = gameState.materials.enhanceStone || 0;
            document.getElementById('player-reforge-stone').textContent = gameState.materials.reforgeStone || 0;
            
            // å±¬æ€§ï¼ˆè¨ˆç®—BuffåŠ æˆï¼‰
            let buffAtk = 0, buffDef = 0, buffCrit = 0;
            if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                gameState.player.buffs.forEach(buff => {
                    // è·³éå±¬æ€§å·Buffï¼ˆå·²åœ¨recalculateStatsä¸­è™•ç†ï¼‰
                    if (buff.source === 'scroll') return;
                    
                    if (buff.effects && buff.effects.atk) {
                        const classStats = CLASSES[gameState.player.class];
                        let baseAtk = classStats.atk + (gameState.player.level - 1) * 2;
                        Object.values(gameState.player.equipment).forEach(item => {
                            if (item) baseAtk += item.atk;
                        });
                        if (gameState.player.setEffects) baseAtk += gameState.player.setEffects.atk;
                        if (gameState.player.classBonus && gameState.player.classBonus.bonusAtk) {
                            baseAtk = Math.floor(baseAtk * (1 + gameState.player.classBonus.bonusAtk / 100));
                        }
                        buffAtk += Math.floor(baseAtk * buff.effects.atk / 100);
                    }
                    if (buff.effects && buff.effects.def) buffDef += buff.effects.def;
                    if (buff.effects && buff.effects.crit) buffCrit += buff.effects.crit;
                });
            }
            
            // è¨ˆç®—å±¬æ€§å·BuffåŠ æˆ
            let scrollBuffAtk = 0, scrollBuffDef = 0, scrollBuffMaxHp = 0;
            if (gameState.player.buffs && gameState.player.buffs.length > 0) {
                gameState.player.buffs.forEach(buff => {
                    if (buff.source === 'scroll' && buff.stat && buff.value !== undefined) {
                        const classStats = CLASSES[gameState.player.class];
                        let baseValue = 0;
                        
                        if (buff.stat === 'atk') {
                            baseValue = classStats.atk + (gameState.player.level - 1) * 2;
                            // åŠ ä¸Šè£å‚™
                            Object.values(gameState.player.equipment).forEach(item => {
                                if (item) {
                                    const enhanced = getEnhancedStats(item);
                                    baseValue += enhanced.atk || 0;
                                }
                            });
                            // åŠ ä¸Šå¥—è£
                            if (gameState.player.setEffects && gameState.player.setEffects.atkPercent) {
                                baseValue = Math.floor(baseValue * (1 + gameState.player.setEffects.atkPercent / 100));
                            }
                            if (buff.isPercent) {
                                scrollBuffAtk += Math.floor(baseValue * buff.value / 100);
                            } else {
                                scrollBuffAtk += buff.value;
                            }
                        } else if (buff.stat === 'def') {
                            baseValue = classStats.def + (gameState.player.level - 1) * 1;
                            Object.values(gameState.player.equipment).forEach(item => {
                                if (item) {
                                    const enhanced = getEnhancedStats(item);
                                    baseValue += enhanced.def || 0;
                                }
                            });
                            if (gameState.player.setEffects && gameState.player.setEffects.defPercent) {
                                baseValue = Math.floor(baseValue * (1 + gameState.player.setEffects.defPercent / 100));
                            }
                            if (buff.isPercent) {
                                scrollBuffDef += Math.floor(baseValue * buff.value / 100);
                            } else {
                                scrollBuffDef += buff.value;
                            }
                        } else if (buff.stat === 'maxHp') {
                            baseValue = classStats.hp + (gameState.player.level - 1) * 10;
                            Object.values(gameState.player.equipment).forEach(item => {
                                if (item) {
                                    const enhanced = getEnhancedStats(item);
                                    baseValue += enhanced.hp || 0;
                                }
                            });
                            if (gameState.player.setEffects && gameState.player.setEffects.hpPercent) {
                                baseValue = Math.floor(baseValue * (1 + gameState.player.setEffects.hpPercent / 100));
                            }
                            if (buff.isPercent) {
                                scrollBuffMaxHp += Math.floor(baseValue * buff.value / 100);
                            } else {
                                scrollBuffMaxHp += buff.value;
                            }
                        }
                    }
                });
            }
            
            // å±¬æ€§é¡¯ç¤ºï¼ˆå«åŸºç¤å’Œè£å‚™åŠ æˆåˆ†è§£ï¼‰
            const breakdown = gameState.player.statsBreakdown || {};
            
            // æ”»æ“ŠåŠ›ï¼ˆåªé¡¯ç¤ºæœ€çµ‚ç¸½å€¼ï¼‰
            document.getElementById('player-atk').textContent = Math.round(gameState.player.atk);
            
            // é˜²ç¦¦åŠ›ï¼ˆåªé¡¯ç¤ºæœ€çµ‚ç¸½å€¼ï¼‰
            document.getElementById('player-def').textContent = Math.round(gameState.player.def);
            
            // æš´æ“Šç‡ï¼ˆåªé¡¯ç¤ºæœ€çµ‚ç¸½å€¼ï¼‰
            const critValue = parseFloat(gameState.player.crit.toFixed(1));
            document.getElementById('player-crit').textContent = `${critValue}%`;
            
            // æš´æ“Šå‚·å®³ï¼ˆåªé¡¯ç¤ºæœ€çµ‚ç¸½å€¼ï¼‰
            const critDmgValue = parseFloat(gameState.player.critDmg.toFixed(1));
            document.getElementById('player-critdmg').textContent = `${critDmgValue}%`;
            
            // æ–°å¢å±¬æ€§é¡¯ç¤ºï¼ˆåªé¡¯ç¤ºæœ€çµ‚ç¸½å€¼ï¼‰
            const dmgRedValue = gameState.player.dmgRed.toFixed(1);
            document.getElementById('player-dmgred').textContent = `${dmgRedValue}%`;
            
            const lifeStealValue = gameState.player.lifeSteal.toFixed(1);
            document.getElementById('player-lifesteal').textContent = `${lifeStealValue}%`;
            
            const armorPenValue = gameState.player.armorPen.toFixed(1);
            document.getElementById('player-armorpen').textContent = `${armorPenValue}%`;
            
            const bossDmgValue = gameState.player.bossDmg.toFixed(1);
            document.getElementById('player-bossdmg').textContent = `${bossDmgValue}%`;
            
            const hpRegenValue = (gameState.player.hpRegen || 0).toFixed(1);
            document.getElementById('player-hpregen').textContent = `${hpRegenValue}%`;
            
            const expBonusValue = (gameState.player.expBonus || 0).toFixed(1);
            document.getElementById('player-expbonus').textContent = `${expBonusValue}%`;
            
            // å¹¸é‹å€¼
            document.getElementById('player-luck').textContent = `${(gameState.player.luck || 0).toFixed(1)}%`;
            
            // é‡‘å¹£åŠ æˆ
            document.getElementById('player-goldbonus').textContent = `${(gameState.player.goldBonus || 0).toFixed(1)}%`;
            
            // è£å‚™
            updateEquipmentSlots();
            
            // å€åŸŸè³‡è¨Š
            const region = REGIONS[gameState.region];
            document.getElementById('current-region').textContent = region.name;
            document.getElementById('battle-progress').textContent = `${gameState.battleProgress}/10`;
            document.getElementById('difficulty').textContent = `Ã—${region.difficulty.toFixed(1)}`;
            
            // çµ±è¨ˆ
            document.getElementById('stat-kills').textContent = gameState.stats.kills;
            document.getElementById('stat-items').textContent = gameState.stats.items;
            
            // èƒŒåŒ…æ•¸é‡
            const maxInv = gameState.maxInventory || 50;
            document.getElementById('bag-count').textContent = `${gameState.inventory.length}/${maxInv}`;
            
            // æ›´æ–°è—¥æ°´é¸æ“‡å™¨
            updatePotionSelector();
            
            // æ›´æ–°å¢ç›Šç‹€æ…‹é¡¯ç¤º
            updateBuffsDisplay();
            
            // æ›´æ–°éš¨å¾é¡¯ç¤º
            updateCompanionDisplay();
            
            // æ›´æ–°å¡ç‰Œé¡¯ç¤º
            updateCardSlotsDisplay();
            
            // æŒ‰éˆ•ç‹€æ…‹

        }
        // æ›´æ–°è·æ¥­è¢«å‹•é¡¯ç¤º
        function updateClassBonusDisplay() {
            const classBonusText = document.getElementById('class-bonus-text');
            if (!classBonusText) return;
            
            const className = gameState.player.class;
            const classData = CLASSES[className];
            
            if (!classData) {
                classBonusText.textContent = 'ç„¡';
                return;
            }
            
            const bonuses = [];
            if (classData.bonusHp) bonuses.push(`+${classData.bonusHp} HP`);
            if (classData.bonusAtk) bonuses.push(`+${classData.bonusAtk} ATK`);
            if (classData.bonusDef) bonuses.push(`+${classData.bonusDef} DEF`);
            if (classData.bonusCrit) bonuses.push(`+${classData.bonusCrit}% CRIT`);
            if (classData.bonusCritDmg) bonuses.push(`+${classData.bonusCritDmg}% CRITDMG`);
            
            classBonusText.textContent = bonuses.length > 0 ? `æ¯ç´š ${bonuses.join(', ')}` : 'ç„¡ç‰¹æ®ŠåŠ æˆ';
        }
        
        // æ›´æ–°æŠ€èƒ½æ•ˆæœé¡¯ç¤º
        function updateSkillEffectDisplay() {
            const skillEffectText = document.getElementById('skill-effect-text');
            if (!skillEffectText) return;
            
            const skillName = gameState.player.skill;
            
            if (!skillName) {
                skillEffectText.textContent = 'æœªé¸æ“‡æŠ€èƒ½';
                return;
            }
            
            const skill = SKILLS[skillName];
            
            if (!skill) {
                skillEffectText.textContent = 'æœªçŸ¥æŠ€èƒ½';
                return;
            }
            
            skillEffectText.textContent = `${skillName}: ${skill.desc}`;
        }
        
        function updateBuffsDisplay() {
            const buffsContainer = document.getElementById('buffs-container');
            const buffsList = document.getElementById('buffs-list');
            
            if (!gameState.player.buffs || gameState.player.buffs.length === 0) {
                buffsContainer.style.display = 'none';
                return;
            }
            
            buffsContainer.style.display = 'block';
            
            // æŒ‰é¡å‹åˆ†çµ„
            const buffsByType = {};
            const scrollBuffs = []; // å±¬æ€§å·Buff
            
            gameState.player.buffs.forEach(buff => {
                if (buff.source === 'scroll') {
                    scrollBuffs.push(buff);
                } else if (buff.type) {
                    if (!buffsByType[buff.type]) {
                        buffsByType[buff.type] = [];
                    }
                    buffsByType[buff.type].push(buff);
                }
            });
            
            let html = '';
            
            // å±¬æ€§å·Buff
            if (scrollBuffs.length > 0) {
                scrollBuffs.forEach(buff => {
                    const icon = {
                        'atk': 'âš”ï¸',
                        'def': 'ğŸ›¡ï¸',
                        'maxHp': 'â¤ï¸',
                        'crit': 'âš¡',
                        'critDmg': 'ğŸ’¥'
                    }[buff.stat] || 'ğŸ“œ';
                    html += `<div style="display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">
                        <span>${icon} ${buff.name}</span>
                        <span style="color: #00ff88;">${buff.label} (å‰©é¤˜${buff.duration}æˆ°)</span>
                    </div>`;
                });
            }
            

            
            // æ”»æ“Šå¢ç›Š
            if (buffsByType['atk']) {
                buffsByType['atk'].forEach(buff => {
                    const value = buff.value > 0 ? `+${Math.floor(buff.value * 100)}%` : `${Math.floor(buff.value * 100)}%`;
                    html += `<div style="display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">
                        <span>ğŸ’¥ ${buff.name}</span>
                        <span style="color: #00ff88;">æ”»æ“Š${value} (å‰©é¤˜${buff.duration}æˆ°)</span>
                    </div>`;
                });
            }
            
            // é˜²ç¦¦å¢ç›Š
            if (buffsByType['def']) {
                buffsByType['def'].forEach(buff => {
                    const value = buff.value > 0 ? `+${Math.floor(buff.value * 100)}%` : `${Math.floor(buff.value * 100)}%`;
                    html += `<div style="display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">
                        <span>ğŸ›¡ï¸ ${buff.name}</span>
                        <span style="color: #00ff88;">é˜²ç¦¦${value} (å‰©é¤˜${buff.duration}æˆ°)</span>
                    </div>`;
                });
            }
            
            // çˆ†æ“Šå¢ç›Š
            if (buffsByType['crit']) {
                buffsByType['crit'].forEach(buff => {
                    const value = buff.value > 0 ? `+${buff.value}%` : `${buff.value}%`;
                    html += `<div style="display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">
                        <span>âš¡ ${buff.name}</span>
                        <span style="color: #00ff88;">çˆ†æ“Š${value} (å‰©é¤˜${buff.duration}æˆ°)</span>
                    </div>`;
                });
            }
            
            // æ‰è½å¢ç›Š
            if (buffsByType['drop']) {
                buffsByType['drop'].forEach(buff => {
                    const value = `+${Math.floor(buff.value * 100)}%`;
                    html += `<div style="display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">
                        <span>ğŸ€ ${buff.name}</span>
                        <span style="color: #00ff88;">æ‰è½${value} (å‰©é¤˜${buff.duration}æˆ°)</span>
                    </div>`;
                });
            }
            
            // ç¶“é©—å¢ç›Š
            if (buffsByType['exp']) {
                buffsByType['exp'].forEach(buff => {
                    const value = `+${Math.floor(buff.value * 100)}%`;
                    html += `<div style="display: flex; justify-content: space-between; padding: 3px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">
                        <span>ğŸ“š ${buff.name}</span>
                        <span style="color: #00ff88;">ç¶“é©—${value} (å‰©é¤˜${buff.duration}æˆ°)</span>
                    </div>`;
                });
            }
            
            buffsList.innerHTML = html;
            
            // è¿­ä»£æŒ‰éˆ•é¡¯ç¤ºï¼ˆç­‰ç´š100ä¸”å®Œæˆæ‰€æœ‰Bossæ™‚é¡¯ç¤ºï¼‰
            const iterationBtn = document.getElementById('iteration-btn');
            const quickIterationBtn = document.getElementById('quick-iteration-btn');
            if (gameState.player.level >= 100 && checkAllBossesCompleted()) {
                if (iterationBtn) iterationBtn.style.display = 'block';
                if (quickIterationBtn) quickIterationBtn.style.display = 'block';
            } else {
                if (iterationBtn) iterationBtn.style.display = 'none';
                if (quickIterationBtn) quickIterationBtn.style.display = 'none';
            }
        }

        function updateEquipmentSlots() {
            // è¨ˆç®—å¥—è£ä»¶æ•¸
            const setCount = {};
            ['weapon', 'armor', 'accessory1', 'accessory2'].forEach(slot => {
                const item = gameState.player.equipment[slot];
                if (item && item.setName) {
                    setCount[item.setName] = (setCount[item.setName] || 0) + 1;
                }
            });
            const hasSetBonus = Object.values(setCount).some(count => count >= 2);
            
            ['weapon', 'armor', 'accessory1', 'accessory2'].forEach(slot => {
                const item = gameState.player.equipment[slot];
                const element = document.getElementById(`equip-${slot}`);
                const slotElement = element.closest('.equipment-slot');
                
                // ç§»é™¤èˆŠçš„class
                slotElement.classList.remove('set-bonus');
                
                if (item) {
                    // å¼·åŒ–ç­‰ç´šé¡¯ç¤º
                    const enhanceLevel = item.enhance || 0;
                    const enhanceDisplay = enhanceLevel > 0 ? ` <span style="color: #ffd700;">+${enhanceLevel}</span>` : '';
                    
                    // ç²å–å¼·åŒ–å¾Œçš„å±¬æ€§
                    const enhanced = getEnhancedStats(item);
                    
                    // å±¬æ€§é¡¯ç¤ºï¼ˆæ‰€æœ‰å±¬æ€§ï¼‰
                    let statsHtml = '';
                    const statConfig = [
                        { key: 'atk', label: 'æ”»æ“Š', suffix: '' },
                        { key: 'def', label: 'é˜²ç¦¦', suffix: '' },
                        { key: 'hp', label: 'ç”Ÿå‘½', suffix: '' },
                        { key: 'crit', label: 'æš´æ“Šç‡', suffix: '%' },
                        { key: 'critDmg', label: 'æš´æ“Šå‚·', suffix: '%' },
                        { key: 'dmgRed', label: 'æ¸›å‚·', suffix: '%' },
                        { key: 'lifeSteal', label: 'å¸è¡€', suffix: '%' },
                        { key: 'armorPen', label: 'ç„¡è¦–é˜²ç¦¦', suffix: '%' },
                        { key: 'bossDmg', label: 'å°é¦–é ˜å‚·å®³', suffix: '%' },
                        { key: 'hpRegen', label: 'ç”Ÿå‘½å›å¾©', suffix: '%' },
                        { key: 'expBonus', label: 'ç¶“é©—åŠ æˆ', suffix: '%' }
                    ];
                    
                    statConfig.forEach(({ key, label, suffix }) => {
                        if (item[key] && item[key] > 0) {
                            const baseValue = item[key];
                            const enhancedValue = enhanced[key];
                            const bonus = enhancedValue - baseValue;
                            
                            const formattedBase = suffix === '%' ? baseValue.toFixed(1) : Math.round(baseValue);
                            const formattedEnhanced = suffix === '%' ? enhancedValue.toFixed(1) : Math.round(enhancedValue);
                            const formattedBonus = suffix === '%' ? bonus.toFixed(1) : Math.round(bonus);
                            
                            if (enhanceLevel > 0 && bonus > 0) {
                                statsHtml += `<div style="font-size: 0.75rem; color: #e0e0e0;">${label}: ${formattedBase}${suffix} <span style="color: #4CAF50;">+${formattedBonus}${suffix}</span> = ${formattedEnhanced}${suffix}</div>`;
                            } else {
                                statsHtml += `<div style="font-size: 0.75rem; color: #e0e0e0;">${label}: ${formattedEnhanced}${suffix}</div>`;
                            }
                        }
                    });
                    
                    element.innerHTML = `
                        <div style="cursor: pointer;" onclick="unequipItem('${slot}')">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: ${item.color}">${item.name}${enhanceDisplay}</span>
                                <span style="font-size: 0.8rem; color: #00d9ff;">â†»</span>
                            </div>
                            ${statsHtml}
                        </div>
                    `;
                    element.style.cursor = 'pointer';
                    
                    // å¦‚æœæ˜¯å¥—è£è£å‚™ä¸”æœ‰å¥—è£æ•ˆæœï¼Œæ·»åŠ ç¶ è‰²å…‰åœˆ
                    if (item.setName && hasSetBonus) {
                        slotElement.classList.add('set-bonus');
                    }
                } else {
                    element.innerHTML = '<span style="color: #5a6b8f;">ç©º</span>';
                    element.style.cursor = 'default';
                }
            });
            
            // æ›´æ–°å¥—è£æ•ˆæœé¡¯ç¤º
            updateSetEffectDisplay();
            
            // æ›´æ–°è£å‚™ç‰¹æ®Šæ•ˆæœé¡¯ç¤º
            updateSpecialEffectsDisplay();
        }
        
        function updateSetEffectDisplay() {
            const setEffectText = document.getElementById('set-effect-text');
            const player = gameState.player;
            
            if (!player.setEffects || !player.setEffects.setCount) {
                setEffectText.textContent = 'ç„¡';
                setEffectText.style.color = '#7a8fb8';
                return;
            }
            
            const setCount = player.setEffects.setCount;
            const activeSets = Object.entries(setCount).filter(([name, count]) => count >= 2);
            
            if (activeSets.length === 0) {
                setEffectText.textContent = 'ç„¡';
                setEffectText.style.color = '#7a8fb8';
                return;
            }
            
            // é¡¯ç¤ºæ‰€æœ‰æ¿€æ´»çš„å¥—è£æ•ˆæœï¼ˆé¡¯ç¤ºå…·é«”èƒ½åŠ›å€¼ï¼‰
            const stats = [];
            if (player.setEffects.atkPercent > 0) stats.push(`æ”»æ“Š+${player.setEffects.atkPercent}%`);
            if (player.setEffects.defPercent > 0) stats.push(`é˜²ç¦¦+${player.setEffects.defPercent}%`);
            if (player.setEffects.crit > 0) stats.push(`æš´æ“Šç‡+${player.setEffects.crit}%`);
            if (player.setEffects.critDmg > 0) stats.push(`æš´æ“Šå‚·+${player.setEffects.critDmg}%`);
            if (player.setEffects.dmgRed > 0) stats.push(`æ¸›å‚·+${player.setEffects.dmgRed}%`);
            if (player.setEffects.lifeSteal > 0) stats.push(`å¸è¡€+${player.setEffects.lifeSteal}%`);
            if (player.setEffects.armorPen > 0) stats.push(`ç„¡è¦–é˜²ç¦¦+${player.setEffects.armorPen}%`);
            if (player.setEffects.bossDmg > 0) stats.push(`å°é¦–é ˜å‚·å®³+${player.setEffects.bossDmg}%`);
            
            if (stats.length > 0) {
                setEffectText.textContent = stats.join('ã€');
                setEffectText.style.color = '#00ff88';
            } else {
                setEffectText.textContent = 'ç„¡';
                setEffectText.style.color = '#7a8fb8';
            }
        }
        
        // æ›´æ–°è£å‚™ç‰¹æ®Šæ•ˆæœé¡¯ç¤º
        function updateSpecialEffectsDisplay() {
            const specialEffectsList = document.getElementById('special-effects-list');
            const player = gameState.player;
            
            if (!player.equipment) {
                specialEffectsList.innerHTML = 'ç„¡';
                return;
            }
            
            const specialEffects = [];
            
            // æª¢æŸ¥æ¯ä»¶è£å‚™çš„ç‰¹æ®Šæ•ˆæœï¼ˆå¾ equipmentAffix ä¸­è®€å–ï¼‰
            Object.entries(player.equipment).forEach(([slot, item]) => {
                if (item && item.equipmentAffix) {
                    const slotName = {
                        'weapon': 'ğŸ—¡ï¸ æ­¦å™¨',
                        'armor': 'ğŸ›¡ï¸ é˜²å…·',
                        'accessory1': 'ğŸ’ é£¾å“1',
                        'accessory2': 'ğŸ’ é£¾å“2'
                    }[slot] || slot;
                    
                    // ç‰¹æ®Šè©ç¶´ï¼ˆé£¾å“å°ˆå±¬ï¼‰
                    if (item.equipmentAffix.type === 'special' && item.equipmentAffix.data) {
                        const data = item.equipmentAffix.data;
                        if (data.description) {
                            specialEffects.push(`<div style="margin-bottom: 3px;">
                                <span style="color: #ff8800;">${slotName}</span>: 
                                <span style="color: #ffd700;">${data.description}</span>
                            </div>`);
                        }
                    }
                    
                    // å‰ç¶´è©ç¶´ï¼ˆæ­¦å™¨ï¼‰
                    if (item.equipmentAffix.prefix && item.equipmentAffix.prefix.description) {
                        specialEffects.push(`<div style="margin-bottom: 3px;">
                            <span style="color: #ff8800;">${slotName}</span>: 
                            <span style="color: #ffd700;">${item.equipmentAffix.prefix.description}</span>
                        </div>`);
                    }
                    
                    // å¾Œç¶´è©ç¶´ï¼ˆé˜²å…·ï¼‰
                    if (item.equipmentAffix.suffix && item.equipmentAffix.suffix.description) {
                        specialEffects.push(`<div style="margin-bottom: 3px;">
                            <span style="color: #ff8800;">${slotName}</span>: 
                            <span style="color: #ffd700;">${item.equipmentAffix.suffix.description}</span>
                        </div>`);
                    }
                }
            });
            
            if (specialEffects.length > 0) {
                specialEffectsList.innerHTML = specialEffects.join('');
            } else {
                specialEffectsList.innerHTML = 'ç„¡';
            }
        }


        // è™•ç†è¢«å‹•å†ç”Ÿæ•ˆæœ
        function applyPassiveRegen() {
            const player = gameState.player;
            const equipment = player.equipment;
            const now = Date.now();
            
            if (!player.passiveTimers) player.passiveTimers = {};
            
            for (const slot in equipment) {
                const item = equipment[slot];
                if (!item) continue;
                
                // æª¢æŸ¥å¾Œç¶´æ•ˆæœ
                if (item.equipmentAffix && item.equipmentAffix.suffix && item.equipmentAffix.suffix.effect) {
                    const effect = item.equipmentAffix.suffix.effect;
                    
                    // å†ç”Ÿæ•ˆæœ
                    if (effect.type === 'passive' && effect.regenPercent && effect.interval) {
                        const timerKey = `regen_${slot}`;
                        if (!player.passiveTimers[timerKey] || now - player.passiveTimers[timerKey] > effect.interval) {
                            const healAmount = Math.floor(player.maxHp * effect.regenPercent);
                            player.hp = Math.min(player.hp + healAmount, player.maxHp);
                            player.passiveTimers[timerKey] = now;
                            addLog('å†ç”Ÿ', `ğŸ’š å†ç”Ÿæ•ˆæœï¼å›å¾© ${healAmount} é»ç”Ÿå‘½å€¼`);
                            updateUI();
                        }
                    }
                }
            }
        }

        function updateGameTime() {
            const minutes = Math.floor((Date.now() - gameState.stats.startTime) / 60000);
            document.getElementById('stat-time').textContent = `${minutes}åˆ†é˜`;
        }

        // ========== æ—¥èªŒç³»çµ± ==========
        // æ—¥èªŒä½‡åˆ—ç³»çµ±
        let logQueue = [];
        let isProcessingLog = false;
        let isBattleInProgress = false; // è¿½è¹¤æˆ°é¬¥æ˜¯å¦é€²è¡Œä¸­
        let battleEndCallback = null; // æˆ°é¬¥çµæŸå¾Œçš„å›èª¿å‡½æ•¸

        function addLog(type, message, isSpecialBoss = false) {
            // å®šç¾©éœ€è¦æ’éšŠçš„æ—¥èªŒé¡å‹ï¼ˆé‡è¦è¨Šæ¯ï¼‰
            const queuedTypes = ['é­é‡', 'å‹åˆ©', 'å¤±æ•—', 'æ‰è½', 'å‡ç´š', 'ç³»çµ±', 'ä¼‘æ¯', 'ä½¿ç”¨', 'åˆ†è§£', 'å•†åº—'];
            
            if (queuedTypes.includes(type)) {
                // é‡è¦è¨Šæ¯ï¼šåŠ å…¥ä½‡åˆ—ï¼Œæœ‰é–“éš”é¡¯ç¤º
                logQueue.push({ type, message, isSpecialBoss });
                
                // å¦‚æœæ²’æœ‰æ­£åœ¨è™•ç†ï¼Œé–‹å§‹è™•ç†ä½‡åˆ—
                if (!isProcessingLog) {
                    processLogQueue();
                }
            } else {
                // æˆ°é¬¥æ—¥èªŒï¼ˆæ”»æ“Šã€æŠ€èƒ½ç­‰ï¼‰ï¼šå³æ™‚é¡¯ç¤º
                displayLog(type, message, isSpecialBoss);
            }
        }

        function processLogQueue() {
            if (logQueue.length === 0) {
                isProcessingLog = false;
                
                // å¦‚æœæœ‰æˆ°é¬¥çµæŸå›èª¿ï¼ŒåŸ·è¡Œå®ƒ
                if (battleEndCallback) {
                    const callback = battleEndCallback;
                    battleEndCallback = null;
                    callback();
                }
                return;
            }
            
            isProcessingLog = true;
            const { type, message, isSpecialBoss } = logQueue.shift();
            
            // é¡¯ç¤ºæ—¥èªŒ
            displayLog(type, message, isSpecialBoss);
            
            // 0.5ç§’å¾Œè™•ç†ä¸‹ä¸€æ¢ï¼ˆé‡è¦è¨Šæ¯é–“éš”ï¼‰
            setTimeout(() => {
                processLogQueue();
            }, 500);
        }

        function displayLog(type, message, isSpecialBoss = false) {
            const log = document.getElementById('battle-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            
            // æ ¹æ“šé¡å‹å’Œå…§å®¹è¨­å®šé¡è‰²å’Œåœ–ç¤º
            let color = '#7a8fb8';
            let icon = 'â„¹ï¸';
            let fontWeight = 'normal';
            
            // å„ªå…ˆåˆ¤æ–·ç‰¹æ®Šå…§å®¹
            if (message.includes('æš´æ“Š') || message.includes('ğŸ’¥')) {
                color = '#ff4444';
                fontWeight = 'bold';
                icon = 'ğŸ’¥';
            } else if (message.includes('å¸è¡€') || message.includes('ğŸ©¸')) {
                color = '#ff69b4';
                icon = 'ğŸ©¸';
            } else if (type === 'é­é‡' || type === 'æ€ªç‰©' || type === 'é‡æ•µ') {
                color = '#ffd700';
                icon = 'ğŸ‘¾';
            } else if (type === 'æˆ°é¬¥' || type === 'æ”»æ“Š') {
                color = '#e0e0e0';
                icon = 'âš”ï¸';
            } else if (type === 'æŠ€èƒ½') {
                color = '#00d9ff';
                icon = 'âš¡';
            } else if (type === 'å‹åˆ©') {
                color = '#00ff88';
                icon = 'âœ…';
            } else if (message.includes('ç²å¾—äº†') && (message.includes('(') || message.includes('ï¼‰'))) {
                // è£å‚™æ‰è½
                color = '#d946ef';
                icon = 'ğŸ';
            } else if (type === 'æ‰è½') {
                color = '#d946ef';
                icon = 'ğŸ';
            } else if (type === 'å‡ç´š') {
                color = '#ffa500';
                fontWeight = 'bold';
                icon = 'â­';
            } else if (type === 'å¤±æ•—' || type === 'æ­»äº¡') {
                color = '#ff4444';
                icon = 'âŒ';
            } else if (type === 'è£å‚™' || message.includes('è£å‚™') || message.includes('å¸ä¸‹')) {
                color = '#d946ef';
                icon = 'ğŸ½';
            } else if (type === 'æ¶ˆè€—å“' || message.includes('è—¥æ°´') || message.includes('å·è»¸')) {
                color = '#00ff88';
                icon = 'ğŸ§ª';
            } else if (type === 'ç³»çµ±') {
                color = '#999999';
                icon = 'ğŸ’»';
            } else if (type === 'ä½¿ç”¨') {
                color = '#00ff88';
                icon = 'âœ¨';
            } else if (type === 'ä¼‘æ¯') {
                color = '#4EA5FF';
                icon = 'ğŸ’¤';
            } else if (type === 'åˆ†è§£') {
                color = '#9E9E9E';
                icon = 'â™»ï¸';
            } else if (type === 'å•†åº—') {
                color = '#FFD700';
                icon = 'ğŸª';
            } else if (type === 'é‡‘å¹£' || message.includes('é‡‘å¹£') || message.includes('ğŸ’°')) {
                color = '#ffd700';
                icon = 'ğŸ’°';
            } else if (type === 'ç¶“é©—' || message.includes('ç¶“é©—') || message.includes('EXP')) {
                color = '#00d9ff';
                icon = 'â¬†ï¸';
            }
            
            // ç‰¹æ®ŠBossä½¿ç”¨æ›´å¤§å­—é«”
            const fontSize = isSpecialBoss ? '1.3rem' : 'inherit';
            if (isSpecialBoss) fontWeight = 'bold';
            
            entry.innerHTML = `
                <div class="log-time" style="color: ${color};">${icon} [${type}]</div>
                <div class="log-text" style="color: ${color}; font-size: ${fontSize}; font-weight: ${fontWeight};">${message}</div>
            `;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        // ========== å…¶ä»–åŠŸèƒ½ ==========
        // ========== è‡ªå‹•è£å‚™èˆ‡åˆ†è§£ç³»çµ± ==========
        
        // è£å‚™è©•åˆ†å‡½æ•¸ï¼šç¶œåˆè€ƒæ…®æ‰€æœ‰å±¬æ€§
        function calculateEquipmentScore(equipment) {
            if (!equipment || equipment.type === 'consumable') return 0;
            
            let score = 0;
            
            // ä¸»å±¬æ€§ï¼ˆæ ¸å¿ƒå±¬æ€§ï¼‰
            score += (equipment.atk || 0) * 10;  // æ”»æ“Šæ¬Šé‡ 10
            score += (equipment.def || 0) * 8;   // é˜²ç¦¦æ¬Šé‡ 8
            score += (equipment.hp || 0) * 0.5;  // ç”Ÿå‘½æ¬Šé‡ 0.5
            
            // æ¬¡è¦å±¬æ€§
            score += (equipment.crit || 0) * 15;  // æš´æ“Šç‡æ¬Šé‡ 15
            score += (equipment.critDmg || 0) * 0.5;  // æš´æ“Šå‚·å®³æ¬Šé‡ 0.5
            score += (equipment.dmgRed || 0) * 20;  // å‚·å®³æ¸›å…æ¬Šé‡ 20
            score += (equipment.lifeSteal || 0) * 25;  // ç”Ÿå‘½å¸å–æ¬Šé‡ 25
            score += (equipment.armorPen || 0) * 15;  // ç©¿é€æ¬Šé‡ 15
            score += (equipment.bossDmg || 0) * 12;  // Bosså‚·å®³æ¬Šé‡ 12
            score += (equipment.hpRegen || 0) * 10;  // ç”Ÿå‘½å›å¾©æ¬Šé‡ 10
            score += (equipment.expBonus || 0) * 5;  // ç¶“é©—åŠ æˆæ¬Šé‡ 5
            score += (equipment.luck || 0) * 8;  // å¹¸é‹æ¬Šé‡ 8
            score += (equipment.goldBonus || 0) * 5;  // é‡‘å¹£åŠ æˆæ¬Šé‡ 5
            
            // ç¨€æœ‰åº¦åŠ æˆ
            const rarityBonus = {
                'Common': 0,
                'Fine': 100,
                'Rare': 300,
                'Epic': 600,
                'Legendary': 1000,
                'Mythic': 1500,
                'Eternal': 2000
            };
            score += rarityBonus[equipment.rarity] || 0;
            
            // å¥—è£åŠ åˆ†ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
            if (gameState.autoEquipment.considerSet && equipment.set) {
                score += 500;  // å¥—è£è£å‚™é¡å¤–åŠ  500 åˆ†
            }
            
            // å¼·åŒ–ç­‰ç´šåŠ åˆ†
            if (equipment.enhance > 0) {
                score += equipment.enhance * 50;  // æ¯ç´šå¼·åŒ– +50 åˆ†
            }
            
            return Math.floor(score);
        }
        
        // æ¯”è¼ƒè£å‚™ï¼šæ–°è£å‚™æ˜¯å¦æ¯”ç•¶å‰è£å‚™æ›´å¥½
        function isEquipmentBetter(newEquip, currentEquip) {
            if (!currentEquip) return true;  // æ²’æœ‰ç•¶å‰è£å‚™ï¼Œç›´æ¥è£å‚™
            if (!newEquip) return false;
            
            const newScore = calculateEquipmentScore(newEquip);
            const currentScore = calculateEquipmentScore(currentEquip);
            
            return newScore > currentScore;
        }
        
        // è‡ªå‹•è£å‚™åŠŸèƒ½
        function autoEquipItem(item) {
            if (!gameState.autoEquipment.enabled) return false;
            if (!item || item.type === 'consumable') return false;
            
            const slot = item.type;  // weapon, armor, accessory
            let targetSlot = null;
            
            // ç¢ºå®šç›®æ¨™æ§½ä½
            if (slot === 'weapon' || slot === 'armor') {
                targetSlot = slot;
            } else if (slot === 'accessory') {
                // å°æ–¼é£¾å“ï¼Œé¸æ“‡è©•åˆ†è¼ƒä½çš„æ§½ä½
                const acc1Score = calculateEquipmentScore(gameState.player.equipment.accessory1);
                const acc2Score = calculateEquipmentScore(gameState.player.equipment.accessory2);
                targetSlot = acc1Score <= acc2Score ? 'accessory1' : 'accessory2';
            } else {
                return false;
            }
            
            const currentEquip = gameState.player.equipment[targetSlot];
            
            // æ¯”è¼ƒè£å‚™
            if (isEquipmentBetter(item, currentEquip)) {
                // å¸ä¸‹ç•¶å‰è£å‚™ï¼ˆæ”¾å›èƒŒåŒ…ï¼‰
                if (currentEquip) {
                    gameState.inventory.push(currentEquip);
                }
                
                // è£å‚™æ–°è£å‚™
                gameState.player.equipment[targetSlot] = item;
                
                // å¾èƒŒåŒ…ä¸­ç§»é™¤
                const index = gameState.inventory.indexOf(item);
                if (index > -1) {
                    gameState.inventory.splice(index, 1);
                }
                
                // çµ±è¨ˆ
                gameState.autoEquipment.stats.autoEquipped++;
                
                // é‡æ–°è¨ˆç®—å±¬æ€§
                recalculateStats();
                updateUI();
                
                addLog('è‡ªå‹•è£å‚™', `âœ… è‡ªå‹•è£å‚™ï¼š${item.name}`);
                playSound('equip');
                
                return true;
            }
            
            return false;
        }
        
        // æª¢æŸ¥è£å‚™æ˜¯å¦æ‡‰è©²è¢«ä¿è­·
        function shouldProtectEquipment(equipment) {
            if (!equipment) return false;
            
            // ä¿è­·å·²è£å‚™çš„
            if (Object.values(gameState.player.equipment).includes(equipment)) {
                return true;
            }
            
            // ä¿è­·å¥—è£è£å‚™ï¼ˆå¦‚æœå•Ÿç”¨ï¼‰
            if (gameState.autoEquipment.protectSet && equipment.setName) {
                return true;
            }
            
            // ä¿è­·æ¯å€‹éƒ¨ä½è©•åˆ†æœ€é«˜çš„è£å‚™ï¼ˆåªä¿è­·ä¸€ä»¶ï¼‰
            // å°æ–¼ accessory é¡å‹ï¼Œéœ€è¦é€²ä¸€æ­¥æª¢æŸ¥ subtypeï¼ˆring æˆ– necklaceï¼‰
            const sameTypeEquips = gameState.inventory.filter(item => {
                if (!item || item.type !== equipment.type) return false;
                
                // å¦‚æœæ˜¯ accessoryï¼Œé‚„è¦æª¢æŸ¥ subtype æ˜¯å¦ç›¸åŒ
                if (equipment.type === 'accessory') {
                    return item.subtype === equipment.subtype;
                }
                
                return true;
            });
            
            if (sameTypeEquips.length > 1) {
                // æ‰¾åˆ°è©•åˆ†æœ€é«˜çš„è£å‚™
                let bestEquip = sameTypeEquips[0];
                let bestScore = calculateEquipmentScore(bestEquip);
                
                for (let i = 1; i < sameTypeEquips.length; i++) {
                    const score = calculateEquipmentScore(sameTypeEquips[i]);
                    if (score > bestScore) {
                        bestScore = score;
                        bestEquip = sameTypeEquips[i];
                    }
                }
                
                // åªä¿è­·è©•åˆ†æœ€é«˜çš„é‚£ä¸€ä»¶ï¼ˆä½¿ç”¨ ID æ¯”å°ï¼‰
                if (equipment.id === bestEquip.id) {
                    return true;
                }
            }
            
            return false;
        }
        
        // åˆ†è§£è£å‚™ç²å¾—ææ–™
        function salvageEquipment(equipment) {
            if (!equipment) return 0;
            
            const rarityMaterials = {
                'Common': 1,
                'Fine': 3,
                'Rare': 8,
                'Epic': 20,
                'Legendary': 50,
                'Mythic': 120,
                'Eternal': 300
            };
            
            let materials = rarityMaterials[equipment.rarity] || 1;
            
            // å¼·åŒ–ç­‰ç´šé¡å¤–ææ–™
            if (equipment.enhance > 0) {
                materials += equipment.enhance * 5;
            }
            
            return materials;
        }
        
        // è‡ªå‹•åˆ†è§£ä½å“è³ªè£å‚™
        function autoSalvageItems() {
            if (!gameState.autoEquipment.autoSalvage) return;
            
        const salvageQualities = gameState.autoEquipment.salvageQuality || ['common'];
        const rarityMap = {
            'common': 'Common',
            'uncommon': 'Uncommon',
            'fine': 'Fine',
            'rare': 'Rare',
            'epic': 'Epic',
            'legendary': 'Legendary',
            'mythic': 'Mythic',
            'eternal': 'Eternal',
            'set': 'Set'
        };
            
            let salvaged = 0;
            let totalMaterials = 0;
            let totalFragments = 0;
            
            // ç¯©é¸éœ€è¦åˆ†è§£çš„è£å‚™
            gameState.inventory = gameState.inventory.filter(item => {
                if (!item || item.type === 'consumable') return true;
                
                // æª¢æŸ¥æ˜¯å¦æ‡‰è©²ä¿è­·
                if (shouldProtectEquipment(item)) return true;
                
                // å¥—è£ç‰¹æ®Šè™•ç†ï¼šæª¢æŸ¥ setName å±¬æ€§
                const isSet = item.setName ? true : false;
                
                // æª¢æŸ¥æ˜¯å¦åœ¨åˆ†è§£åˆ—è¡¨ä¸­
                const shouldSalvage = salvageQualities.some(quality => {
                    const rarity = rarityMap[quality.toLowerCase()];
                    // å¥—è£ç‰¹æ®Šåˆ¤æ–·
                    if (quality.toLowerCase() === 'set' && isSet) return true;
                    // ä¸å€åˆ†å¤§å°å¯«æ¯”è¼ƒï¼ˆå…¼å®¹èˆŠç‰ˆå°å¯«å’Œæ–°ç‰ˆå¤§å¯«ï¼‰
                    return item.rarity && item.rarity.toLowerCase() === rarity.toLowerCase();
                });
                
                if (shouldSalvage) {
                    const materials = salvageEquipment(item);
                    totalMaterials += materials;
                    
                // ç¨€æœ‰ä»¥ä¸Šçš„è£å‚™é¡å¤–ç²å¾—ç¢ç‰‡
                const itemRarity = isSet ? 'set' : item.rarity;
                if (['rare', 'epic', 'legendary', 'mythic', 'eternal', 'set'].includes(itemRarity)) {
                    const fragmentAmount = {
                        'rare': 1,
                        'epic': 2,
                        'legendary': 5,
                        'mythic': 10,
                        'eternal': 20,
                        'set': 3
                    }[itemRarity] || 0;
                    totalFragments += fragmentAmount;
                }
                    
                    salvaged++;
                    return false;  // ç§»é™¤é€™å€‹ç‰©å“
                }
                
                return true;  // ä¿ç•™é€™å€‹ç‰©å“
            });
            
            if (salvaged > 0) {
                // æ·»åŠ ææ–™
                if (!gameState.materials) {
                    gameState.materials = { enhanceStone: 0, fragment: 0 };
                }
                if (!gameState.materials.enhanceStone) gameState.materials.enhanceStone = 0;
                if (!gameState.materials.fragment) gameState.materials.fragment = 0;
                
                gameState.materials.enhanceStone += totalMaterials;
                gameState.materials.fragment += totalFragments;
                
                // çµ±è¨ˆ
                gameState.autoEquipment.stats.autoSalvaged += salvaged;
                gameState.autoEquipment.stats.materialsGained += totalMaterials;
                
                let logMessage = `ğŸ”§ è‡ªå‹•åˆ†è§£äº† ${salvaged} ä»¶è£å‚™`;
                if (totalMaterials > 0) logMessage += `ï¼Œç²å¾— ${totalMaterials} å€‹å¼·åŒ–çŸ³`;
                if (totalFragments > 0) logMessage += `ã€${totalFragments} å€‹ç¢ç‰‡`;
                
                addLog('è‡ªå‹•åˆ†è§£', logMessage);
            }
        }
        
        // èƒŒåŒ…æ»¿æ™‚è‡ªå‹•åˆ†è§£æœ€å·®çš„è£å‚™
        function autoSalvageWorstEquipment() {
            if (!gameState.autoEquipment.autoSalvage) return false;
            
            // æ‰¾åˆ°æ‰€æœ‰éæ¶ˆè€—å“çš„è£å‚™
            const equipments = gameState.inventory.filter(item => 
                item && item.type !== 'consumable' && !shouldProtectEquipment(item)
            );
            
            if (equipments.length === 0) return false;
            
            // æ‰¾åˆ°è©•åˆ†æœ€ä½çš„è£å‚™
            let worstEquip = equipments[0];
            let worstScore = calculateEquipmentScore(worstEquip);
            
            for (const equip of equipments) {
                const score = calculateEquipmentScore(equip);
                if (score < worstScore) {
                    worstScore = score;
                    worstEquip = equip;
                }
            }
            
            // åˆ†è§£æœ€å·®çš„è£å‚™
            const index = gameState.inventory.indexOf(worstEquip);
            if (index > -1) {
                gameState.inventory.splice(index, 1);
                
                const materials = salvageEquipment(worstEquip);
                if (!gameState.materials) {
                    gameState.materials = { enhanceStone: 0 };
                }
                gameState.materials.enhanceStone = (gameState.materials.enhanceStone || 0) + materials;
                
                gameState.autoEquipment.stats.autoSalvaged++;
                gameState.autoEquipment.stats.materialsGained += materials;
                
                addLog('è‡ªå‹•åˆ†è§£', `ğŸ”§ èƒŒåŒ…æ»¿äº†ï¼Œè‡ªå‹•åˆ†è§£ï¼š${worstEquip.name}ï¼Œç²å¾— ${materials} å€‹å¼·åŒ–çŸ³`);
                
                return true;
            }
            
            return false;
        }
        
        // çµ±ä¸€çš„èƒŒåŒ…æ·»åŠ å‡½æ•¸ï¼ˆæª¢æŸ¥å®¹é‡ï¼‰
        function addToInventory(item, showLog = true) {
            const maxInv = gameState.maxInventory || 50;
            
            // åˆå§‹åŒ–è‡ªå‹•è£å‚™è¨­å®šï¼ˆå…¼å®¹èˆŠå­˜æª”ï¼‰
            if (!gameState.autoEquipment) {
                gameState.autoEquipment = {
                    enabled: false,
                    autoSalvage: false,
                    salvageQuality: ['common'],
                    protectSet: true,
                    considerSet: false,
                    stats: {
                        autoEquipped: 0,
                        autoSalvaged: 0,
                        materialsGained: 0
                    }
                };
            }
            
            // å˜—è©¦è‡ªå‹•è£å‚™ï¼ˆå¦‚æœæ˜¯è£å‚™ä¸”å•Ÿç”¨äº†è‡ªå‹•è£å‚™ï¼‰
            if (item && item.type !== 'consumable' && gameState.autoEquipment.enabled) {
                const equipped = autoEquipItem(item);
                if (equipped) {
                    // å·²è‡ªå‹•è£å‚™ï¼Œä¸éœ€è¦æ”¾å…¥èƒŒåŒ…
                    autoSalvageItems();  // å˜—è©¦è‡ªå‹•åˆ†è§£
                    return true;
                }
            }
            
            // æª¢æŸ¥èƒŒåŒ…æ˜¯å¦å·²æ»¿
            if (gameState.inventory.length >= maxInv) {
                // å˜—è©¦è‡ªå‹•åˆ†è§£æœ€å·®çš„è£å‚™é¨°å‡ºç©ºé–“
                if (gameState.autoEquipment.autoSalvage && item.type !== 'consumable') {
                    const salvaged = autoSalvageWorstEquipment();
                    if (salvaged) {
                        // æˆåŠŸåˆ†è§£ï¼Œç¾åœ¨æœ‰ç©ºé–“äº†
                        gameState.inventory.push(item);
                        return true;
                    }
                }
                
                if (showLog) {
                    addLog('ç³»çµ±', `âš ï¸ èƒŒåŒ…å·²æ»¿ï¼ç„¡æ³•ç²å¾— ${item.name}ï¼Œè«‹å…ˆæ•´ç†èƒŒåŒ…ã€‚`);
                }
                return false;
            }
            
            // æ·»åŠ ç‰©å“
            gameState.inventory.push(item);
            
            // å˜—è©¦è‡ªå‹•åˆ†è§£ï¼ˆåœ¨æ·»åŠ å¾Œï¼‰
            if (item && item.type !== 'consumable') {
                autoSalvageItems();
            }
            
            return true;
        }
        
        // ä¼‘æ¯åŠŸèƒ½å·²ç§»é™¤
        /*
         function rest() {
             const COST_GOLD = 30;
             const COST_AP = 2;
             const BUFF_DURATION = 3; // 3 å›åˆ
             const BUFF_DEF_PERCENT = 10; // é˜²ç¦¦ +10%
             
             if (gameState.player.gold < COST_GOLD) {
                 addLog('ç³»çµ±', `é‡‘å¹£ä¸è¶³ï¼éœ€è¦${COST_GOLD}é‡‘å¹£ã€‚`);
                 return;
             }
             
             if (gameState.player.ap < COST_AP) {
                 addLog('ç³»çµ±', `é«”åŠ›ä¸è¶³ï¼éœ€è¦${COST_AP}é«”åŠ›ã€‚`);
                 return;
             }
             
             // æ‰£é™¤è²»ç”¨
             gameState.player.gold -= COST_GOLD;
             gameState.player.ap -= COST_AP;
             
             // æ¢å¾© HP
             const healAmount = Math.floor(gameState.player.maxHp * 0.35); // æ¢å¾© 35% HP
             gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
             
             // æ–°å¢é˜²ç¦¦ Buff
             const defenseBuff = {
                 id: 'rest_def_buff',
                 name: 'ä¼‘æ¯é˜²ç¦¦',
                 duration: BUFF_DURATION,
                 effects: { def: BUFF_DEF_PERCENT } // é€™è£¡çš„ def æ‡‰è©²æ˜¯ç™¾åˆ†æ¯”ï¼Œä½†åŸä»£ç¢¼ä¸­ buff æ•ˆæœæ˜¯åŠ åœ¨åŸºç¤å±¬æ€§ä¸Šï¼Œé€™è£¡å…ˆæŒ‰åŸä»£ç¢¼é‚è¼¯è™•ç†ç‚ºç™¾åˆ†æ¯”åŠ æˆ
             };
             
             // ç§»é™¤èˆŠçš„ä¼‘æ¯ Buff (å¦‚æœå­˜åœ¨)
             gameState.player.buffs = gameState.player.buffs.filter(b => b.id !== defenseBuff.id);
             gameState.player.buffs.push(defenseBuff);
             
             // æˆ°é¬¥æ—¥èªŒ
             addLog('ä¼‘æ¯', `èŠ±è²» ${COST_GOLD} é‡‘å¹£å’Œ ${COST_AP} é«”åŠ›ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ (${(0.35 * 100).toFixed(0)}%)ã€‚`);
             addLog('ä¼‘æ¯', `ç²å¾—äº†ã€Œä¼‘æ¯é˜²ç¦¦ã€Buffï¼šé˜²ç¦¦+${BUFF_DEF_PERCENT}%ï¼ŒæŒçºŒ ${BUFF_DURATION} å›åˆã€‚`);
             
             updateUI();
             
             // ä¼‘æ¯å¾Œç«‹å³å­˜æª”
             saveGame();
         }
         */

        function openBagModal() {
            const modal = document.getElementById('bag-modal');
            const items = document.getElementById('bag-items');
            
            // éæ¿¾ null ç‰©å“
            gameState.inventory = gameState.inventory.filter(item => item !== null && item !== undefined);
            
            if (gameState.inventory.length === 0) {
                items.innerHTML = '<p style="color: #7a8fb8; text-align: center; padding: 20px;">èƒŒåŒ…æ˜¯ç©ºçš„</p>';
            } else {
                items.innerHTML = gameState.inventory.map(item => {
                    // é˜²ç¦¦æ€§æª¢æŸ¥
                    if (!item || !item.type) {
                        return '';
                    }
                    // æ›´åš´æ ¼çš„æ¶ˆè€—å“æª¢æŸ¥ï¼šæœ‰subtypeæˆ–è€…typeæ˜¯consumable
                    const isConsumable = item.type === 'consumable' || item.subtype === 'hp' || item.subtype === 'ap' || item.subtype === 'hp_fixed' || item.subtype === 'ap_fixed' || item.subtype === 'both_fixed' || item.subtype === 'buff' || item.subtype === 'exp' || item.subtype === 'skill_reset' || item.subtype === 'bag_expand' || item.subtype === 'starter_pack' || item.subtype === 'hp_potion' || item.subtype === 'exp_scroll' || item.subtype === 'hp_percent' || item.subtype === 'both_percent' || item.subtype === 'hp_regen' || item.subtype === 'both_regen' || item.subtype === 'ap_potion';
                    
                    if (isConsumable) {
                        // æ¶ˆè€—å“
                        // ä¿®å¾©èˆŠå­˜æª”ï¼šç¢ºä¿ type å±¬æ€§æ­£ç¢º
                        if (item.type !== 'consumable') {
                            item.type = 'consumable';
                        }
                        // ç¢ºä¿ id å­˜åœ¨
                        if (!item.id) {
                            item.id = Date.now() + Math.random();
                        }
                        
                        // å„ªå…ˆä½¿ç”¨ description å±¬æ€§ï¼Œå…¶æ¬¡æ˜¯ desc
                        let desc = item.description || item.desc || '';
                        if (!desc) {
                            // å¦‚æœæ²¡æœ‰æè¿°ï¼Œæ ¹æ“šé¡å‹ç”Ÿæˆ
                            if (item.subtype === 'hp') {
                                desc = `[ç«‹å³] å›å¾©${Math.floor(item.recovery * 100)}% HP`;
                            } else if (item.subtype === 'hp_percent') {
                                desc = `[ç«‹å³] å›å¾©${Math.floor(item.recovery * 100)}%æœ€å¤§HP`;
                            } else if (item.subtype === 'hp_fixed') {
                                desc = `[ç«‹å³] å›å¾©${item.recovery} HP`;
                            } else if (item.subtype === 'ap') {
                                desc = `[ç«‹å³] å›å¾©${item.recovery} AP`;
                            } else if (item.subtype === 'ap_fixed') {
                                desc = `[ç«‹å³] æ¢å¾©${item.recovery} AP`;
                            } else if (item.subtype === 'both_fixed') {
                                desc = `[ç«‹å³] å›å¾©${item.hpRecovery} HP + ${item.apRecovery} AP`;
                            } else if (item.subtype === 'both_percent') {
                                desc = `[ç«‹å³] å›å¾©${Math.floor(item.hpPercent * 100)}%æœ€å¤§HP + ${item.apRecovery} AP`;
                            } else if (item.subtype === 'hp_regen') {
                                desc = `[æŒçºŒ${item.duration}æˆ°] æ¯å›åˆå›å¾©${Math.floor(item.regenValue * 100)}%æœ€å¤§HP`;
                            } else if (item.subtype === 'both_regen') {
                                desc = `[æŒçºŒ${item.duration}æˆ°] æ¯å›åˆå›å¾©${Math.floor(item.hpRegenValue * 100)}%æœ€å¤§HP + ${item.apRegenValue} AP`;
                        } else if (item.subtype === 'buff') {
                            const effectLabel = item.effect?.label || 'å±¬æ€§åŠ æˆ';
                            desc = `[æŒçºŒ10æˆ°] ${effectLabel}`;
                            } else if (item.subtype === 'exp') {
                                desc = `[ç«‹å³] +${item.exp} EXP`;
                            }
                        }
                        
                        const quantity = item.quantity || 1;
                        
                        return `
                            <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="color: #4CAF50; font-weight: bold;">${item.name} <span style="color: #ffd700;">Ã—${quantity}</span></div>
                                    <div style="font-size: 0.85rem; color: #7a8fb8; margin-top: 5px;">${desc}</div>
                                </div>
                                <button onclick="useConsumable('${item.id}')" style="padding: 8px 16px; background: #00d9ff; color: #0a1628; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">ä½¿ç”¨</button>
                            </div>
                        `;
                    } else {
                        // è£å‚™
                        const slotMap = {
                            'weapon': 'weapon',
                            'armor': 'armor',
                            'accessory': gameState.player.equipment.accessory1 ? 'accessory2' : 'accessory1'
                        };
                        const targetSlot = slotMap[item.type];
                        const currentEquipped = gameState.player.equipment[targetSlot];
                        
                        // å¼·åŒ–ç­‰ç´šé¡¯ç¤º
                        const enhanceLevel = item.enhance || 0;
                        const enhanceDisplay = enhanceLevel > 0 ? ` <span style="color: #ffd700;">+${enhanceLevel}</span>` : '';
                        
                        // å¼·åŒ–æŒ‰éˆ•
                        const enhanceCost = ENHANCE_COST[enhanceLevel] || 0;
                        const enhanceRate = ENHANCE_SUCCESS_RATE[enhanceLevel] || 0;
                        let enhanceStoneReq = 1;
                        if (enhanceLevel >= 11) enhanceStoneReq = 3;
                        else if (enhanceLevel >= 6) enhanceStoneReq = 2;
                        const enhanceBtn = enhanceLevel < 15 ? 
                            `<button onclick="enhanceEquipment('${item.id}')" style="padding: 6px 12px; background: #FFD700; color: #0a1628; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; margin-right: 5px;" title="æˆåŠŸç‡: ${enhanceRate}%\næ¶ˆè€—: ${enhanceCost}é‡‘å¹£ + ${enhanceStoneReq}å¼·åŒ–çŸ³">ğŸ”¨ å¼·åŒ–</button>` : 
                            '';
                        
                        // é‡é‘„æŒ‰éˆ•
                        const reforgeCost = REFORGE_COST[item.rarity] || 10;
                        const reforgeGoldCost = reforgeCost * 10;
                        let reforgeStoneReq = 1;
                        if (item.rarity === 'mythic' || item.rarity === 'eternal') reforgeStoneReq = 8;
                        else if (item.rarity === 'legendary') reforgeStoneReq = 5;
                        else if (item.rarity === 'epic') reforgeStoneReq = 3;
                        else if (item.rarity === 'rare') reforgeStoneReq = 2;
                        const reforgeBtn = `<button onclick="reforgeEquipment('${item.id}')" style="padding: 6px 12px; background: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; margin-right: 5px;" title="æ¶ˆè€—: ${reforgeGoldCost}é‡‘å¹£ + ${reforgeCost}ç¢ç‰‡ + ${reforgeStoneReq}é‡é‘„çŸ³">ğŸ² é‡é‘„</button>`;
                        
                        return `
                            <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                    <div style="flex: 1;">
                                        <div style="color: ${item.color}; font-weight: bold;">${item.name}${enhanceDisplay} [${item.rarityLabel}]</div>
                                        ${item.setName ? `<div style="font-size: 0.8rem; color: #FFD700; margin-top: 2px;">âœ¨ ${item.setName}</div>` : ''}
                                        <div style="font-size: 0.85rem; margin-top: 5px; line-height: 1.6;">
                                            ${formatItemStats(item, currentEquipped)}
                                        </div>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 5px; margin-top: 10px; flex-wrap: wrap;">
                                    <button onclick="quickEquipItem('${item.id}', '${targetSlot}')" style="padding: 8px 16px; background: #00d9ff; color: #0a1628; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; white-space: nowrap;">è£å‚™</button>
                                    ${enhanceBtn}
                                    ${reforgeBtn}
                                </div>
                            </div>
                        `;
                    }
                }).join('');
            }
            
            modal.classList.add('active');
        }

        function closeBagModal() {
            document.getElementById('bag-modal').classList.remove('active');
        }

        // é–‹å•Ÿå‡ºç”Ÿç¦®åŒ…
        function openStarterPack() {
            const rewards = [];
            
            // 1. ç”Ÿæˆéš¨æ©Ÿæ­¦å™¨(ç°50%/ç¶ 35%/è—15%)
            const weaponRarityRoll = Math.random();
            let weaponRarity;
            if (weaponRarityRoll < 0.5) {
                weaponRarity = RARITIES[0]; // æ™®é€š(ç°)
            } else if (weaponRarityRoll < 0.85) {
                weaponRarity = RARITIES[1]; // å„ªè³ª(ç¶ )
            } else {
                weaponRarity = RARITIES[2]; // ç²¾è‰¯(è—)
            }
            
            let weapon = generateItem('normal', weaponRarity.name);
            if (!weapon || weapon.type !== 'weapon') {
                // å¦‚æœä¸æ˜¯æ­¦å™¨ï¼Œé‡æ–°ç”Ÿæˆç›´åˆ°ç²å¾—æ­¦å™¨
                let attempts = 0;
                while ((!weapon || weapon.type !== 'weapon') && attempts < 10) {
                    weapon = generateItem('normal', weaponRarity.name);
                    attempts++;
                }
            }
            
            // generateItem å·²ç¶“æœƒè‡ªå‹•æ ¹æ“šå“éšç”Ÿæˆè©ç¶´ï¼Œä¸éœ€è¦æ‰‹å‹•æ·»åŠ 
            
            if (addToInventory(weapon, false)) {
                rewards.push(`âš”ï¸ æ­¦å™¨: <span style="color: ${weaponRarity.color};">[${weaponRarity.label}] ${weapon.name}</span>`);
            }
            
            // 2. ç”Ÿæˆéš¨æ©Ÿé˜²å…·(ç°50%/ç¶ 35%/è—15%)
            const armorRarityRoll = Math.random();
            let armorRarity;
            if (armorRarityRoll < 0.5) {
                armorRarity = RARITIES[0]; // æ™®é€š(ç°)
            } else if (armorRarityRoll < 0.85) {
                armorRarity = RARITIES[1]; // å„ªè³ª(ç¶ )
            } else {
                armorRarity = RARITIES[2]; // ç²¾è‰¯(è—)
            }
            
            let armor = generateItem('normal', armorRarity.name);
            if (!armor || armor.type !== 'armor') {
                // å¦‚æœä¸æ˜¯é˜²å…·ï¼Œé‡æ–°ç”Ÿæˆç›´åˆ°ç²å¾—é˜²å…·
                let attempts = 0;
                while ((!armor || armor.type !== 'armor') && attempts < 10) {
                    armor = generateItem('normal', armorRarity.name);
                    attempts++;
                }
            }
            
            // generateItem å·²ç¶“æœƒè‡ªå‹•æ ¹æ“šå“éšç”Ÿæˆè©ç¶´ï¼Œä¸éœ€è¦æ‰‹å‹•æ·»åŠ 
            
            if (addToInventory(armor, false)) {
                rewards.push(`ğŸ›¡ï¸ é˜²å…·: <span style="color: ${armorRarity.color};">[${armorRarity.label}] ${armor.name}</span>`);
            }
            
            // 3. éš¨æ©Ÿé¸æ“‡1å€‹Commonéš¨å¾
            const commonCompanions = Object.keys(COMPANIONS).filter(id => COMPANIONS[id].rarity === 'common');
            if (commonCompanions.length > 0) {
                const randomCompanionId = commonCompanions[Math.floor(Math.random() * commonCompanions.length)];
                obtainCompanion(randomCompanionId);
                const companion = COMPANIONS[randomCompanionId];
                rewards.push(`ğŸ¾ éš¨å¾: <span style="color: #9e9e9e;">[Common] ${companion.name}</span>`);
            }
            
            // 4. éš¨æ©Ÿé¸æ“‡1å€‹Commonå¡ç‰Œ
            const commonCards = Object.keys(CARDS).filter(id => CARDS[id].rarity === 'common');
            if (commonCards.length > 0) {
                const randomCardId = commonCards[Math.floor(Math.random() * commonCards.length)];
                getCard(randomCardId);
                const card = CARDS[randomCardId];
                rewards.push(`ğŸ´ å¡ç‰Œ: <span style="color: #9e9e9e;">[Common] ${card.name}</span>`);
            }
            
            // 5. æ·»åŠ 30å€‹å°å‹ç”Ÿå‘½è—¥æ°´
            const hpPotion = {
                id: Date.now() + Math.random(),
                type: 'consumable',
                subtype: 'hp_potion',
                name: 'å°å‹ç”Ÿå‘½è—¥æ°´',
                description: '[ç«‹å³] å›å¾©25%æœ€å¤§HP',
                hpPercent: 0.25,
                quantity: 30
            };
            if (addToInventory(hpPotion, false)) {
                rewards.push(`ğŸ§ª å°å‹ç”Ÿå‘½è—¥æ°´ Ã— 30`);
            }
            
            // 6. æ·»åŠ 10å€‹ç¶“é©—è—¥æ°´
            const expScroll = {
                id: Date.now() + Math.random() + 1,
                type: 'consumable',
                subtype: 'exp_scroll',
                name: 'å°å‹ç¶“é©—å·è»¸',
                description: '[ç«‹å³] ç²å¾—500é»ç¶“é©—å€¼',
                exp: 500,
                quantity: 10
            };
            addToInventory(expScroll, false);
            rewards.push(`ğŸ“š å°å‹ç¶“é©—å·è»¸ Ã— 10`);
            
            // é¡¯ç¤ºçå‹µè¦–çª—
            showStarterPackRewards(rewards);
            
            // è¨˜éŒ„æ—¥èªŒ
            addLog('ç³»çµ±', 'ğŸ å‡ºç”Ÿç¦®åŒ…é–‹å•ŸæˆåŠŸï¼');
            
            updateUI();
            saveGame();
        }
        
        // é¡¯ç¤ºå‡ºç”Ÿç¦®åŒ…çå‹µè¦–çª—
        function showStarterPackRewards(rewards) {
            const modal = document.createElement('div');
            modal.className = 'modal active';
            modal.style.zIndex = '10000';
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 500px;">
                    <h2 style="text-align: center; color: #ffd700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">ğŸ å‡ºç”Ÿç¦®åŒ…é–‹å•ŸæˆåŠŸï¼</h2>
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3); margin: 20px 0;">
                        <h3 style="color: #00d9ff; text-align: center; margin-bottom: 15px;">ç²å¾—ç‰©å“</h3>
                        <div style="color: #e0e6ff; line-height: 2; font-size: 1rem;">
                            ${rewards.map(r => `<div style="padding: 5px 0; border-bottom: 1px solid rgba(0, 217, 255, 0.1);">${r}</div>`).join('')}
                        </div>
                    </div>
                    <button onclick="this.closest('.modal').remove()" style="width: 100%; padding: 15px; font-size: 1.1rem; background: linear-gradient(135deg, #00d9ff 0%, #4EA5FF 100%);">ç¢ºå®š</button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        function useConsumable(itemId) {
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item || item.type !== 'consumable') return;
            
            if (item.subtype === 'starter_pack') {
                // å‡ºç”Ÿç¦®åŒ…
                openStarterPack();
                
                // ç§»é™¤ç¦®åŒ…
                const index = gameState.inventory.findIndex(i => i.id == itemId);
                if (index !== -1) {
                    gameState.inventory.splice(index, 1);
                }
                
                updateUI();
                saveGame();
                return;
                
            } else if (item.subtype === 'hp') {
                // HPè—¥æ°´ï¼ˆç™¾åˆ†æ¯”ï¼‰ - ç„¡å†·å»
                const healAmount = Math.floor(gameState.player.maxHp * item.recovery);
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
                
            } else if (item.subtype === 'hp_fixed') {
                // HPè—¥æ°´ï¼ˆå›ºå®šæ•¸å€¼ï¼‰ - ç„¡å†·å»
                const healAmount = item.recovery;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
                
            } else if (item.subtype === 'ap') {
                // APè—¥æ°´ - ç„¡å†·å»æ™‚é–“
                const restoreAmount = item.recovery; // å›ºå®šæ•°å€¼
                gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + restoreAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${restoreAmount} é»é«”åŠ›ï¼`);
                
            } else if (item.subtype === 'ap_fixed') {
                // APè—¥æ°´ï¼ˆå›ºå®šæ•¸å€¼ï¼‰ - ç„¡å†·å»æ™‚é–“
                const restoreAmount = item.recovery;
                gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + restoreAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${restoreAmount} é»é«”åŠ›ï¼`);
                
            } else if (item.subtype === 'both_fixed') {
                // ä¾¿ç•¶ï¼ˆHP+APå›ºå®šæ•¸å€¼ï¼‰ - æª¢æŸ¥å†·å»
                const now = Date.now();
                if (now < gameState.potionCooldown) {
                    const remaining = Math.ceil((gameState.potionCooldown - now) / 1000);
                    addLog('ç³»çµ±', `è—¥æ°´å†·å»ä¸­ï¼é‚„éœ€ç­‰å¾… ${remaining} ç§’`);
                    return;
                }
                
                const healAmount = item.hpRecovery;
                const restoreAmount = item.apRecovery;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + restoreAmount);
                gameState.potionCooldown = now + 5000; // 5ç§’å†·å»
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} HP å’Œ ${restoreAmount} APï¼`);
                
            } else if (item.subtype === 'hp_percent') {
                // HPè—¥æ°´ï¼ˆç™¾åˆ†æ¯”ï¼‰ - ç„¡å†·å»
                const healAmount = Math.floor(gameState.player.maxHp * item.recovery);
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
                
            } else if (item.subtype === 'both_percent') {
                // çµ„åˆè—¥æ°´ï¼ˆç™¾åˆ†æ¯”HP + å›ºå®šAPï¼‰ - ç„¡å†·å»
                const healAmount = Math.floor(gameState.player.maxHp * item.hpPercent);
                const restoreAmount = item.apRecovery;
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                gameState.player.ap = Math.min(gameState.player.maxAp, gameState.player.ap + restoreAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} HP å’Œ ${restoreAmount} APï¼`);
                
            } else if (item.subtype === 'hp_regen') {
                // æŒçºŒHPå›å¾©è—¥æ°´ - æ·»åŠ buff
                if (!gameState.player.buffs) gameState.player.buffs = [];
                gameState.player.buffs.push({
                    name: item.name,
                    type: 'hp_regen_potion',
                    value: item.regenValue,
                    duration: item.duration
                });
                const percent = Math.floor(item.regenValue * 100);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼æ¥ä¸‹ä¾†${item.duration}å ´æˆ°é¬¥æ¯å›åˆå›å¾©${percent}%HPï¼`);
                
            } else if (item.subtype === 'both_regen') {
                // æŒçºŒçµ„åˆå›å¾©è—¥æ°´ - æ·»åŠ buff
                if (!gameState.player.buffs) gameState.player.buffs = [];
                gameState.player.buffs.push({
                    name: item.name,
                    type: 'both_regen_potion',
                    hpValue: item.hpRegenValue,
                    apValue: item.apRegenValue,
                    duration: item.duration
                });
                const hpPercent = Math.floor(item.hpRegenValue * 100);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼æ¥ä¸‹ä¾†${item.duration}å ´æˆ°é¬¥æ¯å›åˆå›å¾©${hpPercent}%HP + ${item.apRegenValue}APï¼`);
                
            } else if (item.subtype === 'buff') {
                // å±¬æ€§å· - è‡¨æ™‚Buffï¼ˆ10å ´æˆ°é¬¥ï¼‰
                const effect = item.effect;
                
                // æª¢æŸ¥ effect æ˜¯å¦å­˜åœ¨
                if (!effect || !effect.stat || effect.value === undefined) {
                    addLog('ç³»çµ±', `ç„¡æ³•ä½¿ç”¨ ${item.name}ï¼šæ•ˆæœæ•¸æ“šç•°å¸¸ï¼`);
                    return;
                }
                
                // åˆå§‹åŒ– buffs é™£åˆ—
                if (!gameState.player.buffs) {
                    gameState.player.buffs = [];
                }
                
                const label = effect.label || `${effect.stat}+${effect.value}`;
                const buffDuration = 10; // 10å ´æˆ°é¬¥
                
                // æª¢æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒé¡å‹çš„Buff
                const existingBuffIndex = gameState.player.buffs.findIndex(b => 
                    b.source === 'scroll' && b.stat === effect.stat
                );
                
                if (existingBuffIndex !== -1) {
                    // åˆ·æ–°æŒçºŒæ™‚é–“ï¼ˆä¸ç–ŠåŠ æ•¸å€¼ï¼‰
                    gameState.player.buffs[existingBuffIndex].duration = buffDuration;
                    addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œ${label} BuffæŒçºŒæ™‚é–“åˆ·æ–°ï¼ï¼ˆå‰©é¤˜${buffDuration}æˆ°ï¼‰`);
                } else {
                    // æ·»åŠ æ–°Buff
                    const buff = {
                        name: item.name,
                        source: 'scroll',
                        stat: effect.stat,
                        value: effect.value,
                        isPercent: effect.isPercent || false,  // æ˜¯å¦ç‚ºç™¾åˆ†æ¯”
                        duration: buffDuration,
                        label: label
                    };
                    gameState.player.buffs.push(buff);
                    addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œç²å¾— ${label} Buffï¼ï¼ˆæŒçºŒ${buffDuration}æˆ°ï¼‰`);
                }
                
                // é‡æ–°è¨ˆç®—å±¬æ€§ï¼ˆå› ç‚ºBuffæ”¹è®Šäº†ï¼‰
                recalculateStats();
                
            } else if (item.subtype === 'hp_potion') {
                // HPè—¥æ°´ï¼ˆç™¾åˆ†æ¯”ï¼‰ - ç„¡å†·å»
                const healAmount = Math.floor(gameState.player.maxHp * item.recovery);
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + healAmount);
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œæ¢å¾©äº† ${healAmount} é»ç”Ÿå‘½ï¼`);
                
            } else if (item.subtype === 'exp_scroll') {
                // ç¶“é©—å·è»¸
                gameState.player.exp += item.exp;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œç²å¾—äº† ${item.exp} é»ç¶“é©—ï¼`);
                
                // æª¢æŸ¥å‡ç´š
                if (gameState.player.exp >= gameState.player.expToNext) {
                    levelUp();
                }
                
            } else if (item.subtype === 'exp') {
                // ç¶“é©—å·
                gameState.player.exp += item.exp;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼Œç²å¾—äº† ${item.exp} é»ç¶“é©—ï¼`);
                
                // æª¢æŸ¥å‡ç´š
                if (gameState.player.exp >= gameState.player.expToNext) {
                    levelUp();
                }
                
            } else if (item.subtype === 'lucky') {
                // å¹¸é‹ç¡¬å¹£
                if (!gameState.buffs) gameState.buffs = {};
                gameState.buffs.luckyBoost = true;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼ä¸‹æ¬¡æˆ°é¬¥æ‰è½ç‡æå‡100%ï¼`);
                
            } else if (item.subtype === 'expBoost') {
                // é›™å€ç¶“é©—å·
                if (!gameState.buffs) gameState.buffs = {};
                gameState.buffs.expBoost = true;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼ä¸‹æ¬¡æˆ°é¬¥ç²å¾—é›™å€ç¶“é©—ï¼`);
                
            } else if (item.subtype === 'protection') {
                // ä¿è­·ç¬¦å’’
                if (!gameState.buffs) gameState.buffs = {};
                gameState.buffs.deathProtection = true;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼ä¸‹æ¬¡æ­»äº¡æ™‚ä¿ç•™50%ç¶“é©—å’Œé‡‘å¹£ï¼`);
                
            } else if (item.subType === 'skill_reset') {
                // æŠ€èƒ½é‡ç½®å·
                gameState.player.skill = null;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼æŠ€èƒ½å·²é‡ç½®ï¼Œè«‹é‡æ–°é¸æ“‡æŠ€èƒ½ã€‚`);
                // é¡¯ç¤ºæŠ€èƒ½é¸æ“‡ç•Œé¢
                setTimeout(() => {
                    openSkillSelectionModal();
                }, 500);
            } else if (item.subType === 'bag_expand') {
                // èƒŒåŒ…æ“´å……å·
                const currentMax = gameState.maxInventory || 50;
                if (currentMax >= 100) {
                    addLog('ç³»çµ±', `èƒŒåŒ…å·²é”ä¸Šé™100æ ¼ï¼Œç„¡æ³•ç¹¼çºŒæ“´å……ï¼`);
                    return; // ä¸æ¶ˆè€—é“å…·
                }
                gameState.maxInventory = currentMax + 1;
                addLog('ä½¿ç”¨', `ä½¿ç”¨äº† ${item.name}ï¼èƒŒåŒ…ä¸Šé™+1ï¼Œç•¶å‰ä¸Šé™ï¼š${gameState.maxInventory}`);
            }
            
            // æ¸›å°‘æ¶ˆè€—å“æ•¸é‡æˆ–ç§»é™¤
            if (item.quantity && item.quantity > 1) {
                item.quantity--;
            } else {
                gameState.inventory = gameState.inventory.filter(i => i.id != itemId);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šåˆ†è§£è£å‚™
            updateQuestProgress('salvage_equipment', 1);
            }
            
            // æ›´æ–°UI
            updateUI();
            openBagModal(); // é‡æ–°æ‰“é–‹èƒŒåŒ…åˆ·æ–°é¡¯ç¤º
            
            // ä½¿ç”¨æ¶ˆè€—å“å¾Œç«‹å³å­˜æª”
            saveGame();
        }

        // ========== éš¨å¾ç³»çµ± ==========

        // åˆå§‹åŒ–éš¨å¾ç³»çµ±
        function initCompanionSystem() {
            if (!gameState.companions) {
                gameState.companions = {
                    owned: [],
                    active: null,
                    equipment: null,
                    shards: 0,
                    ownedEquipment: [],
                    cooldowns: {}
                };
            }
            // ç¢ºä¿è£å‚™ç›¸é—œå­—æ®µå­˜åœ¨
            if (!gameState.companions.ownedEquipment) {
                gameState.companions.ownedEquipment = [];
            }
            if (gameState.companions.equipment === undefined) {
                gameState.companions.equipment = null;
            }
            if (gameState.companions.shards === undefined) {
                gameState.companions.shards = 0;
            }
        }

        // ========== åœ–é‘‘ç³»çµ± ==========
        
        // åˆå§‹åŒ–åœ–é‘‘ç³»çµ±
        function initCodexSystem() {
            if (!gameState.codex) {
                gameState.codex = {
                    monsters: {},
                    equipment: {},
                    companions: {},
                    cards: {},
                    stats: {
                        totalMonstersUnlocked: 0,
                        totalEquipmentObtained: 0,
                        totalCompanionsObtained: 0,
                        totalCardsObtained: 0
                    },
                    rewardsCollected: {
                        monsters: [],
                        equipment: [],
                        companions: [],
                        cards: []
                    }
                };
            }
            
            // åˆå§‹åŒ–æ€ªç‰©åœ–é‘‘
            initMonsterCodex();
            // åˆå§‹åŒ–è£å‚™åœ–é‘‘
            initEquipmentCodex();
            // åˆå§‹åŒ–éš¨å¾åœ–é‘‘
            initCompanionCodex();
            // åˆå§‹åŒ–å¡ç‰Œåœ–é‘‘
            initCardCodex();
        }
        
        // åˆå§‹åŒ–æ€ªç‰©åœ–é‘‘
        function initMonsterCodex() {
            // éæ­·æ‰€æœ‰å€åŸŸçš„æ™®é€šæ€ªç‰©
            for (const regionName in MONSTERS) {
                const enemies = MONSTERS[regionName];
                enemies.forEach(enemy => {
                    if (!gameState.codex.monsters[enemy.name]) {
                        gameState.codex.monsters[enemy.name] = {
                            name: enemy.name,
                            icon: enemy.icon,
                            region: regionName,
                            type: 'normal',
                            killCount: 0,
                            firstKillTime: null,
                            unlocked: false,
                            rewardsCollected: []
                        };
                    }
                });
            }
            
            // éæ­·æ‰€æœ‰Boss
            for (const regionName in REGION_BOSSES) {
                const boss = REGION_BOSSES[regionName];
                if (!gameState.codex.monsters[boss.name]) {
                    gameState.codex.monsters[boss.name] = {
                        name: boss.name,
                        icon: boss.icon,
                        region: regionName,
                        type: 'boss',
                        killCount: 0,
                        firstKillTime: null,
                        unlocked: false,
                        rewardsCollected: []
                    };
                }
            }
            
            // éæ­·æ‰€æœ‰ç²¾è‹±æ€ªç‰©
            for (const regionName in ELITE_MONSTERS) {
                const elites = ELITE_MONSTERS[regionName];
                elites.forEach(elite => {
                    if (!gameState.codex.monsters[elite.name]) {
                        gameState.codex.monsters[elite.name] = {
                            name: elite.name,
                            icon: elite.icon,
                            region: regionName,
                            type: 'elite',
                            killCount: 0,
                            firstKillTime: null,
                            unlocked: false,
                            rewardsCollected: []
                        };
                    }
                });
            }
        }
        
        // åˆå§‹åŒ–è£å‚™åœ–é‘‘ï¼ˆåªè¨˜éŒ„å¥—è£è£å‚™ï¼‰
        function initEquipmentCodex() {
            // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡å»ºï¼ˆèˆŠå­˜æª”ç›¸å®¹ï¼‰
            const needsRebuild = Object.keys(gameState.codex.equipment).some(key => {
                // å¦‚æœå­˜åœ¨èˆŠçš„çµæ§‹ï¼Œå‰‡éœ€è¦é‡å»º
                const rarities = ['common', 'uncommon', 'fine', 'rare', 'epic', 'legendary', 'mythic'];
                const regions = ['å…¥é–€é–‹ç™¼å±¤', 'ç ”ç™¼æ ¸å¿ƒå±¤', 'è³‡æ–™è£‚ç¸«', 'æ·±äº•è‡¨ç•Œå±¤'];
                return rarities.some(rarity => key.includes(`_${rarity}`)) || 
                       regions.some(region => key.includes(`_${region}`));
            });
            
            if (needsRebuild) {
                console.log('åµæ¸¬åˆ°èˆŠçš„è£å‚™åœ–é‘‘çµæ§‹ï¼Œæ­£åœ¨é‡å»º...');
                gameState.codex.equipment = {};
            }
            
            // éæ­·æ‰€æœ‰å¥—è£è£å‚™ï¼ˆç¬¬ä¸€å¥—ï¼‰
            for (const regionName in EQUIPMENT_SETS) {
                const setData = EQUIPMENT_SETS[regionName];
                setData.items.forEach(item => {
                    const key = item.name; // ä½¿ç”¨è£å‚™åç¨±ä½œç‚ºéµå€¼
                    if (!gameState.codex.equipment[key]) {
                        // æ–°å»ºæ¢ç›®
                        gameState.codex.equipment[key] = {
                            name: item.name,
                            type: item.type,
                            region: regionName,
                            setName: setData.setName,
                            setNumber: 1, // ç¬¬ä¸€å¥—
                            icon: item.type === 'weapon' ? 'ğŸ—¡ï¸' : item.type === 'armor' ? 'ğŸ›¡ï¸' : 'ğŸ’',
                            obtained: false,
                            firstObtainTime: null,
                            obtainCount: 0
                        };
                    } else if (gameState.codex.equipment[key].setNumber === undefined) {
                        // èˆŠå­˜æª”ç›¸å®¹ï¼šæ›´æ–° setNumber
                        gameState.codex.equipment[key].setNumber = 1;
                    }
                });
            }
            
            // éæ­·æ‰€æœ‰å¥—è£è£å‚™ï¼ˆç¬¬äºŒå¥—ï¼‰
            for (const regionName in EQUIPMENT_SETS_2) {
                const setData = EQUIPMENT_SETS_2[regionName];
                setData.items.forEach(item => {
                    const key = item.name; // ä½¿ç”¨è£å‚™åç¨±ä½œç‚ºéµå€¼
                    if (!gameState.codex.equipment[key]) {
                        // æ–°å»ºæ¢ç›®
                        gameState.codex.equipment[key] = {
                            name: item.name,
                            type: item.type,
                            region: regionName,
                            setName: setData.setName,
                            setNumber: 2, // ç¬¬äºŒå¥—
                            icon: item.type === 'weapon' ? 'ğŸ—¡ï¸' : item.type === 'armor' ? 'ğŸ›¡ï¸' : 'ğŸ’',
                            obtained: false,
                            firstObtainTime: null,
                            obtainCount: 0
                        };
                    } else if (gameState.codex.equipment[key].setNumber === undefined) {
                        // èˆŠå­˜æª”ç›¸å®¹ï¼šæ›´æ–° setNumber
                        gameState.codex.equipment[key].setNumber = 2;
                    }
                });
            }
        }
        
        // åˆå§‹åŒ–éš¨å¾åœ–é‘‘
        function initCompanionCodex() {
            for (const companionId in COMPANIONS) {
                const companion = COMPANIONS[companionId];
                if (!gameState.codex.companions[companionId]) {
                    gameState.codex.companions[companionId] = {
                        id: companionId,
                        name: companion.name,
                        type: companion.type,
                        rarity: companion.rarity,
                        obtained: false,
                        firstObtainTime: null
                    };
                }
            }
        }
        
        // åˆå§‹åŒ–å¡ç‰Œåœ–é‘‘
        function initCardCodex() {
            for (const cardId in CARDS) {
                const card = CARDS[cardId];
                if (!gameState.codex.cards[cardId]) {
                    gameState.codex.cards[cardId] = {
                        id: cardId,
                        name: card.name,
                        type: card.type,
                        rarity: card.rarity,
                        series: card.series,
                        obtained: false,
                        firstObtainTime: null
                    };
                }
            }
        }
        
        // è¨˜éŒ„æ€ªç‰©æ“Šæ®º
        function recordMonsterKill(monsterName, baseName = null) {
            if (!gameState.codex || !gameState.codex.monsters) {
                initCodexSystem();
            }
            
            // å„ªå…ˆä½¿ç”¨åŸºç¤åç¨±ï¼ˆå»é™¤è©ç¶´ï¼‰
            const nameToRecord = baseName || monsterName;
            
            const monster = gameState.codex.monsters[nameToRecord];
            if (!monster) {
                console.warn('åœ–é‘‘ä¸­æ‰¾ä¸åˆ°æ€ªç‰©ï¼š', nameToRecord, 'ï¼ˆåŸå§‹åç¨±ï¼š', monsterName, 'ï¼‰');
                return;
            }
            
            // é¦–æ¬¡æ“Šæ®º
            if (!monster.unlocked) {
                monster.unlocked = true;
                monster.firstKillTime = Date.now();
                gameState.codex.stats.totalMonstersUnlocked++;
                addLog('åœ–é‘‘', `ğŸ“– è§£é–æ€ªç‰©åœ–é‘‘ï¼š${monster.icon} ${monster.name}`);
                playSound('levelup');
            }
            
            // å¢åŠ æ“Šæ®ºæ•¸
            monster.killCount++;
            
            // æª¢æŸ¥æ˜¯å¦é”åˆ°çå‹µé‡Œç¨‹ç¢‘
            const milestones = [10, 50, 100, 500, 1000];
            milestones.forEach(milestone => {
                if (monster.killCount === milestone && !monster.rewardsCollected.includes(milestone)) {
                    addLog('åœ–é‘‘', `ğŸ‰ ${monster.name} æ“Šæ®ºæ•¸é”åˆ° ${milestone} æ¬¡ï¼å¯åœ¨åœ–é‘‘ä¸­é ˜å–çå‹µï¼`);
                    playSound('reward');
                }
            });
            
            saveGame();
        }
        
        // è¨˜éŒ„è£å‚™ç²å¾—ï¼ˆåªè¨˜éŒ„å¥—è£è£å‚™ï¼‰
        function recordEquipmentObtained(item) {
            if (!gameState.codex || !gameState.codex.equipment) {
                initCodexSystem();
            }
            
            // åªè¨˜éŒ„å¥—è£è£å‚™ï¼Œä½¿ç”¨è£å‚™åç¨±ä½œç‚ºéµå€¼
            if (!item.setName) {
                // ä¸æ˜¯å¥—è£è£å‚™ï¼Œä¸è¨˜éŒ„
                return;
            }
            
            const key = item.name;
            const equipment = gameState.codex.equipment[key];
            
            if (!equipment) {
                console.warn('åœ–é‘‘ä¸­æ‰¾ä¸åˆ°è£å‚™ï¼š', key, 'ï¼ˆåç¨±ï¼š', item.name, 'ï¼Œå¥—è£ï¼š', item.setName, 'ï¼‰');
                return;
            }
            
            // é¦–æ¬¡ç²å¾—
            if (!equipment.obtained) {
                equipment.obtained = true;
                equipment.firstObtainTime = Date.now();
                gameState.codex.stats.totalEquipmentObtained++;
                addLog('åœ–é‘‘', `ğŸ“– è§£é–è£å‚™åœ–é‘‘ï¼š${equipment.icon} ${equipment.name}`);
            }
            
            equipment.obtainCount++;
            
            // æª¢æŸ¥å¥—è£æ”¶é›†ç¨±è™Ÿ
            checkEquipmentCodexTitles();
            
            saveGame();
        }
        
        // è¨˜éŒ„éš¨å¾ç²å¾—
        function recordCompanionObtained(companionId) {
            if (!gameState.codex || !gameState.codex.companions) {
                initCodexSystem();
            }
            
            const companion = gameState.codex.companions[companionId];
            if (!companion) {
                console.warn('åœ–é‘‘ä¸­æ‰¾ä¸åˆ°éš¨å¾ï¼š', companionId);
                return;
            }
            
            // é¦–æ¬¡ç²å¾—
            if (!companion.obtained) {
                companion.obtained = true;
                companion.firstObtainTime = Date.now();
                gameState.codex.stats.totalCompanionsObtained++;
                addLog('åœ–é‘‘', `ğŸ“– è§£é–éš¨å¾åœ–é‘‘ï¼š${companion.name}`);
                
                // æª¢æŸ¥éš¨å¾æ”¶é›†ç¨±è™Ÿ
                checkCompanionCodexTitles();
            }
            
            saveGame();
        }
        
        // è¨˜éŒ„å¡ç‰Œç²å¾—
        function recordCardObtained(cardId) {
            if (!gameState.codex || !gameState.codex.cards) {
                initCodexSystem();
            }
            
            const card = gameState.codex.cards[cardId];
            if (!card) {
                console.warn('åœ–é‘‘ä¸­æ‰¾ä¸åˆ°å¡ç‰Œï¼š', cardId);
                return;
            }
            
            // é¦–æ¬¡ç²å¾—
            if (!card.obtained) {
                card.obtained = true;
                card.firstObtainTime = Date.now();
                gameState.codex.stats.totalCardsObtained++;
                addLog('åœ–é‘‘', `ğŸ“– è§£é–å¡ç‰Œåœ–é‘‘ï¼š${card.name}`);
                
                // æª¢æŸ¥å¡ç‰Œæ”¶é›†ç¨±è™Ÿ
                checkCardCodexTitles();
            }
            
            saveGame();
        }
        
        // ========== åœ–é‘‘çå‹µç³»çµ± ==========
        
        // ç²å–æ€ªç‰©æ“Šæ®ºçå‹µ
        function getMonsterReward(monsterType, milestone) {
            const rewards = {
                normal: {
                    10: { gold: 500, exp: 0, shards: 0, item: null, title: null },
                    50: { gold: 2000, exp: 500, shards: 0, item: null, title: null },
                    100: { gold: 5000, exp: 0, shards: 50, item: null, title: null },
                    500: { gold: 20000, exp: 0, shards: 200, item: 'fine', title: null },
                    1000: { gold: 50000, exp: 0, shards: 500, item: 'rare', title: 'monster_slayer' }
                },
                boss: {
                    10: { gold: 2000, exp: 0, shards: 0, item: null, title: null },
                    50: { gold: 5000, exp: 2000, shards: 0, item: null, title: null },
                    100: { gold: 10000, exp: 0, shards: 200, item: null, title: null },
                    500: { gold: 50000, exp: 0, shards: 500, item: 'rare', title: null },
                    1000: { gold: 100000, exp: 0, shards: 1000, item: 'epic', title: 'boss_conqueror' }
                },
                elite: {
                    10: { gold: 1000, exp: 0, shards: 0, item: null, title: null },
                    50: { gold: 3000, exp: 1000, shards: 0, item: null, title: null },
                    100: { gold: 7000, exp: 0, shards: 100, item: null, title: null },
                    500: { gold: 30000, exp: 0, shards: 300, item: 'fine', title: null },
                    1000: { gold: 70000, exp: 0, shards: 700, item: 'rare', title: 'elite_hunter' }
                }
            };
            
            return rewards[monsterType] ? rewards[monsterType][milestone] : rewards['normal'][milestone];
        }
        
        // é ˜å–æ€ªç‰©æ“Šæ®ºçå‹µ
        function claimMonsterReward(monsterName, milestone) {
            const monster = gameState.codex.monsters[monsterName];
            
            if (!monster) {
                addLog('åœ–é‘‘', 'âŒ æ€ªç‰©ä¸å­˜åœ¨');
                return false;
            }
            
            // æª¢æŸ¥æ˜¯å¦é”åˆ°é‡Œç¨‹ç¢‘
            if (monster.killCount < milestone) {
                addLog('åœ–é‘‘', `âŒ å°šæœªé”åˆ° ${milestone} æ¬¡æ“Šæ®ºï¼ï¼ˆç•¶å‰ï¼š${monster.killCount}ï¼‰`);
                return false;
            }
            
            // æª¢æŸ¥æ˜¯å¦å·²é ˜å–
            if (monster.rewardsCollected.includes(milestone)) {
                addLog('åœ–é‘‘', 'âŒ è©²çå‹µå·²é ˜å–éï¼');
                return false;
            }
            
            // ç²å–çå‹µ
            const reward = getMonsterReward(monster.type, milestone);
            
            // ç™¼æ”¾é‡‘å¹£
            if (reward.gold > 0) {
                gameState.player.gold += reward.gold;
                addLog('çå‹µ', `ğŸ’° ç²å¾—é‡‘å¹£ ${reward.gold}`);
            }
            
            // ç™¼æ”¾ç¶“é©—
            if (reward.exp > 0) {
                gameState.player.exp += reward.exp;
                addLog('çå‹µ', `â­ ç²å¾—ç¶“é©— ${reward.exp}`);
            }
            
            // ç™¼æ”¾ç¢ç‰‡
            if (reward.shards > 0) {
                gameState.companions.shards += reward.shards;
                addLog('çå‹µ', `ğŸ’ ç²å¾—éš¨å¾ç¢ç‰‡ ${reward.shards}`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—éš¨å¾ç¢ç‰‡
                updateQuestProgress('collect_companion_shard', reward.shards);
            }
            
            // ç™¼æ”¾è£å‚™
            if (reward.item) {
                const item = generateItem('normal', reward.item);
                if (item && addToInventory(item)) {
                    addLog('çå‹µ', `ğŸ ç²å¾— ${reward.item} è£å‚™ï¼š${item.name}`);
                }
            }
            
            // ç™¼æ”¾ç¨±è™Ÿ
            if (reward.title) {
                unlockCodexTitle(reward.title, monsterName);
            }
            
            // è¨˜éŒ„å·²é ˜å–
            monster.rewardsCollected.push(milestone);
            
            addLog('åœ–é‘‘', `âœ… æˆåŠŸé ˜å– ${monster.name} ${milestone}æ®ºçå‹µï¼`);
            playSound('reward');
            saveGame();
            updateUI();
            
            return true;
        }
        
        // è§£é–åœ–é‘‘ç¨±è™Ÿ
        function unlockCodexTitle(titleType, monsterName) {
            let titleId;
            
            // æ ¹æ“šæ€ªç‰©é¡å‹ç”Ÿæˆç¨±è™Ÿ ID
            if (titleType === 'monster_slayer') {
                titleId = `monster_master_${monsterName}`;
            } else if (titleType === 'elite_slayer') {
                titleId = `elite_master_${monsterName}`;
            } else if (titleType === 'boss_conqueror') {
                titleId = `boss_master_${monsterName}`;
            }
            
            // æª¢æŸ¥ç¨±è™Ÿæ˜¯å¦å­˜åœ¨æ–¼ TITLES_DATA
            if (!TITLES_DATA[titleId]) {
                console.log(`ç¨±è™Ÿ ${titleId} ä¸å­˜åœ¨æ–¼ TITLES_DATA`);
                return;
            }
            
            // è§£é–ç¨±è™Ÿ
            if (!gameState.titles.unlocked.includes(titleId)) {
                gameState.titles.unlocked.push(titleId);
                const titleData = TITLES_DATA[titleId];
                addLog('ç¨±è™Ÿ', `ğŸ† è§£é–ç¨±è™Ÿï¼š${titleData.name}ï¼`);
                playSound('levelup');
            }
        }
        
        // æª¢æŸ¥è£å‚™æ”¶é›†ç¨±è™Ÿ
        function checkEquipmentCodexTitles() {
            const totalObtained = gameState.codex.stats.totalEquipmentObtained;
            
            // æª¢æŸ¥å¥—è£å®Œæˆç¨±è™Ÿ
            const setCompletion = {};
            for (const key in gameState.codex.equipment) {
                const eq = gameState.codex.equipment[key];
                if (eq.obtained) {
                    if (!setCompletion[eq.setName]) {
                        setCompletion[eq.setName] = 0;
                    }
                    setCompletion[eq.setName]++;
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰å¥—è£å·²å®Œæˆï¼ˆ4ä»¶ï¼‰
            for (const setName in setCompletion) {
                if (setCompletion[setName] >= 4) {
                    const titleId = `equipment_set_${setName}`;
                    if (TITLES_DATA[titleId] && !gameState.titles.unlocked.includes(titleId)) {
                        gameState.titles.unlocked.push(titleId);
                        const titleData = TITLES_DATA[titleId];
                        addLog('ç¨±è™Ÿ', `ğŸ† è§£é–ç¨±è™Ÿï¼š${titleData.name}ï¼`);
                        playSound('levelup');
                    }
                }
            }
            
            // æª¢æŸ¥ç¸½æ”¶é›†ç¨±è™Ÿ
            if (totalObtained >= 16) {
                const titleId = 'equipment_collector_half';
                if (TITLES_DATA[titleId] && !gameState.titles.unlocked.includes(titleId)) {
                    gameState.titles.unlocked.push(titleId);
                    const titleData = TITLES_DATA[titleId];
                    addLog('ç¨±è™Ÿ', `ğŸ† è§£é–ç¨±è™Ÿï¼š${titleData.name}ï¼`);
                    playSound('levelup');
                }
            }
            
            if (totalObtained >= 32) {
                const titleId = 'equipment_collector_full';
                if (TITLES_DATA[titleId] && !gameState.titles.unlocked.includes(titleId)) {
                    gameState.titles.unlocked.push(titleId);
                    const titleData = TITLES_DATA[titleId];
                    addLog('ç¨±è™Ÿ', `ğŸ† è§£é–ç¨±è™Ÿï¼š${titleData.name}ï¼`);
                    playSound('levelup');
                }
            }
        }
        
        // æª¢æŸ¥éš¨å¾æ”¶é›†ç¨±è™Ÿ
        function checkCompanionCodexTitles() {
            const totalObtained = gameState.codex.stats.totalCompanionsObtained;
            
            const milestones = [
                { count: 5, titleId: 'companion_collector_5' },
                { count: 10, titleId: 'companion_collector_10' },
                { count: 15, titleId: 'companion_collector_15' },
                { count: 20, titleId: 'companion_collector_20' }
            ];
            
            for (const milestone of milestones) {
                if (totalObtained >= milestone.count) {
                    const titleId = milestone.titleId;
                    if (TITLES_DATA[titleId] && !gameState.titles.unlocked.includes(titleId)) {
                        gameState.titles.unlocked.push(titleId);
                        const titleData = TITLES_DATA[titleId];
                        addLog('ç¨±è™Ÿ', `ğŸ† è§£é–ç¨±è™Ÿï¼š${titleData.name}ï¼`);
                        playSound('levelup');
                    }
                }
            }
        }
        
        // æª¢æŸ¥å¡ç‰Œæ”¶é›†ç¨±è™Ÿ
        function checkCardCodexTitles() {
            const totalObtained = gameState.codex.stats.totalCardsObtained;
            
            const milestones = [
                { count: 10, titleId: 'card_collector_10' },
                { count: 20, titleId: 'card_collector_20' },
                { count: 30, titleId: 'card_collector_30' },
                { count: 40, titleId: 'card_collector_40' }
            ];
            
            for (const milestone of milestones) {
                if (totalObtained >= milestone.count) {
                    const titleId = milestone.titleId;
                    if (TITLES_DATA[titleId] && !gameState.titles.unlocked.includes(titleId)) {
                        gameState.titles.unlocked.push(titleId);
                        const titleData = TITLES_DATA[titleId];
                        addLog('ç¨±è™Ÿ', `ğŸ† è§£é–ç¨±è™Ÿï¼š${titleData.name}ï¼`);
                        playSound('levelup');
                    }
                }
            }
        }
        
        // ç²å–åœ–é‘‘é€²åº¦
        function getCodexProgress(category) {
            const codex = gameState.codex[category];
            const total = Object.keys(codex).length;
            const unlocked = Object.values(codex).filter(item => 
                category === 'monsters' ? item.unlocked : item.obtained
            ).length;
            
            return {
                unlocked: unlocked,
                total: total,
                percentage: (unlocked / total * 100).toFixed(1)
            };
        }
        
        // ç²å–éš¨å¾
        function obtainCompanion(companionId) {
            initCompanionSystem();
            const companion = COMPANIONS[companionId];
            if (!companion) {
                addLog('ç³»çµ±', 'âŒ éš¨å¾ä¸å­˜åœ¨');
                return false;
            }
            const existing = gameState.companions.owned.find(c => c.id === companionId);
            if (existing) {
                // é‡è¤‡éš¨å¾è½‰æ›ç‚ºç¢ç‰‡
                const shardAmount = getCompanionShardAmount(companion.rarity);
                gameState.companions.shards += shardAmount;
                addLog('éš¨å¾', `å·²æ“æœ‰ ${companion.name}ï¼Œè½‰æ›ç‚º ${shardAmount} å€‹éš¨å¾ç¢ç‰‡ï¼ï¼ˆç¸½è¨ˆ: ${gameState.companions.shards}ï¼‰`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—éš¨å¾ç¢ç‰‡
                updateQuestProgress('collect_companion_shard', shardAmount);
                
                saveGame();
                return false;
            }
            gameState.companions.owned.push({
                id: companionId,
                level: 1,
                exp: 0,
                expToNext: 100
            });
            
            // è¨˜éŒ„éš¨å¾åœ–é‘‘
            recordCompanionObtained(companionId);
            
            addLog('éš¨å¾', `ğŸ‰ ç²å¾—æ–°éš¨å¾ï¼š${companion.name}ï¼`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå¬å–šéš¨å¾
            updateQuestProgress('summon_companion', 1);
            
            playSound('levelup');
            saveGame();
            return true;
        }

        // ç²å–éš¨å¾ç¢ç‰‡æ•¸é‡ï¼ˆæ ¹æ“šå“è³ªï¼‰
        function getCompanionShardAmount(rarity) {
            const shardAmounts = {
                'common': 5,
                'fine': 10,
                'rare': 20,
                'epic': 40,
                'legendary': 60,
                'eternal': 100
            };
            return shardAmounts[rarity.toLowerCase()] || 5;
        }

        // ç²å–éš¨å¾è£å‚™
        function obtainEquipment(equipmentId) {
            initCompanionSystem();
            const equipment = COMPANION_EQUIPMENT[equipmentId];
            if (!equipment) {
                addLog('ç³»çµ±', 'âŒ è£å‚™ä¸å­˜åœ¨');
                return false;
            }
            const existing = gameState.companions.ownedEquipment.find(e => e.id === equipmentId);
            if (existing) {
                // é‡è¤‡è£å‚™è½‰æ›ç‚ºç¢ç‰‡
                const shardAmount = getEquipmentShardAmount(equipment.rarity);
                gameState.companions.shards += shardAmount;
                addLog('éš¨å¾', `å·²æ“æœ‰ ${equipment.icon}${equipment.name}ï¼Œè½‰æ›ç‚º ${shardAmount} å€‹éš¨å¾ç¢ç‰‡ï¼ï¼ˆç¸½è¨ˆ: ${gameState.companions.shards}ï¼‰`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—éš¨å¾ç¢ç‰‡
                updateQuestProgress('collect_companion_shard', shardAmount);
                
                saveGame();
                return false;
            }
            gameState.companions.ownedEquipment.push({
                id: equipmentId,
                level: 1
            });
            addLog('éš¨å¾', `ğŸ‰ ç²å¾—æ–°è£å‚™ï¼š${equipment.icon}${equipment.name}ï¼`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—éš¨å¾è£å‚™
            updateQuestProgress('collect_companion_equipment', 1);
            
            playSound('levelup');
            saveGame();
            return true;
        }

        // ç²å–è£å‚™ç¢ç‰‡æ•¸é‡ï¼ˆæ ¹æ“šå“è³ªï¼‰
        function getEquipmentShardAmount(rarity) {
            const shardAmounts = {
                'common': 10,
                'rare': 30,
                'epic': 60
            };
            return shardAmounts[rarity.toLowerCase()] || 10;
        }

        // è£å‚™éš¨å¾è£å‚™
        function equipCompanionEquipment(equipmentId) {
            initCompanionSystem();
            const owned = gameState.companions.ownedEquipment.find(e => e.id === equipmentId);
            if (!owned) {
                addLog('éš¨å¾', 'âŒ ä½ æ²’æœ‰é€™å€‹è£å‚™');
                return false;
            }
            gameState.companions.equipment = equipmentId;
            const equipment = COMPANION_EQUIPMENT[equipmentId];
            addLog('éš¨å¾', `âœ… è£å‚™äº† ${equipment.icon}${equipment.name}`);
            saveGame();
            return true;
        }

        // å¸ä¸‹éš¨å¾è£å‚™
        function unequipCompanionEquipment() {
            initCompanionSystem();
            if (!gameState.companions.equipment) {
                addLog('éš¨å¾', 'âŒ æ²’æœ‰è£å‚™è£å‚™');
                return false;
            }
            gameState.companions.equipment = null;
            addLog('éš¨å¾', 'âœ… å·²å¸ä¸‹è£å‚™');
            saveGame();
            return true;
        }

        // å‡ç´šéš¨å¾è£å‚™
        function upgradeCompanionEquipment(equipmentId) {
            initCompanionSystem();
            const owned = gameState.companions.ownedEquipment.find(e => e.id === equipmentId);
            if (!owned) {
                addLog('éš¨å¾', 'âŒ ä½ æ²’æœ‰é€™å€‹è£å‚™');
                return false;
            }
            if (owned.level >= 10) {
                addLog('éš¨å¾', 'âŒ è£å‚™å·²é”æœ€é«˜ç­‰ç´š');
                return false;
            }
            const cost = getEquipmentUpgradeCost(owned.level);
            if (gameState.companions.shards < cost) {
                addLog('éš¨å¾', `âŒ éš¨å¾ç¢ç‰‡ä¸è¶³ï¼ˆéœ€è¦ ${cost}ï¼Œæ“æœ‰ ${gameState.companions.shards}ï¼‰`);
                return false;
            }
            gameState.companions.shards -= cost;
            owned.level++;
            const equipment = COMPANION_EQUIPMENT[equipmentId];
            addLog('éš¨å¾', `âœ¨ ${equipment.icon}${equipment.name} å‡ç´šåˆ° Lv.${owned.level}ï¼`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå‡ç´šéš¨å¾è£å‚™
            updateQuestProgress('upgrade_companion_equipment', 1);
            
            playSound('levelup');
            saveGame();
            return true;
        }

        // ç²å–è£å‚™å‡ç´šæ‰€éœ€ç¢ç‰‡
        function getEquipmentUpgradeCost(currentLevel) {
            const costs = [10, 15, 20, 25, 30, 35, 40, 45, 50]; // Lv.1-9å‡ç´šæˆæœ¬
            return costs[currentLevel - 1] || 50;
        }

        // è£å‚™éš¨å¾
        function equipCompanion(companionId) {
            initCompanionSystem();
            const owned = gameState.companions.owned.find(c => c.id === companionId);
            if (!owned) {
                addLog('éš¨å¾', 'âŒ ä½ æ²’æœ‰é€™å€‹éš¨å¾');
                return false;
            }
            const companion = COMPANIONS[companionId];
            gameState.companions.active = companionId;
            recalculateStats();
            addLog('éš¨å¾', `âœ… è£å‚™éš¨å¾ï¼š${companion.name}`);
            saveGame();
            return true;
        }

        // å¸ä¸‹éš¨å¾
        function unequipCompanion() {
            if (!gameState.companions || !gameState.companions.active) return false;
            const companionId = gameState.companions.active;
            const companion = COMPANIONS[companionId];
            gameState.companions.active = null;
            recalculateStats();
            addLog('éš¨å¾', `ğŸ“¤ å¸ä¸‹éš¨å¾ï¼š${companion.name}`);
            saveGame();
            return true;
        }

        // ç²å–ç•¶å‰éš¨å¾
        function getActiveCompanion() {
            if (!gameState.companions || !gameState.companions.active) return null;
            const companionId = gameState.companions.active;
            const companionData = COMPANIONS[companionId];
            const ownedData = gameState.companions.owned.find(c => c.id === companionId);
            if (!companionData || !ownedData) return null;
            return { ...companionData, ...ownedData };
        }

        // æ‡‰ç”¨éš¨å¾è¢«å‹•æŠ€èƒ½
        function applyCompanionPassiveSkills() {
            const companion = getActiveCompanion();
            if (!companion) return {};
            const bonuses = { atk: 0, def: 0, hp: 0, crit: 0, critDmg: 0, dmgRed: 0, lifeSteal: 0, goldBonus: 0, expBonus: 0, dropBonus: 0 };
            companion.skills.forEach(skill => {
                if (skill.trigger !== 'passive') return;
                const levelBonus = (companion.level - 1) * 0.02;
                const effectValue = skill.value * (1 + levelBonus);
                switch (skill.type) {
                    case 'buff_atk': bonuses.atk += effectValue; break;
                    case 'buff_def': bonuses.def += effectValue; break;
                    case 'buff_hp': bonuses.hp += effectValue; break;
                    case 'buff_dmgred': bonuses.dmgRed += effectValue; break;
                    case 'buff_lifesteal': bonuses.lifeSteal += effectValue; break;
                    case 'buff_crit':
                        if (skill.statType === 'critDmg') bonuses.critDmg += effectValue;
                        else bonuses.crit += effectValue;
                        break;
                }
            });
            return bonuses;
        }

        // ç²å–éš¨å¾è£å‚™çµ„åˆæ•ˆæœ
        function getCompanionEquipmentCombo() {
            initCompanionSystem();
            const bonuses = {
                atk: 0, def: 0, hp: 0, crit: 0, critDmg: 0,
                dmgRed: 0, lifeSteal: 0, regen: 0, reflect: 0,
                postBattleHeal: 0, lowHpHeal: 0, ignoreDefense: 0
            };
            
            // ç²å–ç•¶å‰è£å‚™çš„éš¨å¾å’Œè£å‚™
            const activeCompanionId = gameState.companions.active;
            const activeEquipmentId = gameState.companions.equipment;
            
            if (!activeCompanionId || !activeEquipmentId) {
                return bonuses; // æ²’æœ‰è£å‚™å…©è€…ï¼Œç„¡çµ„åˆ
            }
            
            const companion = COMPANIONS[activeCompanionId];
            const equipment = COMPANION_EQUIPMENT[activeEquipmentId];
            const ownedEquipment = gameState.companions.ownedEquipment.find(e => e.id === activeEquipmentId);
            
            if (!companion || !equipment || !ownedEquipment) {
                return bonuses;
            }
            
            // æ‡‰ç”¨è£å‚™åŸºç¤æ•ˆæœï¼ˆæ ¹æ“šç­‰ç´šæå‡ï¼‰
            const levelMultiplier = 1 + (ownedEquipment.level - 1) * 0.1; // æ¯ç´š+10%
            Object.keys(equipment.effects).forEach(key => {
                if (bonuses.hasOwnProperty(key)) {
                    bonuses[key] += equipment.effects[key] * levelMultiplier;
                }
            });
            
            // ç²å–éš¨å¾é¡å‹
            const companionType = companion.type; // attack, defense, heal, balanced
            const equipmentType = equipment.type; // attack, defense, heal
            
            // è¨ˆç®—çµ„åˆæ•ˆæœ
            if (companionType === 'balanced') {
                // å¹³è¡¡å‹éš¨å¾ + ä»»æ„è£å‚™ = è£å‚™æ•ˆæœ+25%
                Object.keys(equipment.effects).forEach(key => {
                    if (bonuses.hasOwnProperty(key)) {
                        bonuses[key] *= 1.25;
                    }
                });
            } else if (companionType === equipmentType) {
                // åŒé¡å‹çµ„åˆï¼šå¼·åŠ›åŠ æˆ
                if (companionType === 'attack') {
                    // æ¥µé™æ”»å‹¢ï¼šæ”»æ“Š+10%, æš´å‚·+15%
                    bonuses.atk += 0.10;
                    bonuses.critDmg += 0.15;
                } else if (companionType === 'defense') {
                    // éµå£é˜²ç·šï¼šé˜²ç¦¦+10%, ç”Ÿå‘½+15%
                    bonuses.def += 0.10;
                    bonuses.hp += 0.15;
                } else if (companionType === 'heal') {
                    // æ°¸çºŒå†ç”Ÿï¼šå›å¾©+50%, å¸è¡€+5%
                    bonuses.regen *= 1.5;
                    bonuses.lifeSteal += 0.05;
                }
            } else {
                // æ··æ­çµ„åˆï¼šç‰¹æ®Šæ•ˆæœ
                if (companionType === 'attack' && equipmentType === 'defense') {
                    // æ”»é˜²ä¸€é«”ï¼šæ”»æ“Š+5%, é˜²ç¦¦+5%
                    bonuses.atk += 0.05;
                    bonuses.def += 0.05;
                } else if (companionType === 'attack' && equipmentType === 'heal') {
                    // ç‹‚æˆ°å£«ï¼šæ”»æ“Š+8%, å¸è¡€+3%
                    bonuses.atk += 0.08;
                    bonuses.lifeSteal += 0.03;
                } else if (companionType === 'defense' && equipmentType === 'attack') {
                    // åæ“Šæˆ°å£«ï¼šé˜²ç¦¦+5%, åå‚·+3%
                    bonuses.def += 0.05;
                    bonuses.reflect += 0.03;
                } else if (companionType === 'defense' && equipmentType === 'heal') {
                    // ä¸æ­»ä¹‹èº«ï¼šç”Ÿå‘½+10%, å›å¾©+1%
                    bonuses.hp += 0.10;
                    bonuses.regen += 0.01;
                } else if (companionType === 'heal' && equipmentType === 'attack') {
                    // å¸è¡€é¬¼ï¼šå¸è¡€+5%, æš´æ“Š+3%
                    bonuses.lifeSteal += 0.05;
                    bonuses.crit += 0.03;
                } else if (companionType === 'heal' && equipmentType === 'defense') {
                    // ç”Ÿå‘½å ¡å£˜ï¼šç”Ÿå‘½+8%, æ¸›å‚·+3%
                    bonuses.hp += 0.08;
                    bonuses.dmgRed += 0.03;
                }
            }
            
            return bonuses;
        }

        // è§¸ç™¼éš¨å¾æŠ€èƒ½
        function triggerCompanionSkill(triggerType, context = {}) {
            const companion = getActiveCompanion();
            if (!companion) return null;
            const results = [];
            companion.skills.forEach(skill => {
                if (skill.trigger !== triggerType) return;
                if (skill.cooldown) {
                    const cooldownKey = `${companion.id}_${skill.type}`;
                    const currentCooldown = gameState.companions.cooldowns[cooldownKey] || 0;
                    if (currentCooldown > 0) return;
                }
                const levelBonus = (companion.level - 1) * 0.02;
                const effectValue = skill.value * (1 + levelBonus);
                let result = null;
                switch (skill.type) {
                    case 'heal_over_time':
                        if (triggerType === 'turn_start') {
                            const healAmount = Math.floor(gameState.player.maxHp * effectValue / 100);
                            gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                            result = { type: 'heal', amount: healAmount, message: `ğŸ’š ${skill.name}ï¼å›å¾© ${healAmount} é»ç”Ÿå‘½` };
                        }
                        break;
                    case 'emergency_heal':
                        if (triggerType === 'low_hp' && context.hpPercent < skill.threshold) {
                            const healAmount = Math.floor(gameState.player.maxHp * effectValue / 100);
                            gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                            const cooldownKey = `${companion.id}_${skill.type}`;
                            gameState.companions.cooldowns[cooldownKey] = skill.cooldown;
                            result = { type: 'heal', amount: healAmount, message: `ğŸš‘ ${skill.name}ï¼ç·Šæ€¥å›å¾© ${healAmount} é»ç”Ÿå‘½` };
                        }
                        break;
                    case 'post_battle_heal':
                        if (triggerType === 'battle_end') {
                            const healAmount = Math.floor(gameState.player.maxHp * effectValue / 100);
                            gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                            result = { type: 'heal', amount: healAmount, message: `ğŸ’Š ${skill.name}ï¼æˆ°å¾Œå›å¾© ${healAmount} é»ç”Ÿå‘½` };
                        }
                        break;
                    case 'debuff_atk':
                    case 'debuff_def':
                    case 'debuff_crit':
                        if (triggerType === 'battle_start' && context.enemy) {
                            result = { type: 'debuff', skillType: skill.type, value: effectValue, message: `ğŸŒ€ ${skill.name}ï¼${skill.description}` };
                        }
                        break;
                }
                if (result) results.push(result);
            });
            return results.length > 0 ? results : null;
        }

        // éš¨å¾ç²å¾—ç¶“é©—
        function addCompanionExp(amount) {
            const companion = getActiveCompanion();
            if (!companion) return;
            const ownedData = gameState.companions.owned.find(c => c.id === companion.id);
            if (!ownedData) return;
            ownedData.exp += amount;
            // é¡¯ç¤ºç¶“é©—ç²å¾—æ—¥èªŒ
            addLog('éš¨å¾', `ğŸ¾ ${companion.name} ç²å¾— ${amount} é»ç¶“é©— (${ownedData.exp}/${ownedData.expToNext})`);
            while (ownedData.exp >= ownedData.expToNext && ownedData.level < companion.maxLevel) {
                ownedData.exp -= ownedData.expToNext;
                ownedData.level++;
                ownedData.expToNext = Math.floor(ownedData.expToNext * 1.15);
                addLog('éš¨å¾', `ğŸ‰ ${companion.name} å‡ç´šåˆ° Lv.${ownedData.level}ï¼æŠ€èƒ½æ•ˆæœæå‡ï¼`);
                playSound('levelup');
            }
        }

        // æ¸›å°‘éš¨å¾æŠ€èƒ½å†·å´
        function reduceCompanionCooldowns() {
            if (!gameState.companions || !gameState.companions.cooldowns) return;
            for (const key in gameState.companions.cooldowns) {
                if (gameState.companions.cooldowns[key] > 0) {
                    gameState.companions.cooldowns[key]--;
                }
            }
        }

        // ========== éš¨å¾UIå‡½æ•¸ ==========
        
        function openCompanionModal() {
            initCompanionSystem();
            updateCompanionModal();
            document.getElementById('companion-modal').classList.add('active');
        }
        
        function closeCompanionModal() {
            document.getElementById('companion-modal').classList.remove('active');
        }
        
        function updateCompanionModal() {
            // æ›´æ–°ç•¶å‰è£å‚™çš„éš¨å¾é¡¯ç¤º
            const activeCompanion = getActiveCompanion();
            const activeCompanionInfo = document.getElementById('active-companion-info');
            
            if (activeCompanion) {
                const rarityColor = getRarityColor(activeCompanion.rarity);
                // è¨ˆç®—å¯¦éš›æŠ€èƒ½æ•ˆæœ
                const levelBonus = (activeCompanion.level - 1) * 0.02;
                let skillsHtml = activeCompanion.skills.map(skill => {
                    const effectValue = skill.value * (1 + levelBonus);
                    let displayText = skill.description;
                    // æ›¿æ›æè¿°ä¸­çš„æ•¸å€¤ç‚ºå¯¦éš›æ•ˆæœ
                    if (skill.description.includes('%')) {
                        displayText = skill.description.replace(/\d+(\.\d+)?%/, `${effectValue.toFixed(1)}%`);
                    } else if (skill.description.match(/\d+/)) {
                        displayText = skill.description.replace(/\d+/, Math.floor(effectValue));
                    }
                    return `<div style="color: #7a8fb8; font-size: 0.85rem; margin: 3px 0;">â€¢ ${skill.name}: ${displayText}</div>`;
                }).join('');
                
                activeCompanionInfo.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div>
                            <div style="font-size: 1.1rem; font-weight: bold; color: ${rarityColor};">${activeCompanion.name}</div>
                            <div style="color: #7a8fb8; font-size: 0.85rem; margin-top: 3px;">${activeCompanion.description}</div>
                        </div>
                        <button onclick="unequipCompanion(); updateCompanionModal(); updateCompanionDisplay();" style="padding: 6px 12px; font-size: 0.85rem; background: rgba(255, 68, 68, 0.2); border: 1px solid #f44336; color: #f44336;">ğŸ“¤ å¸ä¸‹</button>
                    </div>
                    <div style="display: flex; gap: 15px; margin-bottom: 8px;">
                        <div style="color: #7a8fb8; font-size: 0.85rem;">ğŸ¯ ç­‰ç´š: <span style="color: #00ff88; font-weight: bold;">Lv.${activeCompanion.level}</span></div>
                        <div style="color: #7a8fb8; font-size: 0.85rem;">â­ ç¶“é©—: <span style="color: #4EA5FF; font-weight: bold;">${activeCompanion.exp}/${activeCompanion.expToNext}</span></div>
                        <div style="color: #7a8fb8; font-size: 0.85rem;">ğŸ† å“è³ª: <span style="color: ${rarityColor}; font-weight: bold;">${activeCompanion.rarity}</span></div>
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px;">
                        <div style="color: #00ff88; font-size: 0.9rem; font-weight: bold; margin-bottom: 5px;">âœ¨ æŠ€èƒ½æ•ˆæœ</div>
                        ${skillsHtml}
                    </div>
                `;
            } else {
                activeCompanionInfo.innerHTML = '<div style="text-align: center; color: #7a8fb8;">ç„¡</div>';
            }
            
            // æ›´æ–°ç•¶å‰è£å‚™çš„è£å‚™é¡¯ç¤º
            const activeEquipmentId = gameState.companions.equipment;
            const activeEquipmentInfo = document.getElementById('active-equipment-info');
            
            if (activeEquipmentId) {
                const equipment = COMPANION_EQUIPMENT[activeEquipmentId];
                const ownedEquipment = gameState.companions.ownedEquipment.find(e => e.id === activeEquipmentId);
                if (equipment && ownedEquipment) {
                    const rarityColor = getRarityColor(equipment.rarity);
                    const levelMultiplier = 1 + (ownedEquipment.level - 1) * 0.1;
                    const currentEffect = (equipment.effect * levelMultiplier).toFixed(1);
                    const typeText = equipment.type === 'attack' ? 'æ”»æ“Š' : equipment.type === 'defense' ? 'é˜²ç¦¦' : 'å›å¾©';
                    
                    activeEquipmentInfo.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 1.1rem; font-weight: bold; color: ${rarityColor};">${equipment.icon} ${equipment.name}</div>
                                <div style="color: #7a8fb8; font-size: 0.85rem; margin-top: 3px;">${equipment.description}</div>
                            </div>
                            <button onclick="unequipEquipment(); updateCompanionModal(); updateCompanionDisplay();" style="padding: 6px 12px; font-size: 0.85rem; background: rgba(255, 68, 68, 0.2); border: 1px solid #f44336; color: #f44336;">ğŸ“¤ å¸ä¸‹</button>
                        </div>
                        <div style="display: flex; gap: 15px; margin-bottom: 8px;">
                            <div style="color: #7a8fb8; font-size: 0.85rem;">ğŸ¯ ç­‰ç´š: <span style="color: #00ff88; font-weight: bold;">Lv.${ownedEquipment.level}</span></div>
                            <div style="color: #7a8fb8; font-size: 0.85rem;">ğŸ† å“è³ª: <span style="color: ${rarityColor}; font-weight: bold;">${equipment.rarity}</span></div>
                            <div style="color: #7a8fb8; font-size: 0.85rem;">ğŸ“Š é¡å‹: <span style="color: #4EA5FF; font-weight: bold;">${typeText}</span></div>
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px;">
                            <div style="color: #00ff88; font-size: 0.9rem; font-weight: bold; margin-bottom: 5px;">âœ¨ è£å‚™æ•ˆæœ</div>
                            <div style="color: #7a8fb8; font-size: 0.85rem;">${equipment.statType} +${currentEffect}%</div>
                        </div>
                    `;
                }
            } else {
                activeEquipmentInfo.innerHTML = '<div style="text-align: center; color: #7a8fb8;">ç„¡</div>';
            }
            
            // æ›´æ–°çµ„åˆæ•ˆæœé¡¯ç¤º
            updateComboEffectDisplay();
            
            // æ›´æ–°ç¢ç‰‡é¡¯ç¤º
            const shardsDisplay = document.getElementById('equipment-shards-display');
            if (shardsDisplay) {
                shardsDisplay.textContent = gameState.companions.shards || 0;
            }
            
            // æ›´æ–°è£å‚™åˆ—è¡¨
            updateEquipmentList();
            
            // æ›´æ–°éš¨å¾åˆ—è¡¨
            const companionList = document.getElementById('companion-list');
            if (!gameState.companions.owned || gameState.companions.owned.length === 0) {
                companionList.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #7a8fb8; padding: 30px;">ä½ é‚„æ²’æœ‰éš¨å¾ï¼Œå»å•†åº—è³¼è²·å§ï¼</div>';
                return;
            }
            
            companionList.innerHTML = gameState.companions.owned.map(owned => {
                const companion = COMPANIONS[owned.id];
                if (!companion) return '';
                
                const isActive = gameState.companions.active === owned.id;
                const rarityColor = getRarityColor(companion.rarity);
                const typeIcon = { heal: 'ğŸ’š', buff: 'â¬†ï¸', debuff: 'â¬‡ï¸', resource: 'ğŸ’°' }[companion.type] || 'â“';
                
                // è¨ˆç®—å¯¦éš›æŠ€èƒ½æ•ˆæœ
                const levelBonus = (owned.level - 1) * 0.02;
                let skillsHtml = companion.skills.map(skill => {
                    const effectValue = skill.value * (1 + levelBonus);
                    let displayText = skill.description;
                    // æ›¿æ›æè¿°ä¸­çš„æ•¸å€¤ç‚ºå¯¦éš›æ•ˆæœ
                    if (skill.description.includes('%')) {
                        displayText = skill.description.replace(/\d+(\.\d+)?%/, `${effectValue.toFixed(1)}%`);
                    } else if (skill.description.match(/\d+/)) {
                        displayText = skill.description.replace(/\d+/, Math.floor(effectValue));
                    }
                    return `<div style="color: #7a8fb8; font-size: 0.8rem; margin: 2px 0;">â€¢ ${skill.name}: ${displayText}</div>`;
                }).join('');
                
                return `
                    <div style="background: ${isActive ? 'rgba(0, 255, 136, 0.08)' : 'rgba(78, 165, 255, 0.05)'}; padding: 12px; border-radius: 8px; border: 2px solid ${isActive ? 'rgba(0, 255, 136, 0.4)' : 'rgba(78, 165, 255, 0.3)'}; position: relative;">
                        ${isActive ? '<div style="position: absolute; top: 8px; right: 8px; background: #00ff88; color: #000; padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; font-weight: bold;">âœ… å·²è£å‚™</div>' : ''}
                        <div style="font-size: 1rem; font-weight: bold; color: ${rarityColor}; margin-bottom: 5px;">${typeIcon} ${companion.name}</div>
                        <div style="color: #7a8fb8; font-size: 0.8rem; margin-bottom: 8px;">${companion.description}</div>
                        <div style="display: flex; gap: 10px; margin-bottom: 8px; font-size: 0.8rem;">
                            <div style="color: #7a8fb8;">ğŸ¯ Lv.<span style="color: #00ff88; font-weight: bold;">${owned.level}</span></div>
                            <div style="color: #7a8fb8;">â­ <span style="color: #4EA5FF;">${owned.exp}/${owned.expToNext}</span></div>
                            <div style="color: #7a8fb8;">ğŸ† <span style="color: ${rarityColor};">${companion.rarity}</span></div>
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 6px; border-radius: 5px; margin-bottom: 8px; max-height: 80px; overflow-y: auto;">
                            <div style="color: #00ff88; font-size: 0.85rem; font-weight: bold; margin-bottom: 3px;">âœ¨ æŠ€èƒ½</div>
                            ${skillsHtml}
                        </div>
                        ${!isActive ? `<button onclick="equipCompanion('${owned.id}'); updateCompanionModal(); updateCompanionDisplay();" style="width: 100%; padding: 6px; font-size: 0.85rem; background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%); color: #000; font-weight: bold;">âœ… è£å‚™</button>` : ''}
                    </div>
                `;
            }).join('');
        }
        
        function updateCompanionDisplay() {
            initCompanionSystem();
            const companion = getActiveCompanion();
            const activeEquipmentId = gameState.companions.equipment;
            const companionInfo = document.getElementById('companion-info');
            
            // éš¨å¾æ§½é¡¯ç¤º
            let companionHtml = '';
            if (companion) {
                const rarityColor = getRarityColor(companion.rarity);
                
                // ç”ŸæˆæŠ€èƒ½ç°¡è¦æè¿°
                let skillsHtml = '';
                if (companion.skills && companion.skills.length > 0) {
                    const levelBonus = (companion.level - 1) * 0.02;
                    const skillDescriptions = companion.skills.map(skill => {
                        const effectValue = (skill.value * (1 + levelBonus)).toFixed(1);
                        
                        // æ ¹æ“šæŠ€èƒ½é¡å‹ç”Ÿæˆç°¡çŸ­æè¿°
                        let description = '';
                        switch (skill.type) {
                            case 'heal_over_time':
                                description = `å›å¾©${effectValue}%`;
                                break;
                            case 'emergency_heal':
                                description = `ç·Šæ€¥æ²»ç™‚${effectValue}%`;
                                break;
                            case 'battle_heal':
                            case 'post_battle_heal':
                                description = `æˆ°å¾Œå›å¾©${effectValue}%`;
                                break;
                            case 'buff_atk':
                                description = `æ”»æ“Š+${effectValue}%`;
                                break;
                            case 'buff_def':
                                description = `é˜²ç¦¦+${effectValue}%`;
                                break;
                            case 'buff_hp':
                                description = `ç”Ÿå‘½+${effectValue}%`;
                                break;
                            case 'buff_dmgred':
                                description = `æ¸›å‚·+${effectValue}%`;
                                break;
                            case 'buff_lifesteal':
                                description = `å¸è¡€+${effectValue}%`;
                                break;
                            case 'buff_crit':
                                description = skill.statType === 'critDmg' ? `çˆ†å‚·+${effectValue}%` : `çˆ†ç‡+${effectValue}%`;
                                break;
                            case 'debuff_def':
                                description = `é™é˜²${effectValue}%`;
                                break;
                            case 'debuff_atk':
                                description = `é™æ”»${effectValue}%`;
                                break;
                            default:
                                description = skill.description;
                        }
                        
                        return description;
                    });
                    skillsHtml = `
                        <div style="background: rgba(78, 165, 255, 0.1); padding: 3px 5px; border-radius: 3px; margin-top: 3px;">
                            <div style="color: #4ea5ff; font-size: 0.65rem;">âœ¨ ${skillDescriptions.join(' | ')}</div>
                        </div>
                    `;
                }
                
                companionHtml = `
                    <div style="font-weight: bold; color: ${rarityColor}; margin-bottom: 2px; font-size: 0.8rem;">${companion.name}</div>
                    <div style="color: #7a8fb8; font-size: 0.65rem;">Lv.${companion.level} | ${companion.rarity}</div>
                    ${skillsHtml}
                `;
            } else {
                companionHtml = '<div style="color: #7a8fb8; font-size: 0.7rem;">ç„¡éš¨å¾</div>';
            }
            
            // è£å‚™æ§½é¡¯ç¤º
            let equipmentHtml = '';
            let equipmentEffectHtml = '';
            if (activeEquipmentId) {
                const equipment = COMPANION_EQUIPMENT[activeEquipmentId];
                const ownedEquipment = gameState.companions.ownedEquipment.find(e => e.id === activeEquipmentId);
                if (equipment && ownedEquipment) {
                    const rarityColor = getRarityColor(equipment.rarity);
                    const levelMultiplier = 1 + (ownedEquipment.level - 1) * 0.1;
                    const currentEffect = (equipment.effect * levelMultiplier).toFixed(1);
                    
                    equipmentHtml = `
                        <div style="font-weight: bold; color: ${rarityColor}; margin-bottom: 2px; font-size: 0.8rem;">${equipment.icon}${equipment.name}</div>
                        <div style="color: #7a8fb8; font-size: 0.65rem;">Lv.${ownedEquipment.level} | ${equipment.rarity}</div>
                    `;
                    
                    equipmentEffectHtml = `
                        <div style="background: rgba(78, 165, 255, 0.1); padding: 3px 5px; border-radius: 3px; margin-top: 3px;">
                            <div style="color: #4ea5ff; font-size: 0.65rem;">âœ¨ ${equipment.statType} +${currentEffect}%</div>
                        </div>
                    `;
                }
            } else {
                equipmentHtml = '<div style="color: #7a8fb8; font-size: 0.7rem;">ç„¡è£å‚™</div>';
            }
            
            // çµ„åˆæ•ˆæœé¡¯ç¤º
            let comboHtml = '';
            if (companion && activeEquipmentId) {
                const companionType = companion.type;
                const equipment = COMPANION_EQUIPMENT[activeEquipmentId];
                const equipmentType = equipment.type;
                
                let comboName = 'ç„¡çµ„åˆ';
                let comboIcon = 'â“';
                let comboDescription = '';
                
                if (companionType === 'balanced') {
                    comboName = 'å®Œç¾å¹³è¡¡';
                    comboIcon = 'âš–ï¸';
                    comboDescription = 'æ”»+10% é˜²+10% è¡€+10%';
                } else if (companionType === equipmentType) {
                    if (companionType === 'attack') {
                        comboName = 'æ¥µé™æ”»å‹¢';
                        comboIcon = 'ğŸ”¥';
                        comboDescription = 'æ”»+20% çˆ†ç‡+10% çˆ†å‚·+15%';
                    } else if (companionType === 'defense') {
                        comboName = 'éµå£é˜²ç·š';
                        comboIcon = 'ğŸ›¡ï¸';
                        comboDescription = 'é˜²+20% æ¸›å‚·+10% è¡€+15%';
                    } else if (companionType === 'heal') {
                        comboName = 'æ°¸çºŒå†ç”Ÿ';
                        comboIcon = 'ğŸ’š';
                        comboDescription = 'è¡€+20% å¸è¡€+10% å›å¾©2%';
                    }
                } else {
                    if (companionType === 'attack' && equipmentType === 'defense') {
                        comboName = 'æ”»é˜²ä¸€é«”';
                        comboIcon = 'âš”ï¸ğŸ›¡ï¸';
                        comboDescription = 'æ”»+10% é˜²+10%';
                    } else if (companionType === 'attack' && equipmentType === 'heal') {
                        comboName = 'ç‹‚æˆ°å£«';
                        comboIcon = 'âš”ï¸ğŸ’š';
                        comboDescription = 'æ”»+10% å¸è¡€+10%';
                    } else if (companionType === 'defense' && equipmentType === 'attack') {
                        comboName = 'åæ“Šæˆ°å£«';
                        comboIcon = 'ğŸ›¡ï¸âš”ï¸';
                        comboDescription = 'é˜²+10% åå‚·+15%';
                    } else if (companionType === 'defense' && equipmentType === 'heal') {
                        comboName = 'ä¸æ­»ä¹‹èº«';
                        comboIcon = 'ğŸ›¡ï¸ğŸ’š';
                        comboDescription = 'é˜²+10% è¡€+10%';
                    } else if (companionType === 'heal' && equipmentType === 'attack') {
                        comboName = 'å¸è¡€é¬¼';
                        comboIcon = 'ğŸ’šâš”ï¸';
                        comboDescription = 'è¡€+10% å¸è¡€+15%';
                    } else if (companionType === 'heal' && equipmentType === 'defense') {
                        comboName = 'ç”Ÿå‘½å ¡å£˜';
                        comboIcon = 'ğŸ’šğŸ›¡ï¸';
                        comboDescription = 'è¡€+10% æ¸›å‚·+10%';
                    }
                }
                
                comboHtml = `
                    <div style="background: rgba(0, 255, 136, 0.15); padding: 4px 6px; border-radius: 4px; margin-top: 5px; border: 1px solid rgba(0, 255, 136, 0.3);">
                        <div style="color: #00ff88; font-size: 0.7rem; font-weight: bold; margin-bottom: 2px;">${comboIcon} ${comboName}</div>
                        <div style="color: #7a8fb8; font-size: 0.6rem;">${comboDescription}</div>
                    </div>
                `;
            }
            
            companionInfo.innerHTML = `
                <div style="margin-bottom: 6px;">
                    <div style="color: #4ade80; font-size: 0.7rem; margin-bottom: 3px;">ğŸ¤– éš¨å¾</div>
                    ${companionHtml}
                </div>
                <div style="margin-bottom: 6px;">
                    <div style="color: #4ade80; font-size: 0.7rem; margin-bottom: 3px;">ğŸ› ï¸ è£å‚™</div>
                    ${equipmentHtml}
                    ${equipmentEffectHtml}
                </div>
                ${comboHtml}
                <div style="text-align: center; margin-top: 8px;">
                    <span style="color: #ff9a56; font-size: 0.65rem;">é»æ“Šç®¡ç†</span>
                </div>
            `;
        }
        

        
        // æ›´æ–°çµ„åˆæ•ˆæœé¡¯ç¤º
        function updateComboEffectDisplay() {
            const comboDisplay = document.getElementById('combo-effect-display');
            if (!comboDisplay) return;
            
            const companion = getActiveCompanion();
            const activeEquipmentId = gameState.companions.equipment;
            
            if (companion && activeEquipmentId) {
                const equipment = COMPANION_EQUIPMENT[activeEquipmentId];
                
                let comboName = 'ç„¡çµ„åˆ';
                let comboIcon = 'â“';
                let comboDescription = '';
                
                const companionType = companion.type;
                const equipmentType = equipment.type;
                
                if (companionType === 'balanced') {
                    comboName = 'å®Œç¾å¹³è¡¡';
                    comboIcon = 'âš–ï¸';
                    comboDescription = 'æ”»æ“Š+10%, é˜²ç¦¦+10%, æœ€å¤§ç”Ÿå‘½+10%';
                } else if (companionType === equipmentType) {
                    if (companionType === 'attack') {
                        comboName = 'æ¥µé™æ”»å‹¢';
                        comboIcon = 'ğŸ”¥';
                        comboDescription = 'æ”»æ“Š+20%, æš´æ“Šç‡+10%, æš´æ“Šå‚·å®³+15%';
                    } else if (companionType === 'defense') {
                        comboName = 'éµå£é˜²ç·š';
                        comboIcon = 'ğŸ›¡ï¸';
                        comboDescription = 'é˜²ç¦¦+20%, æ¸›å‚·+10%, æœ€å¤§ç”Ÿå‘½+15%';
                    } else if (companionType === 'heal') {
                        comboName = 'æ°¸çºŒå†ç”Ÿ';
                        comboIcon = 'ğŸ’š';
                        comboDescription = 'æœ€å¤§ç”Ÿå‘½+20%, å¸è¡€+10%, æ¯å›åˆå›å¾©2%ç”Ÿå‘½';
                    }
                } else {
                    if (companionType === 'attack' && equipmentType === 'defense') {
                        comboName = 'æ”»é˜²ä¸€é«”';
                        comboIcon = 'âš”ï¸ğŸ›¡ï¸';
                        comboDescription = 'æ”»æ“Š+10%, é˜²ç¦¦+10%';
                    } else if (companionType === 'attack' && equipmentType === 'heal') {
                        comboName = 'ç‹‚æˆ°å£«';
                        comboIcon = 'âš”ï¸ğŸ’š';
                        comboDescription = 'æ”»æ“Š+10%, å¸è¡€+10%';
                    } else if (companionType === 'defense' && equipmentType === 'attack') {
                        comboName = 'åæ“Šæˆ°å£«';
                        comboIcon = 'ğŸ›¡ï¸âš”ï¸';
                        comboDescription = 'é˜²ç¦¦+10%, åæ“Šå‚·å®³+15%';
                    } else if (companionType === 'defense' && equipmentType === 'heal') {
                        comboName = 'ä¸æ­»ä¹‹èº«';
                        comboIcon = 'ğŸ›¡ï¸ğŸ’š';
                        comboDescription = 'é˜²ç¦¦+10%, æœ€å¤§ç”Ÿå‘½+10%';
                    } else if (companionType === 'heal' && equipmentType === 'attack') {
                        comboName = 'å¸è¡€é¬¼';
                        comboIcon = 'ğŸ’šâš”ï¸';
                        comboDescription = 'æœ€å¤§ç”Ÿå‘½+10%, å¸è¡€+15%';
                    } else if (companionType === 'heal' && equipmentType === 'defense') {
                        comboName = 'ç”Ÿå‘½å ¡å£˜';
                        comboIcon = 'ğŸ’šğŸ›¡ï¸';
                        comboDescription = 'æœ€å¤§ç”Ÿå‘½+10%, æ¸›å‚·+10%';
                    }
                }
                
                comboDisplay.style.display = 'block';
                comboDisplay.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 1.2rem; font-weight: bold; color: #00ff88; margin-bottom: 5px;">${comboIcon} ${comboName}</div>
                        <div style="font-size: 0.9rem; color: #7a8fb8;">${comboDescription}</div>
                    </div>
                `;
            } else {
                comboDisplay.style.display = 'none';
            }
        }
        
        // æ›´æ–°è£å‚™åˆ—è¡¨
        function updateEquipmentList() {
            const equipmentList = document.getElementById('equipment-list');
            if (!equipmentList) return;
            
            if (!gameState.companions.ownedEquipment || gameState.companions.ownedEquipment.length === 0) {
                equipmentList.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #7a8fb8; padding: 30px;">ä½ é‚„æ²’æœ‰è£å‚™ï¼Œæ“Šæ•—æ€ªç‰©ç²å–å§ï¼</div>';
                return;
            }
            
            equipmentList.innerHTML = gameState.companions.ownedEquipment.map(owned => {
                const equipment = COMPANION_EQUIPMENT[owned.id];
                if (!equipment) return '';
                
                const isEquipped = gameState.companions.equipment === owned.id;
                const rarityColor = getRarityColor(equipment.rarity);
                const levelMultiplier = 1 + (owned.level - 1) * 0.1;
                const currentEffect = (equipment.effect * levelMultiplier).toFixed(1);
                const nextLevelEffect = (equipment.effect * (levelMultiplier + 0.1)).toFixed(1);
                
                const upgradeCost = owned.level * 10 + 20;
                const canUpgrade = owned.level < 10 && gameState.companions.shards >= upgradeCost;
                
                const typeText = equipment.type === 'attack' ? 'æ”»æ“Š' : equipment.type === 'defense' ? 'é˜²ç¦¦' : 'å›å¾©';
                const typeColor = equipment.type === 'attack' ? '#ff6b6b' : equipment.type === 'defense' ? '#4ea5ff' : '#4ade80';
                
                return `
                    <div style="background: ${isEquipped ? 'rgba(0, 255, 136, 0.08)' : 'rgba(78, 165, 255, 0.05)'}; padding: 12px; border-radius: 8px; border: 2px solid ${isEquipped ? 'rgba(0, 255, 136, 0.4)' : rarityColor}; position: relative;">
                        ${isEquipped ? '<div style="position: absolute; top: 8px; right: 8px; background: #00ff88; color: #000; padding: 2px 8px; border-radius: 10px; font-size: 0.7rem; font-weight: bold;">âœ… å·²è£å‚™</div>' : ''}
                        <div style="font-size: 1.2rem; margin-bottom: 5px;">${equipment.icon}</div>
                        <div style="font-size: 1rem; font-weight: bold; color: ${rarityColor}; margin-bottom: 5px;">${equipment.name}</div>
                        <div style="color: #7a8fb8; font-size: 0.8rem; margin-bottom: 8px;">${equipment.description}</div>
                        <div style="display: flex; gap: 10px; margin-bottom: 8px; font-size: 0.8rem;">
                            <div style="color: #7a8fb8;">ğŸ¯ Lv.<span style="color: #00ff88; font-weight: bold;">${owned.level}</span></div>
                            <div style="color: #7a8fb8;">ğŸ† <span style="color: ${rarityColor};">${equipment.rarity}</span></div>
                            <div style="color: #7a8fb8;">ğŸ“Š <span style="color: ${typeColor};">${typeText}</span></div>
                        </div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 8px; border-radius: 5px; margin-bottom: 8px;">
                            <div style="color: #00ff88; font-size: 0.85rem; font-weight: bold; margin-bottom: 3px;">âœ¨ ç•¶å‰æ•ˆæœ</div>
                            <div style="color: #7a8fb8; font-size: 0.85rem;">${equipment.statType} +${currentEffect}%</div>
                            ${owned.level < 10 ? `<div style="color: #888; font-size: 0.75rem; margin-top: 3px;">ä¸‹ä¸€ç´š: ${equipment.statType} +${nextLevelEffect}%</div>` : '<div style="color: #ffd700; font-size: 0.75rem; margin-top: 3px;">â­ å·²æ»¿ç´š</div>'}
                        </div>
                        <div style="display: flex; gap: 5px;">
                            ${!isEquipped ? `<button onclick="equipEquipment('${owned.id}'); updateCompanionModal(); updateCompanionDisplay();" style="flex: 1; padding: 6px; font-size: 0.85rem; background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%); color: #000; font-weight: bold; border: none; border-radius: 4px; cursor: pointer;">âœ… è£å‚™</button>` : ''}
                            ${owned.level < 10 ? `<button onclick="upgradeEquipment('${owned.id}'); updateCompanionModal();" style="flex: 1; padding: 6px; font-size: 0.85rem; background: ${canUpgrade ? 'linear-gradient(135deg, #4ea5ff 0%, #357abd 100%)' : 'rgba(100, 100, 100, 0.3)'}; color: ${canUpgrade ? '#fff' : '#666'}; font-weight: bold; border: none; border-radius: 4px; cursor: ${canUpgrade ? 'pointer' : 'not-allowed'};" ${!canUpgrade ? 'disabled' : ''}>â¬†ï¸ å‡ç´š (ğŸ’${upgradeCost})</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // è£å‚™è£å‚™
        function equipEquipment(equipmentId) {
            gameState.companions.equipment = equipmentId;
            addLog('è£å‚™', `âœ… å·²è£å‚™ ${COMPANION_EQUIPMENT[equipmentId].name}`);
            saveGame();
        }
        
        // å¸ä¸‹è£å‚™
        function unequipEquipment() {
            const equipmentId = gameState.companions.equipment;
            if (equipmentId) {
                addLog('è£å‚™', `ğŸ“¤ å·²å¸ä¸‹ ${COMPANION_EQUIPMENT[equipmentId].name}`);
                gameState.companions.equipment = null;
                saveGame();
            }
        }
        
        // å‡ç´šè£å‚™
        function upgradeEquipment(equipmentId) {
            const ownedEquipment = gameState.companions.ownedEquipment.find(e => e.id === equipmentId);
            if (!ownedEquipment) return;
            
            if (ownedEquipment.level >= 10) {
                addLog('è£å‚™', 'âŒ è£å‚™å·²é”æœ€é«˜ç­‰ç´š');
                return;
            }
            
            const upgradeCost = ownedEquipment.level * 10 + 20;
            if (gameState.companions.shards < upgradeCost) {
                addLog('è£å‚™', `âŒ ç¢ç‰‡ä¸è¶³ï¼Œéœ€è¦ ${upgradeCost} ç¢ç‰‡`);
                return;
            }
            
            gameState.companions.shards -= upgradeCost;
            ownedEquipment.level++;
            
            const equipment = COMPANION_EQUIPMENT[equipmentId];
            addLog('è£å‚™', `â¬†ï¸ ${equipment.name} å‡ç´šåˆ° Lv.${ownedEquipment.level}`);
            playSound('upgrade');
            saveGame();
        }

        function getRarityColor(rarity) {
            const colors = {
                'common': '#9E9E9E',
                'uncommon': '#4CAF50',
                'fine': '#2196F3',
                'rare': '#9C27B0',
                'epic': '#FF6D00',
                'legendary': '#FFD700',
                'mythic': '#F44336',
                'eternal': '#E040FB',
                'set': '#00BCD4'
            };
            return colors[rarity] || '#9e9e9e';
        }
        
        // ç²å–å“éšæ¨™ç±¤
        function getRarityLabel(rarity) {
            const labels = {
                'common': 'ç ´èˆŠ',
                'uncommon': 'å„ªè³ª',
                'fine': 'ç²¾è‰¯',
                'rare': 'ç¨€æœ‰',
                'epic': 'å²è©©',
                'legendary': 'å‚³èªª',
                'mythic': 'ç¥è©±',
                'eternal': 'æ°¸æ†',
                'set': 'å¥—è£'
            };
            return labels[rarity] || 'æœªçŸ¥';
        }
        
        // ========== å¡ç‰ŒUIå‡½æ•¸ ==========
        
        function openCardModal() {
            updateCardModal();
            document.getElementById('card-modal').classList.add('active');
        }
        
        function closeCardModal() {
            document.getElementById('card-modal').classList.remove('active');
        }
        
        function updateCardModal() {
            if (!gameState.cards) return;
            
            // æ›´æ–°å·²è£å‚™çš„å¡ç‰Œ
            updateEquippedCardsDisplay();
            
            // æ›´æ–°å¥—ç‰Œæ•ˆæœ
            updateDeckEffectDisplay();
            
            // æ›´æ–°ç¢ç‰‡é¡¯ç¤º
            updateCardShardsDisplay();
            
            // æ›´æ–°å¡ç‰Œæ”¶è—
            updateCardCollectionDisplay();
            
            // æ›´æ–°èåˆç•Œé¢
            updateFusionGroupsDisplay();
        }
        
        function updateEquippedCardsDisplay() {
            const container = document.getElementById('equipped-cards-display');
            if (!container) return;
            
            const slot1 = gameState.cards.slot1;
            const slot2 = gameState.cards.slot2;
            
            let html = '';
            
            // å¡æ§½1
            if (slot1) {
                const card = gameState.cards.collection.find(c => c.uuid === slot1);
                const cardData = card ? CARDS[card.id] : null;
                if (card && cardData) {
                    html += renderCardSlot(card, cardData, 1);
                } else {
                    html += renderEmptySlot(1);
                }
            } else {
                html += renderEmptySlot(1);
            }
            
            // å¡æ§½2
            if (slot2) {
                const card = gameState.cards.collection.find(c => c.uuid === slot2);
                const cardData = card ? CARDS[card.id] : null;
                if (card && cardData) {
                    html += renderCardSlot(card, cardData, 2);
                } else {
                    html += renderEmptySlot(2);
                }
            } else {
                html += renderEmptySlot(2);
            }
            
            container.innerHTML = html;
        }
        
        function renderCardSlot(card, cardData, slotNum) {
            const rarityColor = getRarityColor(cardData.rarity);
            const levelMultiplier = getCardLevelMultiplier(card.level);
            
            return `
                <div style="flex: 1; min-width: 300px; background: rgba(138, 43, 226, 0.15); padding: 15px; border-radius: 8px; border: 2px solid ${rarityColor};">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div>
                            <span style="font-size: 1.5rem;">${cardData.icon}</span>
                            <span style="color: ${rarityColor}; font-weight: bold; margin-left: 8px;">${card.name}</span>
                            <span style="color: #888; font-size: 0.85rem; margin-left: 8px;">Lv.${card.level}</span>
                        </div>
                        <button onclick="unequipCard(${slotNum}); updateCardModal();" style="padding: 6px 12px; background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.5); border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 0.85rem;">âœ–ï¸ å¸ä¸‹</button>
                    </div>
                    <div style="font-size: 0.85rem; color: #aaa; margin-bottom: 8px;">
                        ${cardData.type} | ${cardData.series}ç³»åˆ— | ${cardData.rarity}
                    </div>
                    <div style="font-size: 0.9rem; color: #ccc; margin-bottom: 10px;">
                        ${cardData.description}
                    </div>
                    ${card.affixes && card.affixes.length > 0 ? `
                        <div style="margin-bottom: 10px;">
                            ${card.affixes.map(affix => {
                                const affixText = affix.stat ? 
                                    `${affix.name}: ${affix.stat} +${affix.value}${affix.type === 'percent' ? '%' : ''}` :
                                    `${affix.name}: ${affix.stats.map(s => `${s.stat} ${s.value > 0 ? '+' : ''}${s.value}%`).join(', ')}`;
                                return `<span style="display: inline-block; background: ${affix.color}22; color: ${affix.color}; padding: 3px 8px; border-radius: 4px; font-size: 0.8rem; margin-right: 5px; margin-bottom: 5px; border: 1px solid ${affix.color};">âœ¨ ${affixText}</span>`;
                            }).join('')}
                        </div>
                    ` : ''}
                    <div style="font-size: 0.85rem; color: #4EA5FF;">
                        æ•ˆæœå€ç‡: ${(levelMultiplier * 100).toFixed(0)}%
                    </div>
                </div>
            `;
        }
        
        function renderEmptySlot(slotNum) {
            return `
                <div style="flex: 1; min-width: 300px; background: rgba(100, 100, 100, 0.1); padding: 15px; border-radius: 8px; border: 2px dashed rgba(138, 43, 226, 0.3); display: flex; align-items: center; justify-content: center; min-height: 120px;">
                    <div style="text-align: center; color: #888;">
                        <div style="font-size: 2rem; margin-bottom: 8px;">ğŸƒ</div>
                        <div>å¡æ§½ ${slotNum} ç©ºç¼º</div>
                    </div>
                </div>
            `;
        }
        
        function updateDeckEffectDisplay() {
            const container = document.getElementById('deck-effect-display');
            if (!container) return;
            
            const deckEffect = getDeckEffect();
            if (deckEffect) {
                container.style.display = 'block';
                container.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 1.5rem;">âœ¨</span>
                        <div style="flex: 1;">
                            <div style="font-weight: bold; color: #ffd700; margin-bottom: 5px;">ğŸ´ å¥—ç‰Œæ•ˆæœï¼š${deckEffect.name}</div>
                            <div style="font-size: 0.9rem; color: #ddd;">${deckEffect.description}</div>
                        </div>
                    </div>
                `;
            } else {
                container.style.display = 'none';
            }
        }
        
        function updateCardShardsDisplay() {
            const container = document.getElementById('card-shards-display');
            if (!container) return;
            
            const rarities = ['Common', 'Fine', 'Rare', 'Epic', 'Legendary'];
            let html = '';
            
            rarities.forEach(rarity => {
                const amount = gameState.cards.shards[rarity] || 0;
                const color = getRarityColor(rarity);
                html += `
                    <div style="flex: 1; min-width: 140px; background: rgba(100, 100, 100, 0.15); padding: 12px; border-radius: 8px; border: 1px solid ${color}; text-align: center;">
                        <div style="font-size: 0.85rem; color: #888; margin-bottom: 5px;">${rarity}</div>
                        <div style="font-size: 1.3rem; font-weight: bold; color: ${color};">ğŸ’ ${amount}</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function updateCardCollectionDisplay() {
            const container = document.getElementById('card-collection-display');
            if (!container) return;
            
            if (gameState.cards.collection.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">å°šç„¡å¡ç‰Œï¼Œå»æˆ°é¬¥æˆ–å•†åº—ç²å–å§ï¼</div>';
                return;
            }
            
            // æŒ‰å“è³ªåˆ†çµ„
            const byRarity = {};
            gameState.cards.collection.forEach(card => {
                const cardData = CARDS[card.id];
                if (!cardData) return;
                if (!byRarity[cardData.rarity]) {
                    byRarity[cardData.rarity] = [];
                }
                byRarity[cardData.rarity].push({ card, cardData });
            });
            
            let html = '';
            const rarities = ['Eternal', 'Legendary', 'Epic', 'Rare', 'Fine', 'Common'];
            
            rarities.forEach(rarity => {
                if (!byRarity[rarity]) return;
                
                const color = getRarityColor(rarity.toLowerCase());
                const rarityObj = RARITIES.find(r => r.name === rarity.toLowerCase());
                const rarityLabel = rarityObj ? rarityObj.label : rarity;
                
                html += `
                    <div style="margin-bottom: 25px;">
                        <h4 style="color: ${color}; margin-bottom: 12px;">${rarityLabel} (${byRarity[rarity].length})</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">
                `;
                
                byRarity[rarity].forEach(({ card, cardData }) => {
                    html += renderCardItem(card, cardData);
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // æ›´æ–°èåˆç•Œé¢
        function updateFusionGroupsDisplay() {
            const container = document.getElementById('fusion-groups-display');
            if (!container) return;
            
            const fusibleGroups = getFusibleCardGroups();
            
            if (fusibleGroups.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">ç„¡å¯èåˆçš„å¡ç‰Œã€‚éœ€è¦ 3 å¼µç›¸åŒç³»åˆ—ã€ç›¸åŒå“éšçš„æ»¿ç´š (Lv.10) å¡ç‰Œã€‚</div>';
                return;
            }
            
            let html = '';
            
            fusibleGroups.forEach(group => {
                const rarityColor = getRarityColor(group.rarity);
                const nextRarity = getNextRarity(group.rarity);
                const nextRarityColor = getRarityColor(nextRarity);
                const cost = getFusionCost(group.rarity);
                const canAfford = gameState.gold >= cost;
                
                // æ‰¾åˆ°ä¸‹ä¸€å“éšçš„å¡ç‰Œ
                const nextCard = Object.values(CARDS).find(c => c.series === group.series && c.rarity === nextRarity);
                
                html += `
                    <div style="background: rgba(100, 100, 100, 0.15); padding: 15px; border-radius: 8px; border: 2px solid ${rarityColor}; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div>
                                <span style="font-size: 1.2rem; font-weight: bold; color: ${rarityColor};">${group.series}ç³»åˆ— - ${group.rarity}</span>
                                <span style="color: #888; font-size: 0.9rem; margin-left: 10px;">å¯ç”¨: ${group.cards.length} å¼µ</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.85rem; color: #888;">èåˆæˆæœ¬</div>
                                <div style="font-size: 1.1rem; font-weight: bold; color: ${canAfford ? '#ffd700' : '#ff6b6b'};">ğŸ’° ${cost}</div>
                            </div>
                        </div>
                        
                        ${nextCard ? `
                            <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 6px; margin-bottom: 12px;">
                                <div style="font-size: 0.85rem; color: #888; margin-bottom: 5px;">èåˆçµæœï¼š</div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 1.5rem;">${nextCard.icon}</span>
                                    <span style="color: ${nextRarityColor}; font-weight: bold;">${nextCard.name}</span>
                                    <span style="color: #888; font-size: 0.85rem;">(${nextRarity})</span>
                                </div>
                            </div>
                        ` : ''}
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 12px;">
                            ${group.cards.slice(0, 3).map((card, idx) => {
                                const cardData = CARDS[card.id];
                                return `
                                    <div id="fusion-card-${group.series}-${group.rarity}-${idx}" onclick="toggleFusionCardSelection('${group.series}', '${group.rarity}', ${idx}, '${card.id}')" style="background: rgba(100, 100, 100, 0.2); padding: 10px; border-radius: 6px; border: 2px solid rgba(100, 100, 100, 0.3); cursor: pointer; text-align: center; transition: all 0.2s;">
                                        <div style="font-size: 1.2rem; margin-bottom: 5px;">${cardData.icon}</div>
                                        <div style="font-size: 0.75rem; color: #ccc;">${cardData.name}</div>
                                        <div style="font-size: 0.7rem; color: #888; margin-top: 3px;">Lv.${card.level}</div>
                                        ${card.affixes && card.affixes.length > 0 ? `
                                            <div style="margin-top: 5px;">
                                                ${card.affixes.map(a => `<span style="font-size: 0.65rem; color: ${a.color};">âœ¨${a.name}</span>`).join(' ')}
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        <button onclick="performFusion('${group.series}', '${group.rarity}')" ${!canAfford ? 'disabled' : ''} style="width: 100%; padding: 12px; background: ${canAfford ? 'linear-gradient(135deg, #ff8c00 0%, #ff6347 100%)' : 'rgba(100, 100, 100, 0.3)'}; border: none; border-radius: 6px; color: ${canAfford ? 'white' : '#666'}; font-size: 1rem; font-weight: bold; cursor: ${canAfford ? 'pointer' : 'not-allowed'};">ğŸ”¥ èåˆ (3 å¼µ ${group.rarity} â†’ 1 å¼µ ${nextRarity})</button>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // åˆ‡æ›èåˆå¡ç‰Œé¸æ“‡ï¼ˆç”¨æ–¼è¦–è¦ºåé¥‹ï¼‰
        function toggleFusionCardSelection(series, rarity, idx, cardId) {
            const element = document.getElementById(`fusion-card-${series}-${rarity}-${idx}`);
            if (!element) return;
            
            const isSelected = element.style.borderColor === 'rgb(255, 215, 0)';
            
            if (isSelected) {
                element.style.borderColor = 'rgba(100, 100, 100, 0.3)';
                element.style.background = 'rgba(100, 100, 100, 0.2)';
            } else {
                element.style.borderColor = '#ffd700';
                element.style.background = 'rgba(255, 215, 0, 0.2)';
            }
        }
        
        // åŸ·è¡Œèåˆ
        function performFusion(series, rarity) {
            const group = getFusibleCardGroups().find(g => g.series === series && g.rarity === rarity);
            if (!group || group.cards.length < 3) {
                addLog('èåˆ', 'ç„¡æ³•æ‰¾åˆ°è¶³å¤ çš„å¡ç‰Œï¼');
                return;
            }
            
            // å–å‰ 3 å¼µå¡ç‰Œï¼ˆä½¿ç”¨ UUIDï¼‰
            const cardIds = group.cards.slice(0, 3).map(c => c.uuid);
            
            if (fuseCards(cardIds)) {
                // èåˆæˆåŠŸï¼Œé‡æ–°æ¸²æŸ“ç•Œé¢
                updateCardModal();
            }
        }
        
        function renderCardItem(card, cardData) {
            const rarityColor = getRarityColor(cardData.rarity);
            const levelMultiplier = getCardLevelMultiplier(card.level);
            const isEquipped = gameState.cards.slot1 === card.uuid || gameState.cards.slot2 === card.uuid;
            const upgradeCost = card.level < 10 ? getUpgradeShardCost(card.level, cardData.rarity) : 0;
            const currentShards = gameState.cards.shards[cardData.rarity] || 0;
            const canUpgrade = card.level < 10 && currentShards >= upgradeCost;
            
            return `
                <div style="background: rgba(100, 100, 100, 0.1); padding: 15px; border-radius: 8px; border: 2px solid ${rarityColor};">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div>
                            <span style="font-size: 1.5rem;">${cardData.icon}</span>
                            <span style="color: ${rarityColor}; font-weight: bold; margin-left: 8px;">${card.name}</span>
                            ${isEquipped ? '<span style="color: #4EA5FF; font-size: 0.75rem; margin-left: 8px;">âœ”ï¸ å·²è£å‚™</span>' : ''}
                        </div>
                        <div style="text-align: right;">
                            <div style="color: #888; font-size: 0.85rem;">Lv.${card.level}</div>
                            <div style="color: #4EA5FF; font-size: 0.75rem;">${(levelMultiplier * 100).toFixed(0)}%</div>
                        </div>
                    </div>
                    <div style="font-size: 0.85rem; color: #aaa; margin-bottom: 8px;">
                        ${cardData.type} | ${cardData.series}ç³»åˆ—
                    </div>
                    <div style="font-size: 0.9rem; color: #ccc; margin-bottom: 10px;">
                        ${cardData.description}
                    </div>
                    ${card.affixes && card.affixes.length > 0 ? `
                        <div style="margin-bottom: 10px;">
                            ${card.affixes.map(affix => {
                                const affixText = affix.stat ? 
                                    `${affix.name}: ${affix.stat} +${affix.value}${affix.type === 'percent' ? '%' : ''}` :
                                    `${affix.name}: ${affix.stats.map(s => `${s.stat} ${s.value > 0 ? '+' : ''}${s.value}%`).join(', ')}`;
                                return `<span style="display: inline-block; background: ${affix.color}22; color: ${affix.color}; padding: 3px 8px; border-radius: 4px; font-size: 0.8rem; margin-right: 5px; margin-bottom: 5px; border: 1px solid ${affix.color};">âœ¨ ${affixText}</span>`;
                            }).join('')}
                        </div>
                    ` : ''}
                    ${card.level < 10 ? `
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                            <div style="font-size: 0.85rem; color: #888; margin-bottom: 5px;">å‡ç´šæ‰€éœ€ï¼š<span style="color: ${rarityColor}">ğŸ’ ${upgradeCost}</span> / ${currentShards}</div>
                            <button onclick="upgradeCard(${card.uuid}); updateCardModal();" ${!canUpgrade ? 'disabled' : ''} style="width: 100%; padding: 8px; background: ${canUpgrade ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : 'rgba(100, 100, 100, 0.3)'}; border: none; border-radius: 4px; color: ${canUpgrade ? 'white' : '#666'}; cursor: ${canUpgrade ? 'pointer' : 'not-allowed'}; font-size: 0.9rem;">â¬†ï¸ å‡ç´šåˆ° Lv.${card.level + 1}</button>
                        </div>
                    ` : '<div style="text-align: center; color: #ffd700; font-size: 0.85rem; padding: 8px;">ğŸ† å·²é”æœ€é«˜ç­‰ç´š</div>'}
                    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                        ${!isEquipped ? `
                            <button onclick="equipCard(${card.uuid}, 1); updateCardModal();" style="flex: 1; padding: 8px; background: rgba(138, 43, 226, 0.3); border: 1px solid rgba(138, 43, 226, 0.6); border-radius: 4px; color: #b794f4; cursor: pointer; font-size: 0.85rem;">â­ è£å‚™åˆ°1</button>
                            <button onclick="equipCard(${card.uuid}, 2); updateCardModal();" style="flex: 1; padding: 8px; background: rgba(138, 43, 226, 0.3); border: 1px solid rgba(138, 43, 226, 0.6); border-radius: 4px; color: #b794f4; cursor: pointer; font-size: 0.85rem;">â­ è£å‚™åˆ°2</button>
                        ` : `
                            <button onclick="unequipCard(${gameState.cards.slot1 === card.uuid ? 1 : 2}); updateCardModal();" style="flex: 1; padding: 8px; background: rgba(255, 0, 0, 0.2); border: 1px solid rgba(255, 0, 0, 0.5); border-radius: 4px; color: #ff6b6b; cursor: pointer; font-size: 0.85rem;">âœ–ï¸ å¸ä¸‹</button>
                        `}
                    </div>
                    <button onclick="salvageCard(${card.uuid}); updateCardModal();" style="width: 100%; padding: 8px; background: rgba(255, 140, 0, 0.2); border: 1px solid rgba(255, 140, 0, 0.5); border-radius: 4px; color: #ff8c00; cursor: pointer; font-size: 0.85rem;">ğŸ”¨ åˆ†è§£ç‚ºç¢ç‰‡ (+${getShardAmount(cardData.rarity)} ğŸ’)</button>
                </div>
            `;
        }
        
        // æ›´æ–°å·¦å´æ¬„å¡æ§½é¡¯ç¤º
        function updateCardSlotsDisplay() {
            const container = document.getElementById('card-slots-display');
            if (!container || !gameState.cards) return;
            
            const slot1 = gameState.cards.slot1;
            const slot2 = gameState.cards.slot2;
            
            let html = '<div style="font-weight: bold; margin-bottom: 8px; color: rgba(138, 43, 226, 1);">ğŸ´ å¡ç‰Œ</div>';
            
            // å¡æ§½1
            if (slot1) {
                const card = gameState.cards.collection.find(c => c.uuid === slot1);
                const cardData = card ? CARDS[card.id] : null;
                if (card && cardData) {
                    const color = getRarityColor(cardData.rarity);
                    // ç”Ÿæˆæ•ˆæœæè¿°
                    const effects1 = [];
                    const cardEffect1 = cardData.effect;
                    
                    // è™•ç†å–®ä¸€å±¬æ€§æ•ˆæœ
                    if (cardEffect1.stat) {
                        const statName = {
                            'atk': 'æ”»æ“Š',
                            'def': 'é˜²ç¦¦',
                            'hp': 'ç”Ÿå‘½',
                            'crit': 'æš´æ“Šç‡',
                            'critDmg': 'æš´æ“Šå‚·å®³',
                            'goldBonus': 'é‡‘å¹£',
                            'expBonus': 'ç¶“é©—'
                        }[cardEffect1.stat] || cardEffect1.stat;
                        effects1.push(`${statName}+${cardEffect1.value}%`);
                    }
                    
                    // è™•ç†å¤šå±¬æ€§æ•ˆæœ
                    if (cardEffect1.stats && Array.isArray(cardEffect1.stats)) {
                        cardEffect1.stats.forEach(s => {
                            const statName = {
                                'atk': 'æ”»æ“Š',
                                'def': 'é˜²ç¦¦',
                                'hp': 'ç”Ÿå‘½',
                                'crit': 'æš´æ“Šç‡',
                                'critDmg': 'æš´æ“Šå‚·å®³',
                                'goldBonus': 'é‡‘å¹£',
                                'expBonus': 'ç¶“é©—'
                            }[s.stat] || s.stat;
                            effects1.push(`${statName}+${s.value}%`);
                        });
                    }
                    
                    const effectsText1 = effects1.length > 0 ? effects1.join(', ') : cardData.description;
                    
                    html += `
                        <div style="background: rgba(138, 43, 226, 0.15); padding: 8px; border-radius: 6px; margin-bottom: 6px; border: 1px solid ${color}; cursor: pointer;" onclick="openCardModal()">
                            <div style="font-size: 0.85rem;">
                                <span>${cardData.icon}</span>
                                <span style="color: ${color}; margin-left: 5px;">${card.name}</span>
                                <span style="color: #888; font-size: 0.75rem; margin-left: 5px;">Lv.${card.level}</span>
                            </div>
                            <div style="color: #4ade80; font-size: 0.7rem; margin-top: 4px;">${effectsText1}</div>
                        </div>
                    `;
                } else {
                    html += '<div style="background: rgba(100, 100, 100, 0.1); padding: 8px; border-radius: 6px; margin-bottom: 6px; border: 1px dashed rgba(138, 43, 226, 0.3); text-align: center; color: #666; font-size: 0.85rem; cursor: pointer;" onclick="openCardModal()">å¡æ§½1 ç©ºç¼º</div>';
                }
            } else {
                html += '<div style="background: rgba(100, 100, 100, 0.1); padding: 8px; border-radius: 6px; margin-bottom: 6px; border: 1px dashed rgba(138, 43, 226, 0.3); text-align: center; color: #666; font-size: 0.85rem; cursor: pointer;" onclick="openCardModal()">å¡æ§½1 ç©ºç¼º</div>';
            }
            
            // å¡æ§½2
            if (slot2) {
                const card = gameState.cards.collection.find(c => c.uuid === slot2);
                const cardData = card ? CARDS[card.id] : null;
                if (card && cardData) {
                    const color = getRarityColor(cardData.rarity);
                    // ç”Ÿæˆæ•ˆæœæè¿°
                    const effects2 = [];
                    const cardEffect2 = cardData.effect;
                    
                    // è™•ç†å–®ä¸€å±¬æ€§æ•ˆæœ
                    if (cardEffect2.stat) {
                        const statName = {
                            'atk': 'æ”»æ“Š',
                            'def': 'é˜²ç¦¦',
                            'hp': 'ç”Ÿå‘½',
                            'crit': 'æš´æ“Šç‡',
                            'critDmg': 'æš´æ“Šå‚·å®³',
                            'goldBonus': 'é‡‘å¹£',
                            'expBonus': 'ç¶“é©—'
                        }[cardEffect2.stat] || cardEffect2.stat;
                        effects2.push(`${statName}+${cardEffect2.value}%`);
                    }
                    
                    // è™•ç†å¤šå±¬æ€§æ•ˆæœ
                    if (cardEffect2.stats && Array.isArray(cardEffect2.stats)) {
                        cardEffect2.stats.forEach(s => {
                            const statName = {
                                'atk': 'æ”»æ“Š',
                                'def': 'é˜²ç¦¦',
                                'hp': 'ç”Ÿå‘½',
                                'crit': 'æš´æ“Šç‡',
                                'critDmg': 'æš´æ“Šå‚·å®³',
                                'goldBonus': 'é‡‘å¹£',
                                'expBonus': 'ç¶“é©—'
                            }[s.stat] || s.stat;
                            effects2.push(`${statName}+${s.value}%`);
                        });
                    }
                    
                    const effectsText2 = effects2.length > 0 ? effects2.join(', ') : cardData.description;
                    
                    html += `
                        <div style="background: rgba(138, 43, 226, 0.15); padding: 8px; border-radius: 6px; margin-bottom: 6px; border: 1px solid ${color}; cursor: pointer;" onclick="openCardModal()">
                            <div style="font-size: 0.85rem;">
                                <span>${cardData.icon}</span>
                                <span style="color: ${color}; margin-left: 5px;">${card.name}</span>
                                <span style="color: #888; font-size: 0.75rem; margin-left: 5px;">Lv.${card.level}</span>
                            </div>
                            <div style="color: #4ade80; font-size: 0.7rem; margin-top: 4px;">${effectsText2}</div>
                        </div>
                    `;
                } else {
                    html += '<div style="background: rgba(100, 100, 100, 0.1); padding: 8px; border-radius: 6px; margin-bottom: 6px; border: 1px dashed rgba(138, 43, 226, 0.3); text-align: center; color: #666; font-size: 0.85rem; cursor: pointer;" onclick="openCardModal()">å¡æ§½2 ç©ºç¼º</div>';
                }
            } else {
                html += '<div style="background: rgba(100, 100, 100, 0.1); padding: 8px; border-radius: 6px; margin-bottom: 6px; border: 1px dashed rgba(138, 43, 226, 0.3); text-align: center; color: #666; font-size: 0.85rem; cursor: pointer;" onclick="openCardModal()">å¡æ§½2 ç©ºç¼º</div>';
            }
            
            // å¥—ç‰Œæ•ˆæœ
            const deckEffect = getDeckEffect();
            if (deckEffect) {
                html += `
                    <div style="background: rgba(255, 215, 0, 0.15); padding: 8px; border-radius: 6px; margin-top: 8px; border: 1px solid rgba(255, 215, 0, 0.5);">
                        <div style="font-size: 0.75rem; color: #ffd700; font-weight: bold;">âœ¨ ${deckEffect.name}</div>
                        <div style="font-size: 0.7rem; color: #4ade80; margin-top: 4px;">${deckEffect.description}</div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        // ========== å¡ç‰Œç³»çµ±å‡½æ•¸ ==========
        
        // è©ç¶´ç³»çµ±å‡½æ•¸
        
        // æ ¹æ“šæ¬Šé‡éš¨æ©Ÿé¸æ“‡è©ç¶´
        function getRandomAffix(excludeIds = []) {
            const availableAffixes = Object.values(CARD_AFFIXES).filter(a => !excludeIds.includes(a.id));
            if (availableAffixes.length === 0) return null;
            
            const totalWeight = availableAffixes.reduce((sum, a) => sum + a.weight, 0);
            let rand = Math.random() * totalWeight;
            
            for (const affix of availableAffixes) {
                rand -= affix.weight;
                if (rand <= 0) {
                    return JSON.parse(JSON.stringify(affix)); // è¿”å›å‰¯æœ¬
                }
            }
            
            return availableAffixes[0];
        }
        
        // ç‚ºå¡ç‰Œç”Ÿæˆè©ç¶´
        function generateAffixesForCard(rarity) {
            const chances = AFFIX_CHANCES[rarity];
            if (!chances) return [];
            
            const affixes = [];
            
            // ç¬¬ä¸€å€‹è©ç¶´
            if (Math.random() < chances.one) {
                const affix = getRandomAffix();
                if (affix) affixes.push(affix);
            }
            
            // ç¬¬äºŒå€‹è©ç¶´
            if (Math.random() < chances.two) {
                const excludeIds = affixes.map(a => a.id);
                const affix = getRandomAffix(excludeIds);
                if (affix) affixes.push(affix);
            }
            
            return affixes;
        }
        
        // è¨ˆç®—è©ç¶´å±¬æ€§åŠ æˆ
        function applyAffixBonuses(affixes) {
            if (!affixes || affixes.length === 0) return {};
            
            const bonuses = {};
            
            for (const affix of affixes) {
                if (affix.stat) {
                    // å–®ä¸€å±¬æ€§è©ç¶´
                    bonuses[affix.stat] = (bonuses[affix.stat] || 0) + affix.value;
                } else if (affix.stats) {
                    // å¤šå±¬æ€§è©ç¶´
                    for (const statBonus of affix.stats) {
                        bonuses[statBonus.stat] = (bonuses[statBonus.stat] || 0) + statBonus.value;
                    }
                }
            }
            
            return bonuses;
        }
        
        // ç²å–å¡ç‰Œ
        function getCard(cardId) {
            if (!gameState.cards) {
                gameState.cards = { slot1: null, slot2: null, collection: [], shards: {} };
            }
            
            const card = CARDS[cardId];
            if (!card) {
                console.error('å¡ç‰Œä¸å­˜åœ¨:', cardId);
                return false;
            }
            
            // ä¸å†æª¢æŸ¥é‡è¤‡ï¼Œå…è¨±æ”¶è—å¤šå¼µç›¸åŒå¡ç‰Œï¼ˆå› ç‚ºè©ç¶´ä¸åŒï¼‰
            
            // æ·»åŠ åˆ°æ”¶è—
            const newCard = {
                uuid: Date.now() + Math.random(), // å”¯ä¸€ ID
                id: card.id, // å¡ç‰Œé¡å‹ ID
                name: card.name,
                type: card.type,
                rarity: card.rarity,
                series: card.series,
                description: card.description,
                effect: card.effect,
                icon: card.icon,
                level: 1,
                exp: 0,
                affixes: generateAffixesForCard(card.rarity) // ç”Ÿæˆè©ç¶´
            };
            
            gameState.cards.collection.push(newCard);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—å¡ç‰Œ
            updateQuestProgress('collect_card', 1);
            if (card.rarity === 'Rare' || card.rarity === 'Epic' || card.rarity === 'Legendary' || card.rarity === 'Mythic' || card.rarity === 'Eternal') {
                updateQuestProgress('collect_rare_card', 1);
            }
            gameState.cards.stats.totalCardsObtained++;
            
            // è¨˜éŒ„å¡ç‰Œåœ–é‘‘
            recordCardObtained(card.id);
            
            const rarityColor = getRarityColor(card.rarity);
            const rarityObj = RARITIES.find(r => r.name === card.rarity);
            const rarityLabel = rarityObj ? rarityObj.label : card.rarity;
            addLog('å¡ç‰Œ', `ç²å¾—å¡ç‰Œï¼š${card.icon} <span style="color: ${rarityColor}">${card.name}</span> (${rarityLabel})ï¼`);
            return true;
        }
        
        // è£å‚™å¡ç‰Œ
        function equipCard(cardUuid, slotNum) {
            if (!gameState.cards) {
                gameState.cards = { slot1: null, slot2: null, collection: [], shards: {} };
            }
            
            const card = gameState.cards.collection.find(c => c.uuid === cardUuid);
            if (!card) {
                addLog('å¡ç‰Œä¸å­˜åœ¨ï¼', 'error');
                return false;
            }
            
            const slotKey = `slot${slotNum}`;
            
            // æª¢æŸ¥æ˜¯å¦å·²è£å‚™åœ¨å…¶ä»–æ§½ä½
            const otherSlotKey = slotNum === 1 ? 'slot2' : 'slot1';
            if (gameState.cards[otherSlotKey] === cardUuid) {
                addLog('æ­¤å¡ç‰Œå·²è£å‚™åœ¨å…¶ä»–æ§½ä½ï¼', 'error');
                return false;
            }
            
            // è£å‚™å¡ç‰Œï¼ˆå„²å­˜ UUIDï¼‰
            gameState.cards[slotKey] = cardUuid;
            addLog(`è£å‚™å¡ç‰Œï¼š${card.name} åˆ°æ§½ä½${slotNum}`, 'info');
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šè£å‚™å¡ç‰Œ
            updateQuestProgress('equip_card', 1);
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            recalculateStats();
            updateUI();
            return true;
        }
        
        // å¸ä¸‹å¡ç‰Œ
        function unequipCard(slotNum) {
            if (!gameState.cards) return false;
            
            const slotKey = `slot${slotNum}`;
            const cardUuid = gameState.cards[slotKey];
            
            if (!cardUuid) {
                addLog(`æ§½ä½${slotNum}æ²’æœ‰è£å‚™å¡ç‰Œï¼`, 'error');
                return false;
            }
            
            const card = gameState.cards.collection.find(c => c.uuid === cardUuid);
            if (card) {
                addLog(`å¸ä¸‹å¡ç‰Œï¼š${card.name}`, 'info');
            }
            
            gameState.cards[slotKey] = null;
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            recalculateStats();
            updateUI();
            return true;
        }
        
        // ç²å–è£å‚™çš„å¡ç‰Œ
        function getEquippedCards() {
            if (!gameState.cards) return [];
            
            const equipped = [];
            if (gameState.cards.slot1) {
                const card = gameState.cards.collection.find(c => c.uuid === gameState.cards.slot1);
                if (card) equipped.push(card);
            }
            if (gameState.cards.slot2) {
                const card = gameState.cards.collection.find(c => c.uuid === gameState.cards.slot2);
                if (card) equipped.push(card);
            }
            return equipped;
        }
        
        // æª¢æŸ¥å¥—ç‰Œæ•ˆæœ
        function getDeckEffect() {
            const equipped = getEquippedCards();
            if (equipped.length !== 2) return null;
            
            // æª¢æŸ¥æ˜¯å¦åŒç³»åˆ—
            if (equipped[0].series === equipped[1].series) {
                const deckEffect = DECK_EFFECTS[equipped[0].series];
                if (deckEffect) {
                    return {
                        series: equipped[0].series,
                        name: deckEffect.name,
                        bonus: deckEffect.bonus,
                        description: deckEffect.description
                    };
                }
            }
            return null;
        }
        
        // è¨ˆç®—å¡ç‰ŒåŠ æˆ
        function applyCardBonuses() {
            const equipped = getEquippedCards();
            if (equipped.length === 0) return null;
            
            const bonuses = {
                atk: 0,
                def: 0,
                hp: 0,
                crit: 0,
                critDmg: 0,
                dmgRed: 0,
                lifeSteal: 0
            };
            
            // è¨ˆç®—æ¯å¼µå¡ç‰Œçš„æ•ˆæœï¼ˆåŒ…æ‹¬è©ç¶´ï¼‰
            equipped.forEach(card => {
                // è¨ˆç®—è©ç¶´åŠ æˆ
                if (card.affixes && card.affixes.length > 0) {
                    const affixBonuses = applyAffixBonuses(card.affixes);
                    for (const stat in affixBonuses) {
                        if (bonuses.hasOwnProperty(stat)) {
                            bonuses[stat] += affixBonuses[stat];
                        }
                    }
                }
                
                const effect = card.effect;
                if (effect.type === 'passive') {
                    // å–®ä¸€å±¬æ€§
                    if (effect.stat) {
                        const statMap = {
                            'atk': 'atk',
                            'def': 'def',
                            'hp': 'hp',
                            'crit': 'crit',
                            'critDmg': 'critDmg',
                            'dmgRed': 'dmgRed',
                            'lifeSteal': 'lifeSteal'
                        };
                        const mappedStat = statMap[effect.stat];
                        if (mappedStat && bonuses.hasOwnProperty(mappedStat)) {
                            // æ‡‰ç”¨å¡ç‰Œç­‰ç´šå€ç‡
                            const levelMultiplier = getCardLevelMultiplier(card.level);
                            bonuses[mappedStat] += effect.value * levelMultiplier;
                        }
                    }
                    // å¤šå€‹å±¬æ€§
                    if (effect.stats) {
                        effect.stats.forEach(s => {
                            const statMap = {
                                'atk': 'atk',
                                'def': 'def',
                                'hp': 'hp',
                                'crit': 'crit',
                                'critDmg': 'critDmg',
                                'dmgRed': 'dmgRed',
                                'lifeSteal': 'lifeSteal'
                            };
                            const mappedStat = statMap[s.stat];
                            if (mappedStat && bonuses.hasOwnProperty(mappedStat)) {
                                // æ‡‰ç”¨å¡ç‰Œç­‰ç´šå€ç‡
                                const levelMultiplier = getCardLevelMultiplier(card.level);
                                bonuses[mappedStat] += s.value * levelMultiplier;
                            }
                        });
                    }
                }
            });
            
            
            // åŠ ä¸Šå¥—ç‰Œæ•ˆæœ
            const deckEffect = getDeckEffect();
            if (deckEffect && deckEffect.bonus) {
                const bonus = deckEffect.bonus;
                if (bonus.atk) bonuses.atk += bonus.atk;
                if (bonus.def) bonuses.def += bonus.def;
                if (bonus.hp) bonuses.hp += bonus.hp;
                if (bonus.crit) bonuses.crit += bonus.crit;
                if (bonus.critDmg) bonuses.critDmg += bonus.critDmg;
                if (bonus.dmgRed) bonuses.dmgRed += bonus.dmgRed;
                if (bonus.lifeSteal) bonuses.lifeSteal += bonus.lifeSteal;
            }
            
            return bonuses;
        }
        
        // ç²å–ç¢ç‰‡æ•¸é‡ï¼ˆæ ¹æ“šå“è³ªï¼‰
        function getShardAmount(rarity) {
            const shardAmounts = {
                'Common': 1,
                'Fine': 3,
                'Rare': 10,
                'Epic': 30,
                'Legendary': 100,
                'Eternal': 300
            };
            return shardAmounts[rarity] || 1;
        }

        // å¡ç‰Œå‡ç´šç³»çµ±
        function upgradeCard(cardUuid) {
            const card = gameState.cards.collection.find(c => c.uuid === cardUuid);
            if (!card) {
                addLog('å¡ç‰Œ', 'å¡ç‰Œä¸å­˜åœ¨ï¼');
                return false;
            }
            
            const cardData = CARDS[card.id];
            if (!cardData) {
                return false;
            }
            
            // æª¢æŸ¥æ˜¯å¦å·²é”æœ€é«˜ç­‰ç´š
            if (card.level >= 10) {
                addLog('å¡ç‰Œ', `${card.icon} ${card.name} å·²é”æœ€é«˜ç­‰ç´šï¼`);
                return false;
            }
            
            // è¨ˆç®—æ‰€éœ€ç¢ç‰‡
            const shardsNeeded = getUpgradeShardCost(card.level, cardData.rarity);
            const currentShards = gameState.cards.shards[cardData.rarity] || 0;
            
            if (currentShards < shardsNeeded) {
                const rarityColor = getRarityColor(cardData.rarity);
                addLog('å¡ç‰Œ', `ç¢ç‰‡ä¸è¶³ï¼éœ€è¦ <span style="color: ${rarityColor}">${shardsNeeded}</span> å€‹ç¢ç‰‡ï¼Œç•¶å‰åªæœ‰ <span style="color: ${rarityColor}">${currentShards}</span> å€‹ã€‚`);
                return false;
            }
            
            // æ‰£é™¤ç¢ç‰‡
            gameState.cards.shards[cardData.rarity] -= shardsNeeded;
            
            // å‡ç´š
            card.level++;
            
            // æ—¥èªŒæç¤º
            const rarityColor = getRarityColor(cardData.rarity);
            addLog('å¡ç‰Œ', `â¬†ï¸ ${card.icon} <span style="color: ${rarityColor}">${card.name}</span> å‡ç´šåˆ° Lv.${card.level}ï¼æ•ˆæœæå‡ ${card.level * 10}%ï¼`);
            
            // ç‰¹æ®Šç­‰ç´šæç¤º
            if (card.level === 5) {
                addLog('å¡ç‰Œ', `ğŸŒŸ ${card.icon} ${card.name} é”åˆ° Lv.5ï¼Œè§£é–é¡å¤–æ•ˆæœï¼`);
            } else if (card.level === 10) {
                addLog('å¡ç‰Œ', `ğŸ† ${card.icon} ${card.name} é”åˆ°æœ€é«˜ç­‰ç´š Lv.10ï¼Œæ•ˆæœå¤§å¹…æå‡ï¼`);
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå¡ç‰Œå‡ç´š
            updateQuestProgress('level_up_card', 1);
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            recalculateStats();
            updateCardModal();
            saveGame();
            
            return true;
        }
        
        // æ‰‹å‹•åˆ†è§£å¡ç‰Œç‚ºç¢ç‰‡
        function salvageCard(cardUuid) {
            const cardIndex = gameState.cards.collection.findIndex(c => c.uuid === cardUuid);
            if (cardIndex === -1) {
                addLog('åˆ†è§£', 'å¡ç‰Œä¸å­˜åœ¨ï¼');
                return false;
            }
            
            const card = gameState.cards.collection[cardIndex];
            const cardData = CARDS[card.id];
            
            // æª¢æŸ¥æ˜¯å¦è¢«è£å‚™
            if (gameState.cards.slot1 === card.uuid || gameState.cards.slot2 === card.uuid) {
                addLog('åˆ†è§£', 'ç„¡æ³•åˆ†è§£å·²è£å‚™çš„å¡ç‰Œï¼Œè«‹å…ˆå¸ä¸‹ï¼');
                return false;
            }
            
            // ç²å¾—ç¢ç‰‡
            const shardAmount = getShardAmount(cardData.rarity);
            gameState.cards.shards[cardData.rarity] = (gameState.cards.shards[cardData.rarity] || 0) + shardAmount;
            
            // ç§»é™¤å¡ç‰Œ
            gameState.cards.collection.splice(cardIndex, 1);
            
            const rarityColor = getRarityColor(cardData.rarity);
            addLog('åˆ†è§£', `åˆ†è§£ ${cardData.icon} ${card.name}ï¼Œç²å¾— <span style="color: ${rarityColor}">${shardAmount}</span> å€‹ç¢ç‰‡ï¼`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå›æ”¶å¡ç‰Œ
            updateQuestProgress('salvage_card', 1);
            
            recalculateStats();
            saveGame();
            
            return true;
        }
        
        // è¨ˆç®—å‡ç´šæ‰€éœ€ç¢ç‰‡
        function getUpgradeShardCost(currentLevel, rarity) {
            // åŸºç¤æˆæœ¬
            const baseCost = {
                'Common': 2,
                'Fine': 5,
                'Rare': 15,
                'Epic': 50,
                'Legendary': 150
            };
            
            // æ¯ç´šæˆæœ¬éå¢
            const cost = baseCost[rarity] || 2;
            return Math.floor(cost * (1 + currentLevel * 0.5));
        }
        
        // ç²å–å¡ç‰Œå‡ç´šå¾Œçš„æ•ˆæœå€ç‡
        function getCardLevelMultiplier(level) {
            return 1 + (level - 1) * 0.1; // æ¯ç´š+10%
        }
        
        // ========== å¡ç‰Œèåˆç³»çµ± ==========
        
        // ç²å–èåˆæˆæœ¬
        function getFusionCost(rarity) {
            const costs = {
                'Common': 50,
                'Fine': 200,
                'Rare': 1000,
                'Epic': 5000
            };
            return costs[rarity] || 0;
        }
        
        // ç²å–ä¸‹ä¸€å€‹å“éš
        function getNextRarity(currentRarity) {
            const rarityOrder = ['Common', 'Fine', 'Rare', 'Epic', 'Legendary'];
            const currentIndex = rarityOrder.indexOf(currentRarity);
            if (currentIndex === -1 || currentIndex === rarityOrder.length - 1) {
                return null; // ç„¡æ³•èåˆ
            }
            return rarityOrder[currentIndex + 1];
        }
        
        // ç²å–å¯èåˆçš„å¡ç‰Œçµ„åˆ
        function getFusibleCardGroups() {
            if (!gameState.cards || !gameState.cards.collection) return [];
            
            const groups = {};
            
            // æŒ‰ç³»åˆ—å’Œå“éšåˆ†çµ„
            gameState.cards.collection.forEach(card => {
                if (card.level === 10) { // åªæœ‰æ»¿ç´šå¡ç‰Œæ‰èƒ½èåˆ
                    const key = `${card.series}_${card.rarity}`;
                    if (!groups[key]) {
                        groups[key] = {
                            series: card.series,
                            rarity: card.rarity,
                            cards: []
                        };
                    }
                    groups[key].cards.push(card);
                }
            });
            
            // åªè¿”å›æœ‰è‡³å°‘ 3 å¼µå¡ç‰Œçš„çµ„åˆ
            return Object.values(groups).filter(g => g.cards.length >= 3 && getNextRarity(g.rarity) !== null);
        }
        
        // èåˆå¡ç‰Œ
        function fuseCards(cardIds) {
            if (!gameState.cards || !gameState.cards.collection) return false;
            
            // é©—è­‰å¡ç‰Œæ•¸é‡
            if (cardIds.length !== 3) {
                addLog('èåˆ', 'éœ€è¦æ­£å¥½ 3 å¼µå¡ç‰Œæ‰èƒ½èåˆï¼');
                return false;
            }
            
            // ç²å–å¡ç‰Œï¼ˆä½¿ç”¨ UUIDï¼‰
            const cards = cardIds.map(uuid => gameState.cards.collection.find(c => c.uuid === uuid)).filter(c => c);
            if (cards.length !== 3) {
                addLog('èåˆ', 'å¡ç‰Œä¸å­˜åœ¨ï¼');
                return false;
            }
            
            // é©—è­‰ç­‰ç´š
            if (!cards.every(c => c.level === 10)) {
                addLog('èåˆ', 'æ‰€æœ‰å¡ç‰Œå¿…é ˆé”åˆ° Lv.10 æ‰èƒ½èåˆï¼');
                return false;
            }
            
            // é©—è­‰ç³»åˆ—å’Œå“éš
            const series = cards[0].series;
            const rarity = cards[0].rarity;
            if (!cards.every(c => c.series === series && c.rarity === rarity)) {
                addLog('èåˆ', 'å¿…é ˆæ˜¯ç›¸åŒç³»åˆ—å’Œå“éšçš„å¡ç‰Œï¼');
                return false;
            }
            
            // ç²å–ä¸‹ä¸€å€‹å“éš
            const nextRarity = getNextRarity(rarity);
            if (!nextRarity) {
                addLog('èåˆ', 'è©²å“éšå·²ç¶“æ˜¯æœ€é«˜ç´šï¼Œç„¡æ³•èåˆï¼');
                return false;
            }
            
            // æª¢æŸ¥é‡‘å¹£
            const cost = getFusionCost(rarity);
            if (gameState.gold < cost) {
                addLog('èåˆ', `é‡‘å¹£ä¸è¶³ï¼éœ€è¦ ${cost} é‡‘å¹£ã€‚`);
                return false;
            }
            
            // æ‰¾åˆ°ä¸‹ä¸€å“éšçš„åŒç³»åˆ—å¡ç‰Œ
            const nextRarityCardId = Object.values(CARDS).find(c => c.series === series && c.rarity === nextRarity)?.id;
            if (!nextRarityCardId) {
                addLog('èåˆ', 'æ‰¾ä¸åˆ°ä¸‹ä¸€å“éšçš„å¡ç‰Œï¼');
                return false;
            }
            
            // æ”¶é›†ææ–™å¡çš„è©ç¶´
            const materialAffixes = [];
            cards.forEach(card => {
                if (card.affixes && card.affixes.length > 0) {
                    materialAffixes.push(...card.affixes);
                }
            });
            
            // ç§»é™¤ææ–™å¡ç‰Œï¼ˆä½¿ç”¨ UUIDï¼‰
            cardIds.forEach(cardUuid => {
                const index = gameState.cards.collection.findIndex(c => c.uuid === cardUuid);
                if (index !== -1) {
                    // å¦‚æœå¡ç‰Œè¢«è£å‚™ï¼Œå…ˆå¸ä¸‹
                    if (gameState.cards.slot1 === cardUuid) gameState.cards.slot1 = null;
                    if (gameState.cards.slot2 === cardUuid) gameState.cards.slot2 = null;
                    gameState.cards.collection.splice(index, 1);
                }
            });
            
            // æ‰£é™¤é‡‘å¹£
            gameState.gold -= cost;
            
            // ç”Ÿæˆæ–°å¡ç‰Œçš„è©ç¶´
            const newAffixes = [];
            
            // 1. å¿…å®šç²å¾— 1 å€‹éš¨æ©Ÿæ–°è©ç¶´
            const newAffix = getRandomAffix();
            if (newAffix) newAffixes.push(newAffix);
            
            // 2. 50% æ©Ÿç‡ç¹¼æ‰¿ææ–™å¡çš„ä¸€å€‹è©ç¶´
            if (materialAffixes.length > 0 && Math.random() < 0.5) {
                const inheritedAffix = materialAffixes[Math.floor(Math.random() * materialAffixes.length)];
                // ç¢ºä¿ä¸é‡è¤‡
                if (!newAffixes.find(a => a.id === inheritedAffix.id)) {
                    newAffixes.push(JSON.parse(JSON.stringify(inheritedAffix)));
                }
            }
            
            // 3. 30% æ©Ÿç‡ç²å¾—ç¬¬ 2 å€‹éš¨æ©Ÿè©ç¶´
            if (newAffixes.length < 2 && Math.random() < 0.3) {
                const excludeIds = newAffixes.map(a => a.id);
                const extraAffix = getRandomAffix(excludeIds);
                if (extraAffix) newAffixes.push(extraAffix);
            }
            
            // ç²å–æ–°å¡ç‰Œ
            const nextCard = CARDS[nextRarityCardId];
            
            // æ·»åŠ æ–°å¡ç‰Œï¼ˆä¸å†æª¢æŸ¥é‡è¤‡ï¼Œå…è¨±æ”¶è—å¤šå¼µï¼‰
            const fusedCard = {
                uuid: Date.now() + Math.random(), // å”¯ä¸€ ID
                id: nextCard.id,
                name: nextCard.name,
                type: nextCard.type,
                rarity: nextCard.rarity,
                series: nextCard.series,
                description: nextCard.description,
                effect: nextCard.effect,
                icon: nextCard.icon,
                level: 1,
                exp: 0,
                affixes: newAffixes
            };
            
            gameState.cards.collection.push(fusedCard);
            gameState.cards.stats.totalCardsObtained++;
            recordCardObtained(nextCard.id);
            
            const rarityColor = getRarityColor(nextCard.rarity);
            const rarityObj = RARITIES.find(r => r.name === nextCard.rarity);
            const rarityLabel = rarityObj ? rarityObj.label : nextCard.rarity;
            
            let affixText = '';
            if (newAffixes.length > 0) {
                const affixNames = newAffixes.map(a => `<span style="color: ${a.color}">${a.name}</span>`).join('ã€');
                affixText = ` é™„å¸¶è©ç¶´ï¼š${affixNames}`;
            }
            
            addLog('èåˆ', `èåˆæˆåŠŸï¼ç²å¾—å¡ç‰Œï¼š${nextCard.icon} <span style="color: ${rarityColor}">${nextCard.name}</span> (${rarityLabel})${affixText}ï¼`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šèåˆå¡ç‰Œ
            updateQuestProgress('fuse_card', 1);
            
            recalculateStats();
            updateCardModal();
            saveGame();
            
            return true;
        }
        
        // è§¸ç™¼å¡ç‰Œæ•ˆæœï¼ˆæ”»æ“Šæ™‚ï¼‰
        function triggerCardEffectsOnAttack(damage, enemy) {
            if (!gameState.cards) return { damage, effects: [] };
            
            let finalDamage = damage;
            const effects = [];
            
            // æª¢æŸ¥è£å‚™çš„å¡ç‰Œ
            [gameState.cards.slot1, gameState.cards.slot2].forEach(cardId => {
                if (!cardId) return;
                
                const card = gameState.cards.collection.find(c => c.id === cardId);
                if (!card) return;
                
                const cardData = CARDS[cardId];
                if (!cardData || !cardData.trigger) return;
                
                // åªè™•ç†æ”»æ“Šæ™‚è§¸ç™¼çš„æ•ˆæœ
                if (cardData.trigger.type === 'onAttack') {
                    const trigger = cardData.trigger;
                    const levelMultiplier = getCardLevelMultiplier(card.level);
                    
                    // æª¢æŸ¥è§¸ç™¼æ©Ÿç‡
                    if (Math.random() < trigger.chance) {
                        if (trigger.effect === 'extraDamage') {
                            // é¡å¤–å‚·å®³
                            const extraDmg = Math.floor(damage * trigger.value * levelMultiplier);
                            finalDamage += extraDmg;
                            effects.push({
                                card: card,
                                type: 'extraDamage',
                                value: extraDmg,
                                icon: cardData.icon
                            });
                        } else if (trigger.effect === 'chain') {
                            // é€£é£å‚·å®³
                            const chainDmg = Math.floor(damage * trigger.value * levelMultiplier);
                            const chainCount = trigger.count || 2;
                            const totalChainDmg = chainDmg * chainCount;
                            finalDamage += totalChainDmg;
                            effects.push({
                                card: card,
                                type: 'chain',
                                value: totalChainDmg,
                                count: chainCount,
                                icon: cardData.icon
                            });
                        }
                    }
                }
            });
            
            return { damage: finalDamage, effects };
        }
        
        // è§¸ç™¼å¡ç‰Œæ•ˆæœï¼ˆå—æ“Šæ™‚ï¼‰
        function triggerCardEffectsOnHit(damage, enemy) {
            if (!gameState.cards) return { counterDamage: 0, effects: [] };
            
            let counterDamage = 0;
            const effects = [];
            
            // æª¢æŸ¥è£å‚™çš„å¡ç‰Œ
            [gameState.cards.slot1, gameState.cards.slot2].forEach(cardId => {
                if (!cardId) return;
                
                const card = gameState.cards.collection.find(c => c.id === cardId);
                if (!card) return;
                
                const cardData = CARDS[cardId];
                if (!cardData || !cardData.trigger) return;
                
                // åªè™•ç†å—æ“Šæ™‚è§¸ç™¼çš„æ•ˆæœ
                if (cardData.trigger.type === 'onHit') {
                    const trigger = cardData.trigger;
                    const levelMultiplier = getCardLevelMultiplier(card.level);
                    
                    // æª¢æŸ¥è§¸ç™¼æ©Ÿç‡
                    if (Math.random() < trigger.chance) {
                        if (trigger.effect === 'counter') {
                            // åæ“Šå‚·å®³
                            const counterDmg = Math.floor(gameState.player.atk * trigger.value * levelMultiplier);
                            counterDamage += counterDmg;
                            effects.push({
                                card: card,
                                type: 'counter',
                                value: counterDmg,
                                icon: cardData.icon
                            });
                        }
                    }
                }
            });
            
            return { counterDamage, effects };
        }
        
        // è§¸ç™¼å¡ç‰Œæ•ˆæœï¼ˆæˆ°é¬¥é–‹å§‹ï¼‰
        function triggerCardEffectsOnBattleStart() {
            if (!gameState.cards) return { effects: [] };
            
            const effects = [];
            
            // æª¢æŸ¥è£å‚™çš„å¡ç‰Œ
            [gameState.cards.slot1, gameState.cards.slot2].forEach(cardId => {
                if (!cardId) return;
                
                const card = gameState.cards.collection.find(c => c.id === cardId);
                if (!card) return;
                
                const cardData = CARDS[cardId];
                if (!cardData || !cardData.trigger) return;
                
                // åªè™•ç†æˆ°é¬¥é–‹å§‹æ™‚è§¸ç™¼çš„æ•ˆæœ
                if (cardData.trigger.type === 'onBattleStart') {
                    const trigger = cardData.trigger;
                    const levelMultiplier = getCardLevelMultiplier(card.level);
                    
                    // æª¢æŸ¥è§¸ç™¼æ©Ÿç‡
                    if (Math.random() < trigger.chance) {
                        if (trigger.effect === 'buff') {
                            // å¢ç›ŠBuff
                            effects.push({
                                card: card,
                                type: 'buff',
                                stat: trigger.stat,
                                value: trigger.value * levelMultiplier,
                                duration: trigger.duration,
                                icon: cardData.icon
                            });
                        }
                    }
                }
            });
            
            return { effects };
        }

        // ========== é›¢ç·šæ”¶ç›Šç³»çµ± ==========
        
        // è¨ˆç®—é›¢ç·šæ”¶ç›Š
        function calculateOfflineRewards(offlineTimeMs) {
            let offlineHours = offlineTimeMs / (1000 * 60 * 60);
            
            // æ™‚é–“ä¿‚æ•¸ï¼ˆå„ªåŒ–å¾Œï¼‰
            let timeCoefficient = 1.0;
            
            // é™åˆ¶æœ€å¤š12å°æ™‚
            if (offlineHours > 12) {
                offlineHours = 12;
            }
            
            if (offlineHours <= 4) {
                timeCoefficient = 1.0;      // 100%æ•ˆç‡
            } else if (offlineHours <= 8) {
                timeCoefficient = 0.95;     // 95%æ•ˆç‡
            } else {
                timeCoefficient = 0.9;      // 90%æ•ˆç‡
            }
            
            // ç²å–ç•¶å‰å€åŸŸè³‡è¨Š
            const region = REGIONS[gameState.region] || REGIONS[0];
            const playerLevel = gameState.player.level;
            
            // è¨ˆç®—æ•ˆç‡ä¿‚æ•¸ï¼ˆåŸºæ–¼è£å‚™å’Œéš¨å¾ï¼‰
            let efficiencyCoefficient = 1.0;
            
            // è£å‚™è©•åˆ†åŠ æˆï¼ˆæ ¹æ“šæ–°è£å‚™é»æ•¸ç³»çµ±ï¼‰
            let equipmentScore = 0;
            Object.values(gameState.player.equipment).forEach(item => {
                if (item) {
                    const rarityScores = {
                        'Common': 50,      // å…¥é–€é–‹ç™¼å±¤
                        'Fine': 90,        // ç ”ç™¼æ ¸å¿ƒå±¤
                        'Rare': 140,       // è³‡æ–™è£‚ç¸«
                        'Epic': 200,       // æ·±äº•è‡¨ç•Œå±¤
                        'Legendary': 300,  // å‚³èªªè£å‚™
                        'Mythic': 400,     // ç¥è©±è£å‚™
                        'Eternal': 550,    // æ°¸æ†è£å‚™
                        'Set': 180
                    };
                    equipmentScore += rarityScores[item.rarity] || 50;
                }
            });
            efficiencyCoefficient += equipmentScore / 2000;
            
            // éš¨å¾ç­‰ç´šåŠ æˆ
            const activeCompanion = getActiveCompanion();
            if (activeCompanion) {
                efficiencyCoefficient += activeCompanion.level / 100;
            }
            
            // è¨ˆç®—åŠ æˆä¿‚æ•¸ï¼ˆå¤©è³¦ã€ç¨±è™Ÿã€éš¨å¾ï¼‰
            let bonusCoefficient = 1.0;
            
            // å¤©è³¦åŠ æˆï¼ˆå‡è¨­æœ‰é›¢ç·šå¤§å¸«å¤©è³¦ï¼‰
            // é€™è£¡å¯ä»¥æ ¹æ“šå¯¦éš›å¤©è³¦ç³»çµ±èª¿æ•´
            
            // ç¨±è™ŸåŠ æˆ
            if (gameState.titles && gameState.titles.equipped && typeof TITLES_DATA !== 'undefined') {
                const equippedTitle = TITLES_DATA[gameState.titles.equipped];
                if (equippedTitle && equippedTitle.bonus) {
                    // å‡è¨­æŸäº›ç¨±è™Ÿæä¾›é›¢ç·šæ”¶ç›ŠåŠ æˆ
                    // é€™è£¡å¯ä»¥æ ¹æ“šå¯¦éš›ç¨±è™Ÿæ•ˆæœèª¿æ•´
                }
            }
            
            // éš¨å¾åŠ æˆï¼ˆå„ªåŒ–å¾Œï¼‰
            if (activeCompanion) {
                if (activeCompanion.type === 'resource') {
                    bonusCoefficient += 0.2 + (activeCompanion.level * 0.02); // 20% + 2%/ç´š
                } else {
                    bonusCoefficient += 0.1 + (activeCompanion.level * 0.01); // 10% + 1%/ç´š
                }
            }
            
            // åŸºç¤æ”¶ç›Šè¨ˆç®—ï¼ˆæ ¹æ“šæ–°å¹³è¡¡æ•¸å€¼ï¼‰
            // é‡‘å¹£: æ¯å°æ™‚æ“Šæ•¥20éš»æ€ªç‰©ï¼Œå¹³å‡æ‰è½ level * 4.5
            const baseGoldPerHour = playerLevel * 90;
            // ç¶“é©—: æ¯å°æ™‚æ“Šæ•¥20éš»æ€ªç‰©ï¼Œå¹³å‡ç¶“é©— (level * 2 + 10)
            const baseExpPerHour = (playerLevel * 2 + 10) * 20;
            
            // è¨ˆç®—ç¸½æ”¶ç›Šï¼ˆæ‡‰ç”¨æ‰€æœ‰ä¿‚æ•¸ï¼‰
            const goldReward = Math.floor(baseGoldPerHour * offlineHours * timeCoefficient * efficiencyCoefficient * bonusCoefficient);
            const expReward = Math.floor(baseExpPerHour * offlineHours * timeCoefficient * efficiencyCoefficient * bonusCoefficient);
            
            // è¨ˆç®—è£å‚™æ‰è½ï¼ˆæ¯3å°æ™‚1ä»¶ï¼Œå„ªåŒ–å¾Œï¼‰
            const itemDrops = [];
            const dropCount = Math.floor(offlineHours / 3);
            const maxDrops = Math.min(dropCount, 8); // æœ€å¤šä¿å­˜8ä»¶
            
            for (let i = 0; i < maxDrops; i++) {
                const item = generateOfflineItem();
                if (item) itemDrops.push(item);
            }
            
            // è¨ˆç®—æ¶ˆè€—å“æ‰è½
            const consumableDrops = generateOfflineConsumables(offlineHours, region);
            
            // è¨ˆç®—éš¨å¾ç¶“é©—
            let companionExpReward = 0;
            if (activeCompanion) {
                companionExpReward = Math.floor(expReward * 0.5);
            }
            
            // è¨ˆç®—å¡ç‰Œæ‰è½ï¼ˆæ¯8å°æ™‚æ‰è½1å¼µå¡ç‰Œæˆ–ç¢ç‰‡ï¼‰
            const cardDrops = [];
            const shardDrops = {};
            const cardDropCount = Math.floor(offlineHours / 8); // æ¯8å°æ™‚
            const maxCardDrops = Math.min(cardDropCount, 3); // æœ€å¤š3å¼µ
            
            for (let i = 0; i < maxCardDrops; i++) {
                const dropResult = generateOfflineCard();
                if (dropResult.type === 'card') {
                    cardDrops.push(dropResult.card);
                } else if (dropResult.type === 'shards') {
                    shardDrops[dropResult.rarity] = (shardDrops[dropResult.rarity] || 0) + dropResult.amount;
                }
            }
            
            return {
                offlineTime: offlineTimeMs,
                offlineHours: offlineHours,
                timeCoefficient: timeCoefficient,
                efficiencyCoefficient: efficiencyCoefficient,
                bonusCoefficient: bonusCoefficient,
                goldReward: goldReward,
                expReward: expReward,
                baseGoldPerHour: baseGoldPerHour,
                baseExpPerHour: baseExpPerHour,
                itemDrops: itemDrops,
                consumableDrops: consumableDrops,
                companionExpReward: companionExpReward,
                companionName: activeCompanion ? activeCompanion.name : null,
                cardDrops: cardDrops,
                shardDrops: shardDrops
            };
        }
        
        // ç”Ÿæˆé›¢ç·šè£å‚™æ‰è½
        function generateOfflineItem() {
            // æ ¹æ“šç©å®¶ç­‰ç´šèª¿æ•´å“è³ªåˆ†å¸ƒ
            const playerLevel = gameState.player.level;
            const rand = Math.random();
            let rarity;
            
            if (playerLevel < 25) {
                // 1-25ç´š: Common 60%, Fine 30%, Rare 10%
                if (rand < 0.60) rarity = 'Common';
                else if (rand < 0.90) rarity = 'Fine';
                else rarity = 'Rare';
            } else if (playerLevel < 50) {
                // 26-50ç´š: Common 40%, Fine 35%, Rare 20%, Epic 5%
                if (rand < 0.40) rarity = 'Common';
                else if (rand < 0.75) rarity = 'Fine';
                else if (rand < 0.95) rarity = 'Rare';
                else rarity = 'Epic';
            } else if (playerLevel < 75) {
                // 51-75ç´š: Common 20%, Fine 30%, Rare 35%, Epic 13%, Legendary 2%
                if (rand < 0.20) rarity = 'Common';
                else if (rand < 0.50) rarity = 'Fine';
                else if (rand < 0.85) rarity = 'Rare';
                else if (rand < 0.98) rarity = 'Epic';
                else rarity = 'Legendary';
            } else {
                // 76-100ç´š: Common 10%, Fine 20%, Rare 35%, Epic 24%, Legendary 8%, Mythic 2.5%, Eternal 0.5%
                if (rand < 0.10) rarity = 'Common';
                else if (rand < 0.30) rarity = 'Fine';
                else if (rand < 0.65) rarity = 'Rare';
                else if (rand < 0.89) rarity = 'Epic';
                else if (rand < 0.97) rarity = 'Legendary';
                else if (rand < 0.995) rarity = 'Mythic';
                else rarity = 'Eternal';
            }
            
            // éš¨æ©Ÿé¸æ“‡è£å‚™é¡å‹
            const types = ['weapon', 'armor', 'ring', 'necklace'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            // ç”Ÿæˆè£å‚™
            const item = generateItem(rarity, type);            return item;
        }
        
        // ç”Ÿæˆé›¢ç·šå¡ç‰Œæ‰è½
        function generateOfflineCard() {
            // å“è³ªåˆ†å¸ƒï¼šCommon 60%, Fine 25%, Rare 10%, Epic 4%, Legendary 1%
            const rand = Math.random();
            let rarity;
            if (rand < 0.60) rarity = 'Common';
            else if (rand < 0.85) rarity = 'Fine';
            else if (rand < 0.95) rarity = 'Rare';
            else if (rand < 0.99) rarity = 'Epic';
            else rarity = 'Legendary';
            
            // ç²å¾—è©²å“è³ªçš„å¡ç‰Œåˆ—è¡¨
            const availableCards = Object.values(CARDS).filter(c => c.rarity === rarity);
            if (availableCards.length === 0) {
                // å¦‚æœæ²’æœ‰è©²å“è³ªçš„å¡ç‰Œï¼Œè¿”å›ç¢ç‰‡
                return {
                    type: 'shards',
                    rarity: rarity,
                    amount: getShardAmount(rarity)
                };
            }
            
            const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
            
            // ä¸å†æª¢æŸ¥é‡è¤‡ï¼Œç›´æ¥è¿”å›å¡ç‰Œï¼ˆå…è¨±æ”¶è—å¤šå¼µï¼‰
            return {
                type: 'card',
                card: randomCard
            };
        }
        
        // é›¢ç·šæ”¶ç›Šé¡¯ç¤ºè€—å“æ‰è½
        function generateOfflineConsumables(offlineHours, region) {
            const consumables = [];
            
            // æ¯2å°æ™‚é€²è¡Œä¸€æ¬¡æ¶ˆè€—å“æ‰è½æª¢æŸ¥ï¼ˆå„ªåŒ–å¾Œï¼‰
            const consumableChecks = Math.floor(offlineHours / 2);
            const maxChecks = Math.min(consumableChecks, 24); // æœ€å¤š24æ¬¡
            
            const regionConsumables = REGION_CONSUMABLES[region.name];
            if (!regionConsumables) return consumables;
            
            for (let i = 0; i < maxChecks; i++) {
                // HPè—¥æ°´
                if (Math.random() < regionConsumables.hp.dropRate) {
                    addOfflineConsumable(consumables, {
                        type: 'consumable',
                        subtype: 'hp',
                        name: regionConsumables.hp.name,
                        recovery: regionConsumables.hp.recovery,
                        description: `[ç«‹å³] æ¢å¾©${Math.floor(regionConsumables.hp.recovery * 100)}%æœ€å¤§ç”Ÿå‘½å€¼`
                    });
                }
                
                // APè—¥æ°´
                if (Math.random() < regionConsumables.ap.dropRate) {
                    addOfflineConsumable(consumables, {
                        type: 'consumable',
                        subtype: 'ap',
                        name: regionConsumables.ap.name,
                        recovery: regionConsumables.ap.recovery,
                        description: `[ç«‹å³] æ¢å¾©${regionConsumables.ap.recovery}é»è¡Œå‹•åŠ›`
                    });
                }
                
                // ç¶“é©—å·è»¸
                if (Math.random() < regionConsumables.exp.dropRate) {
                    addOfflineConsumable(consumables, {
                        type: 'consumable',
                        subtype: 'exp',
                        name: regionConsumables.exp.name,
                        exp: regionConsumables.exp.exp,
                        description: `[ç«‹å³] ç²å¾—${regionConsumables.exp.exp}é»ç¶“é©—å€¼`
                    });
                }
                
                // å¹¸é‹ç¡¬å¹£
                if (regionConsumables.lucky && Math.random() < regionConsumables.lucky.dropRate) {
                    addOfflineConsumable(consumables, {
                        type: 'consumable',
                        subtype: 'lucky',
                        name: regionConsumables.lucky.name,
                        description: '[ä¸€æ¬¡æ€§] ä¸‹æ¬¡æˆ°é¬¥æ‰è½ç‡æå‡100%'
                    });
                }
                
                // é›™å€ç¶“é©—å·
                if (regionConsumables.expBoost && Math.random() < regionConsumables.expBoost.dropRate) {
                    addOfflineConsumable(consumables, {
                        type: 'consumable',
                        subtype: 'expBoost',
                        name: regionConsumables.expBoost.name,
                        description: '[ä¸€æ¬¡æ€§] ä¸‹æ¬¡æˆ°é¬¥ç²å¾—é›™å€ç¶“é©—'
                    });
                }
                
                // ä¿è­·ç¬¦å’’
                if (regionConsumables.protection && Math.random() < regionConsumables.protection.dropRate) {
                    addOfflineConsumable(consumables, {
                        type: 'consumable',
                        subtype: 'protection',
                        name: regionConsumables.protection.name,
                        description: '[ä¸€æ¬¡æ€§] æ­»äº¡æ™‚ä¿ç•50%ç¶“é©—å’Œé‡‘å¹£'
                    });
                }
            }
            
            return consumables;
        }
        
        // æ·»åŠ é›¢ç·šæ¶ˆè€—å“åˆ°åˆ—è¡¨ï¼ˆè‡ªå‹•å †ç–Šï¼‰
        function addOfflineConsumable(consumables, newItem) {
            const existing = consumables.find(c => c.name === newItem.name && c.subtype === newItem.subtype);
            if (existing) {
                existing.quantity = (existing.quantity || 1) + 1;
            } else {
                newItem.id = Date.now() + Math.random();
                newItem.quantity = 1;
                consumables.push(newItem);
            }
        }
        
        // ç”Ÿæˆæ¶ˆè€—å“ï¼ˆè¼”åŠ©å‡½æ•¸ï¼‰
        function generateConsumable(type, region) {
            const regionName = region.name;
            const consumableData = REGION_CONSUMABLES[regionName];
            if (!consumableData) return null;
            
            // æ ¹æ“šé¡å‹æ˜ å°„åˆ°REGION_CONSUMABLESçš„å±¬æ€§
            let consumableType;
            if (type === 'hp_potion') {
                consumableType = 'hp';
            } else if (type === 'ap_potion') {
                consumableType = 'ap';
            } else if (type === 'atk_scroll' || type === 'def_scroll' || type === 'crit_scroll') {
                consumableType = 'buff';
            } else if (type === 'exp_scroll') {
                consumableType = 'exp';
            } else {
                return null;
            }
            
            const item = consumableData[consumableType];
            if (!item) return null;
            
            // è¿”å›å®Œæ•´çš„æ¶ˆè€—å“çµæ§‹
            const consumable = {
                id: Date.now() + Math.random(),
                type: 'consumable',
                subtype: consumableType,
                name: item.name,
                quantity: 1
            };
            
            // æ ¹æ“šé¡å‹æ·»åŠ å±¬æ€§
            if (consumableType === 'hp' || consumableType === 'ap') {
                consumable.recovery = item.recovery;
            } else if (consumableType === 'buff') {
                // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ•ˆæœ
                const randomEffect = item.effects[Math.floor(Math.random() * item.effects.length)];
                consumable.effect = randomEffect;
            } else if (consumableType === 'exp') {
                consumable.exp = item.exp;
            }
            
            return consumable;
        }
        
        // é¡¯ç¤ºé›¢ç·šæ”¶ç›Šå½ˆçª—
        function showOfflineRewardsModal(rewards) {
            const hours = Math.floor(rewards.offlineHours);
            const minutes = Math.floor((rewards.offlineHours - hours) * 60);
            const timeText = hours > 0 ? `${hours}å°æ™‚${minutes}åˆ†é˜` : `${minutes}åˆ†é˜`;
            
            const timeCoefficientPercent = Math.round(rewards.timeCoefficient * 100);
            const efficiencyPercent = Math.round(rewards.efficiencyCoefficient * 100);
            const bonusPercent = Math.round(rewards.bonusCoefficient * 100);
            
            // è£å‚™æ‰è½é¡¯ç¤º
            let itemsHtml = '';
            if (rewards.itemDrops && rewards.itemDrops.length > 0) {
                itemsHtml = rewards.itemDrops.map(item => {
                    const rarityColor = getRarityColor(item.rarity);
                    const rarityObj = RARITIES.find(r => r.name === item.rarity);
                    const rarityLabel = rarityObj ? rarityObj.label : item.rarity;
                    return `<div style="color: ${rarityColor}; font-size: 0.85rem; margin: 3px 0;">â€¢ ${item.name} (${rarityLabel})</div>`;
                }).join('');
            } else {
                itemsHtml = '<div style="color: #7a8fb8; font-size: 0.85rem; text-align: center;">ç„¡</div>';
            }
            
            // æ¶ˆè€—å“æ‰è½é¡¯ç¤º
            let consumablesHtml = '';
            if (rewards.consumableDrops && rewards.consumableDrops.length > 0) {
                consumablesHtml = rewards.consumableDrops.map(item => {
                    return `<div style="color: #4EA5FF; font-size: 0.85rem; margin: 3px 0;">â€¢ ${item.name} Ã—${item.quantity}</div>`;
                }).join('');
            } else {
                consumablesHtml = '<div style="color: #7a8fb8; font-size: 0.85rem; text-align: center;">ç„¡</div>';
            }
            
            // å¡ç‰Œå’Œç¢ç‰‡æ‰è½é¡¯ç¤º
            let cardDropsHtml = '';
            if ((rewards.cardDrops && rewards.cardDrops.length > 0) || (rewards.shardDrops && Object.keys(rewards.shardDrops).length > 0)) {
                let cardsListHtml = '';
                
                // å¡ç‰Œæ‰è½
                if (rewards.cardDrops && rewards.cardDrops.length > 0) {
                    cardsListHtml += rewards.cardDrops.map(card => {
                        const rarityColor = getRarityColor(card.rarity);
                        const rarityObj = RARITIES.find(r => r.name === card.rarity);
                        const rarityLabel = rarityObj ? rarityObj.label : card.rarity;
                        return `<div style="color: ${rarityColor}; font-size: 0.85rem; margin: 3px 0;">â€¢ ${card.icon} ${card.name} (${rarityLabel})</div>`;
                    }).join('');
                }
                
                // ç¢ç‰‡æ‰è½
                if (rewards.shardDrops && Object.keys(rewards.shardDrops).length > 0) {
                    Object.entries(rewards.shardDrops).forEach(([rarity, amount]) => {
                        const rarityColor = getRarityColor(rarity);
                        const rarityObj = RARITIES.find(r => r.name === rarity);
                        const rarityLabel = rarityObj ? rarityObj.label : rarity;
                        cardsListHtml += `<div style="color: ${rarityColor}; font-size: 0.85rem; margin: 3px 0;">â€¢ ${rarityLabel}ç¢ç‰‡ Ã—${amount}</div>`;
                    });
                }
                
                if (!cardsListHtml) {
                    cardsListHtml = '<div style="color: #7a8fb8; font-size: 0.85rem; text-align: center;">ç„¡</div>';
                }
                
                const totalCards = (rewards.cardDrops ? rewards.cardDrops.length : 0);
                const totalShards = rewards.shardDrops ? Object.keys(rewards.shardDrops).length : 0;
                
                cardDropsHtml = `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 1.1rem; font-weight: bold; color: #8a2be2; margin-bottom: 10px;">ğŸƒ å¡ç‰Œæ‰è½ (${totalCards}å¼µ + ${totalShards}ç¨®ç¢ç‰‡)</div>
                        <div style="background: rgba(138, 43, 226, 0.1); padding: 12px; border-radius: 8px; max-height: 150px; overflow-y: auto;">
                            ${cardsListHtml}
                        </div>
                    </div>
                `;
            }
            
            // éš¨å¾ç¶“é©—é¡¯ç¤º
            let companionExpHtml = '';
            if (rewards.companionExpReward > 0 && rewards.companionName) {
                companionExpHtml = `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 1.1rem; font-weight: bold; color: #ff9a56; margin-bottom: 10px;">ğŸ¾ éš¨å¾ç¶“é©—</div>
                        <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">
                                <span>éš¨å¾ï¼š</span>
                                <span style="color: #00ff88;">${rewards.companionName}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; font-size: 1rem; font-weight: bold;">
                                <span style="color: #ff9a56;">ç¶“é©—ï¼š</span>
                                <span style="color: #00ff88;">+${rewards.companionExpReward.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            const modalHtml = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #00d9ff; margin-bottom: 10px;">ğŸŒ™ é›¢ç·šæ”¶ç›Šçµç®— ğŸŒ™</div>
                    <div style="color: #7a8fb8; font-size: 0.9rem;">é›¢ç·šæ™‚é–“ï¼š<span style="color: #00ff88; font-weight: bold;">${timeText}</span></div>
                    <div style="display: flex; gap: 15px; justify-content: center; margin-top: 5px;">
                        <div style="color: #7a8fb8; font-size: 0.85rem;">æ™‚é–“ï¼š<span style="color: #4EA5FF; font-weight: bold;">${timeCoefficientPercent}%</span></div>
                        <div style="color: #7a8fb8; font-size: 0.85rem;">æ•ˆç‡ï¼š<span style="color: #4EA5FF; font-weight: bold;">${efficiencyPercent}%</span></div>
                        <div style="color: #7a8fb8; font-size: 0.85rem;">åŠ æˆï¼š<span style="color: #4EA5FF; font-weight: bold;">${bonusPercent}%</span></div>
                    </div>
                </div>
                
                <div style="border-top: 2px solid rgba(0, 217, 255, 0.3); margin: 20px 0;"></div>
                
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 1.1rem; font-weight: bold; color: #ffd700; margin-bottom: 10px;">ğŸ’° é‡‘å¹£æ”¶ç›Š</div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">
                            <span>åŸºç¤æ”¶ç›Šï¼š</span>
                            <span style="color: #fff;">${Math.floor(rewards.baseGoldPerHour * rewards.offlineHours)}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">
                            <span>æ™‚é–“åŠ æˆï¼š</span>
                            <span style="color: #4EA5FF;">Ã—${rewards.timeCoefficient.toFixed(1)}</span>
                        </div>
                        <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 8px 0; padding-top: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 1rem; font-weight: bold;">
                                <span style="color: #ffd700;">ç¸½è¨ˆï¼š</span>
                                <span style="color: #00ff88;">+${rewards.goldReward.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 1.1rem; font-weight: bold; color: #4EA5FF; margin-bottom: 10px;">â­ ç¶“é©—æ”¶ç›Š</div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                        <div style="display: flex; justify-content: space-between; color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">
                            <span>åŸºç¤æ”¶ç›Šï¼š</span>
                            <span style="color: #fff;">${Math.floor(rewards.baseExpPerHour * rewards.offlineHours)}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; color: #7a8fb8; font-size: 0.85rem; margin-bottom: 5px;">
                            <span>æ™‚é–“åŠ æˆï¼š</span>
                            <span style="color: #4EA5FF;">Ã—${rewards.timeCoefficient.toFixed(1)}</span>
                        </div>
                        <div style="border-top: 1px solid rgba(255, 255, 255, 0.1); margin: 8px 0; padding-top: 8px;">
                            <div style="display: flex; justify-content: space-between; font-size: 1rem; font-weight: bold;">
                                <span style="color: #4EA5FF;">ç¸½è¨ˆï¼š</span>
                                <span style="color: #00ff88;">+${rewards.expReward.toLocaleString()}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="border-top: 2px solid rgba(0, 217, 255, 0.3); margin: 20px 0;"></div>
                
                ${companionExpHtml}
                
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 1.1rem; font-weight: bold; color: #9c27b0; margin-bottom: 10px;">ğŸª è£å‚™æ‰è½ (${rewards.itemDrops ? rewards.itemDrops.length : 0}ä»¶)</div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; max-height: 150px; overflow-y: auto;">
                        ${itemsHtml}
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 1.1rem; font-weight: bold; color: #4EA5FF; margin-bottom: 10px;">ğŸ§ª æ¶ˆè€—å“æ‰è½ (${rewards.consumableDrops ? rewards.consumableDrops.length : 0}ç¨®)</div>
                    <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; max-height: 150px; overflow-y: auto;">
                        ${consumablesHtml}
                    </div>
                </div>
                
                ${cardDropsHtml}
                
                <div style="border-top: 2px solid rgba(0, 217, 255, 0.3); margin: 20px 0;"></div>
                
                <button onclick="claimOfflineRewards()" style="width: 100%; padding: 15px; font-size: 1.1rem; font-weight: bold; background: linear-gradient(135deg, #00d9ff 0%, #00a8cc 100%); border: none; border-radius: 8px; color: #000; cursor: pointer;">
                    âœ… é ˜å–çå‹µ
                </button>
            `;
            
            const modal = document.getElementById('offline-rewards-modal');
            const content = document.getElementById('offline-rewards-content');
            content.innerHTML = modalHtml;
            modal.classList.add('active');
            
            // å„²å­˜çå‹µè³‡è¨Šä»¥ä¾¿é ˜å–
            window.pendingOfflineRewards = rewards;
        }
        
        // é ˜å–é›¢ç·šæ”¶ç›Š
        function claimOfflineRewards() {
            const rewards = window.pendingOfflineRewards;
            if (!rewards) return;
            
            // æ·»åŠ é‡‘å¹£å’Œç¶“é©—
            gameState.player.gold += rewards.goldReward;
            gameState.player.exp += rewards.expReward;
            
            // æ·»åŠ è£å‚™åˆ°èƒŒåŒ…
            let itemsAdded = 0;
            if (rewards.itemDrops && rewards.itemDrops.length > 0) {
                rewards.itemDrops.forEach(item => {
                    if (gameState.inventory.length < gameState.maxInventory) {
                        gameState.inventory.push(item);
                        gameState.stats.items++;
                        itemsAdded++;
                        
                        // çµ±è¨ˆå‚³èªªè£å‚™
                        if (item.rarity === 'legendary') {
                            gameState.stats.legendaryItems = (gameState.stats.legendaryItems || 0) + 1;
                        }
                        
                        // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
                        updateQuestProgress('collect_equipment', 1);
                        if (item.rarity === 'rare' || item.rarity === 'epic' || item.rarity === 'legendary' || item.rarity === 'set') {
                            updateQuestProgress('collect_rare', 1);
                        }
                        if (item.rarity === 'legendary') {
                            updateQuestProgress('collect_legendary', 1);
                        }
                    }
                });
            }
            
            // æ·»åŠ æ¶ˆè€—å“åˆ°èƒŒåŒ…
            let consumablesAdded = 0;
            if (rewards.consumableDrops && rewards.consumableDrops.length > 0) {
                rewards.consumableDrops.forEach(consumable => {
                    if (gameState.inventory.length < gameState.maxInventory) {
                        // æª¢æŸ¥æ˜¯å¦å·²æœ‰ç›¸åŒæ¶ˆè€—å“
                        const existing = gameState.inventory.find(i => i.id === consumable.id && i.type === 'consumable');
                        if (existing) {
                            existing.quantity = (existing.quantity || 1) + (consumable.quantity || 1);
                        } else {
                            gameState.inventory.push(consumable);
                        }
                        consumablesAdded += consumable.quantity || 1;
                    }
                });
            }
            
            // æ·»åŠ éš¨å¾ç¶“é©—
            if (rewards.companionExpReward > 0) {
                addCompanionExp(rewards.companionExpReward);
            }
            
            // æ·»åŠ å¡ç‰Œ
            let cardsAdded = 0;
            if (rewards.cardDrops && rewards.cardDrops.length > 0) {
                rewards.cardDrops.forEach(card => {
                    getCard(card.id);
                    cardsAdded++;
                });
            }
            
            // æ·»åŠ ç¢ç‰‡
            if (rewards.shardDrops && Object.keys(rewards.shardDrops).length > 0) {
                Object.entries(rewards.shardDrops).forEach(([rarity, amount]) => {
                    gameState.cards.shards[rarity] = (gameState.cards.shards[rarity] || 0) + amount;
                });
            }
            
            // æ›´æ–°çµ±è¨ˆ
            if (!gameState.offline.stats) {
                gameState.offline.stats = {
                    totalGoldEarned: 0,
                    totalExpEarned: 0,
                    claimCount: 0
                };
            }
            gameState.offline.stats.totalGoldEarned += rewards.goldReward;
            gameState.offline.stats.totalExpEarned += rewards.expReward;
            gameState.offline.stats.claimCount++;
            gameState.offline.totalOfflineTime += rewards.offlineTime;
            
            // æ¨™è¨˜å·²é ˜å–
            gameState.offline.rewardsClaimed = true;
            
            // æª¢æŸ¥å‡ç´š
            while (gameState.player.exp >= gameState.player.expToNext) {
                levelUp();
            }
            
            // æ›´æ–°UI
            updateUI();
            
            // é—œé–‰å½ˆçª—
            closeOfflineRewardsModal();
            
            // é¡¯ç¤ºè©³ç´°æç¤º
            addLog('é›¢ç·š', `âœ… é ˜å–é›¢ç·šæ”¶ç›Šï¼š${rewards.goldReward} é‡‘å¹£ã€${rewards.expReward} ç¶“é©—`);
            if (itemsAdded > 0) {
                addLog('é›¢ç·š', `ğŸª ç²å¾— ${itemsAdded} ä»¶è£å‚™`);
            }
            if (consumablesAdded > 0) {
                addLog('é›¢ç·š', `ğŸ§ª ç²å¾— ${consumablesAdded} å€‹æ¶ˆè€—å“`);
            }
            if (rewards.companionExpReward > 0) {
                addLog('é›¢ç·š', `ğŸ¾ ${rewards.companionName} ç²å¾— ${rewards.companionExpReward} é»ç¶“é©—`);
            }
            playSound('reward');
            
            // æ¸…ç†æš«å­˜è³‡æ–™
            window.pendingOfflineRewards = null;
            
            // å„²å­˜éŠæˆ²
            saveGame();
        }
        
        // é—œé–‰é›¢ç·šæ”¶ç›Šå½ˆçª—
        function closeOfflineRewardsModal() {
            document.getElementById('offline-rewards-modal').classList.remove('active');
        }
        
        // è¨˜éŒ„é›¢ç·šæ™‚é–“
        function recordOfflineTime() {
            if (!gameState.offline) {
                gameState.offline = {
                    lastOnlineTime: Date.now(),
                    totalOfflineTime: 0,
                    rewardsClaimed: true,
                    stats: {
                        totalGoldEarned: 0,
                        totalExpEarned: 0,
                        claimCount: 0
                    }
                };
            }
            gameState.offline.lastOnlineTime = Date.now();
        }
        
        // æª¢æŸ¥é›¢ç·šæ”¶ç›Š
        function checkOfflineRewards() {
            if (!gameState.offline) {
                recordOfflineTime();
                return;
            }
            
            const now = Date.now();
            const offlineTime = now - (gameState.offline.lastOnlineTime || now);
            
            // è¶…é30åˆ†é˜æ‰è¨ˆç®—é›¢ç·šæ”¶ç›Š
            if (offlineTime > 30 * 60 * 1000) {
                const rewards = calculateOfflineRewards(offlineTime);
                showOfflineRewardsModal(rewards);
            }
            
            // æ›´æ–°åœ¨ç·šæ™‚é–“
            recordOfflineTime();
        }

        // ========== å¼·åŒ–ç³»çµ± ==========

        // å¼·åŒ–æˆåŠŸç‡é…ç½®
        const ENHANCE_SUCCESS_RATE = {
            0: 100, 1: 100, 2: 100, 3: 100, 4: 100, 5: 100,  // +0~+5: 100%
            6: 80, 7: 80, 8: 80, 9: 80, 10: 80,              // +6~+10: 80%
            11: 60, 12: 60, 13: 60, 14: 60, 15: 60           // +11~+15: 60%
        };

        // å¼·åŒ–æ¶ˆè€—é‡‘å¹£é…ç½®
        const ENHANCE_COST = {
            0: 100, 1: 200, 2: 300, 3: 400, 4: 500,
            5: 700, 6: 1000, 7: 1500, 8: 2000, 9: 2500,
            10: 3500, 11: 5000, 12: 7000, 13: 10000, 14: 15000, 15: 20000
        };

        // è¨ˆç®—å¼·åŒ–å¾Œçš„å±¬æ€§åŠ æˆ
        function getEnhanceBonus(baseValue, enhanceLevel, statType) {
            if (enhanceLevel === 0) return 0;
            
            // æ¯ç´šå¢åŠ åŸºç¤å€¼çš„5%
            const percentBonus = enhanceLevel * 0.05;
            
            // ç™¾åˆ†æ¯”å±¬æ€§ï¼ˆæš´æ“Šç‡ã€æš´æ“Šå‚·å®³ç­‰ï¼‰ä½¿ç”¨å›ºå®šå€¼å¢åŠ 
            if (statType === 'crit') {
                return enhanceLevel * 0.5; // æ¯ç´š+0.5%
            } else if (statType === 'critDmg') {
                return enhanceLevel * 2; // æ¯ç´š+2%
            } else if (statType === 'dmgRed' || statType === 'lifeSteal' || statType === 'armorPen' || statType === 'bossDmg') {
                return enhanceLevel * 0.3; // æ¯ç´š+0.3%
            }
            
            // æ•¸å€¼å±¬æ€§ï¼ˆæ”»æ“Šã€é˜²ç¦¦ã€ç”Ÿå‘½ï¼‰ä½¿ç”¨ç™¾åˆ†æ¯”å¢åŠ 
            return Math.floor(baseValue * percentBonus);
        }

        // ç²å–è£å‚™çš„ç¸½å±¬æ€§ï¼ˆåŒ…å«å¼·åŒ–åŠ æˆï¼‰
        function getEnhancedStats(item) {
            if (!item || !item.enhance || item.enhance === 0) {
                return item;
            }
            
            const enhanced = { ...item };
            
            // è¨ˆç®—æ¯å€‹å±¬æ€§çš„å¼·åŒ–åŠ æˆ
            if (item.atk > 0) enhanced.atk = item.atk + getEnhanceBonus(item.atk, item.enhance, 'atk');
            if (item.def > 0) enhanced.def = item.def + getEnhanceBonus(item.def, item.enhance, 'def');
            if (item.hp > 0) enhanced.hp = item.hp + getEnhanceBonus(item.hp, item.enhance, 'hp');
            if (item.crit > 0) enhanced.crit = item.crit + getEnhanceBonus(item.crit, item.enhance, 'crit');
            if (item.critDmg > 0) enhanced.critDmg = item.critDmg + getEnhanceBonus(item.critDmg, item.enhance, 'critDmg');
            if (item.dmgRed > 0) enhanced.dmgRed = item.dmgRed + getEnhanceBonus(item.dmgRed, item.enhance, 'dmgRed');
            if (item.lifeSteal > 0) enhanced.lifeSteal = item.lifeSteal + getEnhanceBonus(item.lifeSteal, item.enhance, 'lifeSteal');
            if (item.armorPen > 0) enhanced.armorPen = item.armorPen + getEnhanceBonus(item.armorPen, item.enhance, 'armorPen');
            if (item.bossDmg > 0) enhanced.bossDmg = item.bossDmg + getEnhanceBonus(item.bossDmg, item.enhance, 'bossDmg');
            if (item.hpRegen > 0) enhanced.hpRegen = item.hpRegen + getEnhanceBonus(item.hpRegen, item.enhance, 'hpRegen');
            if (item.expBonus > 0) enhanced.expBonus = item.expBonus + getEnhanceBonus(item.expBonus, item.enhance, 'expBonus');
            if (item.luck > 0) enhanced.luck = item.luck + getEnhanceBonus(item.luck, item.enhance, 'luck');
            if (item.goldBonus > 0) enhanced.goldBonus = item.goldBonus + getEnhanceBonus(item.goldBonus, item.enhance, 'goldBonus');
            
            return enhanced;
        }

        // å¼·åŒ–è£å‚™
        function enhanceEquipment(itemId) {
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item || item.type === 'consumable') {
                addLog('å¼·åŒ–', 'ç„¡æ³•å¼·åŒ–æ­¤ç‰©å“ï¼');
                return false;
            }
            
            // åˆå§‹åŒ–enhanceå­—æ®µ
            if (!item.enhance) item.enhance = 0;
            
            // æª¢æŸ¥å¼·åŒ–ç­‰ç´šä¸Šé™
            if (item.enhance >= 15) {
                addLog('å¼·åŒ–', 'å·²é”åˆ°æœ€å¤§å¼·åŒ–ç­‰ç´šï¼');
                return false;
            }
            
            // è¨ˆç®—æ¶ˆè€—é‡‘å¹£å’Œå¼·åŒ–çŸ³
            const cost = ENHANCE_COST[item.enhance];
            let stoneRequired = 1;  // é è¨­ 1 å€‹
            if (item.enhance >= 11) {
                stoneRequired = 3;
            } else if (item.enhance >= 6) {
                stoneRequired = 2;
            }
            
            // æª¢æŸ¥é‡‘å¹£
            if (gameState.player.gold < cost) {
                addLog('å¼·åŒ–', `é‡‘å¹£ä¸è¶³ï¼éœ€è¦ ${cost} é‡‘å¹£`);
                return false;
            }
            
            // æª¢æŸ¥å¼·åŒ–çŸ³
            if (!gameState.materials) {
                gameState.materials = { enhanceStone: 0, reforgeStone: 0 };
            }
            if (gameState.materials.enhanceStone < stoneRequired) {
                addLog('å¼·åŒ–', `å¼·åŒ–çŸ³ä¸è¶³ï¼éœ€è¦ ${stoneRequired} å€‹å¼·åŒ–çŸ³`);
                return false;
            }
            
            // æ‰£é™¤é‡‘å¹£å’Œå¼·åŒ–çŸ³
            gameState.player.gold -= cost;
            gameState.materials.enhanceStone -= stoneRequired;
            
            // è¨ˆç®—æˆåŠŸç‡
            const successRate = ENHANCE_SUCCESS_RATE[item.enhance];
            const success = Math.random() * 100 < successRate;
            
            if (success) {
                // å¼·åŒ–æˆåŠŸ
                item.enhance++;
                addLog('å¼·åŒ–', `âœ¨ å¼·åŒ–æˆåŠŸ!${item.name} +${item.enhance}`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦
                updateQuestProgress('enhance', 1);
                
                // å¦‚æœè£å‚™å·²è£å‚™,é‡æ–°è¨ˆç®—å±¬æ€§
                if (isEquipped(item)) {
                    recalculateStats();
                }
                
                updateUI();
                openBagModal();
                saveGame();
                return true;
            } else {
                // å¼·åŒ–å¤±æ•—
                if (item.enhance >= 11) {
                    // +11ä»¥ä¸Šå¤±æ•—æœƒæ‰ç´š
                    item.enhance--;
                    addLog('å¼·åŒ–', `âŒ å¼·åŒ–å¤±æ•—ï¼${item.name} é™ç´šè‡³ +${item.enhance}`);
                } else {
                    addLog('å¼·åŒ–', `âŒ å¼·åŒ–å¤±æ•—ï¼ä½†è£å‚™æœªæå£`);
                }
                
                // å¦‚æœè£å‚™å·²è£å‚™ï¼Œé‡æ–°è¨ˆç®—å±¬æ€§
                if (isEquipped(item)) {
                    recalculateStats();
                }
                
                updateUI();
                openBagModal();
                saveGame();
                return false;
            }
        }

        // æª¢æŸ¥è£å‚™æ˜¯å¦å·²è£å‚™
        function isEquipped(item) {
            const equipment = gameState.player.equipment;
            return Object.values(equipment).some(equipped => equipped && equipped.id === item.id);
        }

        // ========== é‡é‘„ç³»çµ± ==========

        // é‡é„æ¶ˆè€—ç¢ç‰‡é…ç½®
        const REFORGE_COST = {
            'common': 10,
            'uncommon': 20,
            'fine': 40,
            'rare': 80,
            'epic': 150,
            'legendary': 300,
            'mythic': 500
        };

        // é‡é„è£å‚™
        function reforgeEquipment(itemId) {
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item || item.type === 'consumable') {
                addLog('é‡é„', 'ç„¡æ³•é‡é„æ­¤ç‰©å“ï¼');
                return false;
            }
            
            // è¨ˆç®—æ¶ˆè€—é‡‘å¹£ã€ç¢ç‰‡å’Œé‡é‘„çŸ³
            const shardCost = REFORGE_COST[item.rarity] || 10;
            const goldCost = shardCost * 10;
            
            // æ ¹æ“šå“è³ªæ±ºå®šé‡é‘„çŸ³æ¶ˆè€—
            let stoneRequired = 1;
            if (item.rarity === 'mythic' || item.rarity === 'eternal') {
                stoneRequired = 8;
            } else if (item.rarity === 'legendary') {
                stoneRequired = 5;
            } else if (item.rarity === 'epic') {
                stoneRequired = 3;
            } else if (item.rarity === 'rare') {
                stoneRequired = 2;
            }
            
            // æª¢æŸ¥é‡‘å¹£
            if (gameState.player.gold < goldCost) {
                addLog('é‡é‘„', `é‡‘å¹£ä¸è¶³ï¼éœ€è¦ ${goldCost} é‡‘å¹£`);
                return false;
            }
            
            // æª¢æŸ¥ç¢ç‰‡
            if (gameState.player.shards < shardCost) {
                addLog('é‡é‘„', `ç¢ç‰‡ä¸è¶³ï¼éœ€è¦ ${shardCost} ç¢ç‰‡`);
                return false;
            }
            
            // æª¢æŸ¥é‡é‘„çŸ³
            if (!gameState.materials) {
                gameState.materials = { enhanceStone: 0, reforgeStone: 0 };
            }
            if (gameState.materials.reforgeStone < stoneRequired) {
                addLog('é‡é‘„', `é‡é‘„çŸ³ä¸è¶³ï¼éœ€è¦ ${stoneRequired} å€‹é‡é‘„çŸ³`);
                return false;
            }
            
            // æ‰£é™¤è³‡æº
            gameState.player.gold -= goldCost;
            gameState.player.shards -= shardCost;
            gameState.materials.reforgeStone -= stoneRequired;
            
            // é‡æ–°ç”Ÿæˆå±¬æ€§ï¼ˆä½¿ç”¨èˆ‡æ‰è½ç›¸åŒçš„é‚è¼¯ï¼‰
            const rarity = RARITIES.find(r => r.name === item.rarity);
            if (!rarity) {
                addLog('é‡é„', 'é‡é„å¤±æ•—ï¼šæœªçŸ¥å“è³ª');
                return false;
            }
            
            // é‡æ–°éš¨æ©Ÿå±¬æ€§
            const region = REGIONS[gameState.region];
            const difficultyMult = region.difficulty;
            
            // åŸºç¤å±¬æ€§ç¯„åœï¼ˆéš¨æ©Ÿ + ç­‰ç´šæˆé•·ï¼‰
            let baseAtk = 0, baseDef = 0, baseHp = 0;
            const level = gameState.player.level;
            if (item.type === 'weapon') {
                baseAtk = (5 + level * 0.7) + Math.random() * 15;
            } else if (item.type === 'armor') {
                baseDef = (3 + level * 0.45) + Math.random() * 12;
                baseHp = (12 + level * 1.6) + Math.random() * 25;
            } else if (item.type === 'accessory') {
                baseAtk = (2 + level * 0.28) + Math.random() * 8;
                baseDef = (2 + level * 0.28) + Math.random() * 8;
                baseHp = (10 + level * 1.3) + Math.random() * 35;
            }
            
            // æ‡‰ç”¨å“è³ªå’Œé›£åº¦
            const finalMult = rarity.multiplier * difficultyMult;
            
            item.atk = Math.floor(baseAtk * finalMult);
            item.def = Math.floor(baseDef * finalMult);
            item.hp = Math.floor(baseHp * finalMult);
            
            // éš¨æ©Ÿé¡å¤–å±¬æ€§
            item.crit = Math.random() < 0.3 ? Math.random() * 5 : 0;
            item.critDmg = Math.random() < 0.3 ? Math.random() * 20 : 0;
            item.dmgRed = Math.random() < 0.2 ? Math.random() * 5 : 0;
            item.lifeSteal = Math.random() < 0.2 ? Math.random() * 3 : 0;
            item.armorPen = Math.random() < 0.2 ? Math.random() * 5 : 0;
            item.bossDmg = Math.random() < 0.2 ? Math.random() * 5 : 0;
            item.hpRegen = Math.random() < 0.15 ? Math.random() * 3 : 0;
            item.expBonus = Math.random() < 0.15 ? Math.random() * 20 : 0;
            
            addLog('é‡é‹', `ğŸ”„ é‡é‹å®Œæˆï¼${item.name} çš„å±¬æ€§å·²é‡æ–°éš¨æ©Ÿ`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦
            updateQuestProgress('reforge', 1);
            
            // å¦‚æœè£å‚™å·²è£å‚™ï¼Œé‡æ–°è¨ˆç®—å±¬æ€§
            if (isEquipped(item)) {
                recalculateStats();
            }
            
            updateUI();
            openBagModal();
            saveGame();
            return true;
        }

        // ========== å¯µç‰©ç³»çµ±å‡½æ•¸ ==========
        
        // åˆå§‹åŒ–å¯µç‰©ç³»çµ±
        function initPetSystem() {
            if (!gameState.pets) {
                gameState.pets = {
                    collection: [],
                    eggs: [],
                    equipped: null,
                    discovered: [],
                    shards: { dragon: 0, mecha: 0, void: 0 }
                };
            }
            // ç¢ºä¿ shardså­˜åœ¨
            if (!gameState.pets.shards) {
                gameState.pets.shards = { dragon: 0, mecha: 0, void: 0 };
            }
        }
        
        // å­µåŒ–å¯µç‰©è›‹
        function hatchPetEgg(eggIndex) {
            initPetSystem();
            if (!gameState.pets.eggs[eggIndex]) {
                addLog('å¯µç‰©', 'â“ å¯µç‰©è›‹ä¸å­˜åœ¨');
                return false;
            }
            
            const egg = gameState.pets.eggs[eggIndex];
            const family = egg.family;
            
            // æ ¹æ“šå®¶æ—ç²å–å¹¼å¹´æœŸå¯µç‰©
            const petIds = {
                'dragon': 'drake_hatchling',
                'mecha': 'scout_drone',
                'void': 'void_gazer'
            };
            
            const petId = petIds[family];
            if (!petId || !PETS[petId]) {
                addLog('å¯µç‰©', 'â“ å¯µç‰©ä¸å­˜åœ¨');
                return false;
            }
            
            const petData = PETS[petId];
            
            // ç”Ÿæˆå¯µç‰©å¯¦ä¾‹
            const petInstance = {
                instanceId: Date.now() + Math.random(), // å”¯ä¸€ID
                baseId: petId,
                name: petData.name,
                family: petData.family,
                stage: petData.stage,
                rarity: petData.rarity,
                icon: petData.icon,
                level: 1,
                exp: 0,
                expToNext: 100,
                stats: {
                    atk: petData.baseStats.atk,
                    def: petData.baseStats.def,
                    hp: petData.baseStats.hp,
                    maxHp: petData.baseStats.hp
                },
                skills: JSON.parse(JSON.stringify(petData.skills)), // æ·±æ‹·è²
                evolution: petData.evolution,
                awakening: petData.awakening
            };
            
            // æ·»åŠ åˆ°æ”¶è—
            gameState.pets.collection.push(petInstance);
            
            // ç§»é™¤å¯µç‰©è›‹
            gameState.pets.eggs.splice(eggIndex, 1);
            
            // è¨˜éŒ„åœ–é‘‘
            if (!gameState.codex.pets[petId]) {
                gameState.codex.pets[petId] = {
                    id: petId,
                    name: petData.name,
                    family: petData.family,
                    stage: petData.stage,
                    rarity: petData.rarity,
                    obtained: true,
                    firstObtainTime: Date.now()
                };
                gameState.codex.stats.totalPetsObtained++;
            }
            
            const rarityColor = getRarityColor(petData.rarity);
            addLog('å¯µç‰©', `ğŸ‰ å­µåŒ–æˆåŠŸï¼ç²å¾— <span style="color: ${rarityColor}">${petData.rarity}</span> å¯µç‰©ï¼š${petData.icon} ${petData.name}ï¼`, true);
            
            saveGame();
            return true;
        }
        
        // è£å‚™å¯µç‰©
        function equipPet(instanceId) {
            initPetSystem();
            const pet = gameState.pets.collection.find(p => p.instanceId === instanceId);
            if (!pet) {
                addLog('å¯µç‰©', 'â“ å¯µç‰©ä¸å­˜åœ¨');
                return false;
            }
            
            gameState.pets.equipped = instanceId;
            addLog('å¯µç‰©', `âœ… è£å‚™äº† ${pet.icon} ${pet.name}`);
            
            saveGame();
            updateUI();
            return true;
        }
        
        // å¸ä¸‹å¯µç‰©
        function unequipPet() {
            initPetSystem();
            if (!gameState.pets.equipped) {
                addLog('å¯µç‰©', 'â“ æ²’æœ‰è£å‚™å¯µç‰©');
                return false;
            }
            
            gameState.pets.equipped = null;
            addLog('å¯µç‰©', 'âœ… å·²å¸ä¸‹å¯µç‰©');
            
            saveGame();
            updateUI();
            return true;
        }
        
        // å¯µç‰©ç²å¾—ç¶“é©—
        function addPetExp(instanceId, expAmount) {
            initPetSystem();
            const pet = gameState.pets.collection.find(p => p.instanceId === instanceId);
            if (!pet) return false;
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šé¤µé¤Šå¯µç‰©ï¼ˆæ¯æ¬¡çµ¦ç¶“é©—è¦–ç‚ºä¸€æ¬¡é¤µé¤Šï¼‰
            updateQuestProgress('feed_pet', 1);
            
            pet.exp += expAmount;
            
            // æª¢æŸ¥å‡ç´š
            while (pet.exp >= pet.expToNext && pet.level < 100) {
                pet.exp -= pet.expToNext;
                pet.level++;
                
                // æ›´æ–°å±¬æ€§
                const petData = PETS[pet.baseId];
                if (petData) {
                    pet.stats.atk = petData.baseStats.atk + petData.growthRate.atk * (pet.level - 1);
                    pet.stats.def = petData.baseStats.def + petData.growthRate.def * (pet.level - 1);
                    pet.stats.hp = petData.baseStats.hp + petData.growthRate.hp * (pet.level - 1);
                    pet.stats.maxHp = pet.stats.hp;
                }
                
                // è¨ˆç®—ä¸‹ä¸€ç´šç¶“é©—
                pet.expToNext = Math.floor(100 * Math.pow(1.15, pet.level - 1));
                
                addLog('å¯µç‰©', `â­ ${pet.icon} ${pet.name} å‡ç´šè‡³ Lv.${pet.level}ï¼`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå¯µç‰©å‡ç´š
                updateQuestProgress('level_up_pet', 1);
            }
            
            saveGame();
            return true;
        }
        
        // é€²åŒ–å¯µç‰©
        function evolvePet(instanceId) {
            initPetSystem();
            const pet = gameState.pets.collection.find(p => p.instanceId === instanceId);
            if (!pet) {
                addLog('å¯µç‰©', 'â“ å¯µç‰©ä¸å­˜åœ¨');
                return false;
            }
            
            if (!pet.evolution) {
                addLog('å¯µç‰©', 'â“ æ­¤å¯µç‰©ç„¡æ³•é€²åŒ–');
                return false;
            }
            
            // æª¢æŸ¥ç­‰ç´š
            if (pet.level < pet.evolution.requiredLevel) {
                addLog('å¯µç‰©', `â“ éœ€è¦ Lv.${pet.evolution.requiredLevel} æ‰èƒ½é€²åŒ–ï¼ˆç•¶å‰ Lv.${pet.level}ï¼‰`);
                return false;
            }
            
            // æª¢æŸ¥ææ–™
            const materials = pet.evolution.materials;
            if (materials.evolutionStone > gameState.materials.evolutionStone) {
                addLog('å¯µç‰©', `â“ é€²åŒ–çŸ³ä¸è¶³ï¼ˆéœ€è¦ ${materials.evolutionStone}ï¼Œæ“æœ‰ ${gameState.materials.evolutionStone}ï¼‰`);
                return false;
            }
            
            const familyShards = gameState.pets.shards[pet.family] || 0;
            if (materials.petShards > familyShards) {
                addLog('å¯µç‰©', `â“ å¯µç‰©ç¢ç‰‡ä¸è¶³ï¼ˆéœ€è¦ ${materials.petShards}ï¼Œæ“æœ‰ ${familyShards}ï¼‰`);
                return false;
            }
            
            // æ‰£é™¤ææ–™
            gameState.materials.evolutionStone -= materials.evolutionStone;
            gameState.pets.shards[pet.family] -= materials.petShards;
            
            // ç²å–ä¸‹ä¸€éšæ®µæ•¸æ“š
            const nextPetData = PETS[pet.evolution.nextStage];
            if (!nextPetData) {
                addLog('å¯µç‰©', 'â“ é€²åŒ–å¤±æ•—ï¼šä¸‹ä¸€éšæ®µä¸å­˜åœ¨');
                return false;
            }
            
            // ä¿ç•™ç­‰ç´šå’Œç¶“é©—
            const oldLevel = pet.level;
            const oldExp = pet.exp;
            const oldName = pet.name;
            
            // æ›´æ–°å¯µç‰©æ•¸æ“š
            pet.baseId = nextPetData.id;
            pet.name = nextPetData.name;
            pet.stage = nextPetData.stage;
            pet.rarity = nextPetData.rarity;
            pet.icon = nextPetData.icon;
            pet.skills = JSON.parse(JSON.stringify(nextPetData.skills));
            pet.evolution = nextPetData.evolution;
            pet.awakening = nextPetData.awakening;
            
            // é‡æ–°è¨ˆç®—å±¬æ€§ï¼ˆä½¿ç”¨æ–°çš„åŸºç¤å€¼å’Œæˆé•·ç‡ï¼‰
            pet.stats.atk = nextPetData.baseStats.atk + nextPetData.growthRate.atk * (oldLevel - 1);
            pet.stats.def = nextPetData.baseStats.def + nextPetData.growthRate.def * (oldLevel - 1);
            pet.stats.hp = nextPetData.baseStats.hp + nextPetData.growthRate.hp * (oldLevel - 1);
            pet.stats.maxHp = pet.stats.hp;
            
            // è¨˜éŒ„åœ–é‘‘
            if (!gameState.codex.pets[nextPetData.id]) {
                gameState.codex.pets[nextPetData.id] = {
                    id: nextPetData.id,
                    name: nextPetData.name,
                    family: nextPetData.family,
                    stage: nextPetData.stage,
                    rarity: nextPetData.rarity,
                    obtained: true,
                    firstObtainTime: Date.now()
                };
                gameState.codex.stats.totalPetsObtained++;
            }
            
            const rarityColor = getRarityColor(nextPetData.rarity);
            addLog('å¯µç‰©', `âœ¨ ${oldName} é€²åŒ–æˆ <span style="color: ${rarityColor}">${nextPetData.rarity}</span> ${pet.icon} ${pet.name}ï¼`, true);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå¯µç‰©é€²åŒ–
            updateQuestProgress('evolve_pet', 1);
            
            saveGame();
            return true;
        }
        
        // è¦ºé†’å¯µç‰©
        function awakenPet(instanceId) {
            initPetSystem();
            const pet = gameState.pets.collection.find(p => p.instanceId === instanceId);
            if (!pet) {
                addLog('å¯µç‰©', 'â“ å¯µç‰©ä¸å­˜åœ¨');
                return false;
            }
            
            if (!pet.awakening) {
                addLog('å¯µç‰©', 'â“ æ­¤å¯µç‰©ç„¡æ³•è¦ºé†’');
                return false;
            }
            
            // æª¢æŸ¥ç­‰ç´š
            if (pet.level < pet.awakening.requiredLevel) {
                addLog('å¯µç‰©', `â“ éœ€è¦ Lv.${pet.awakening.requiredLevel} æ‰èƒ½è¦ºé†’ï¼ˆç•¶å‰ Lv.${pet.level}ï¼‰`);
                return false;
            }
            
            // æª¢æŸ¥ææ–™
            const materials = pet.awakening.materials;
            if (materials.eternalSource > gameState.materials.eternalSource) {
                addLog('å¯µç‰©', `â“ æ°¸æ†ä¹‹æºä¸è¶³ï¼ˆéœ€è¦ ${materials.eternalSource}ï¼Œæ“æœ‰ ${gameState.materials.eternalSource}ï¼‰`);
                return false;
            }
            
            const familyShards = gameState.pets.shards[pet.family] || 0;
            if (materials.petShards > familyShards) {
                addLog('å¯µç‰©', `â“ å¯µç‰©ç¢ç‰‡ä¸è¶³ï¼ˆéœ€è¦ ${materials.petShards}ï¼Œæ“æœ‰ ${familyShards}ï¼‰`);
                return false;
            }
            
            // æ‰£é™¤ææ–™
            gameState.materials.eternalSource -= materials.eternalSource;
            gameState.pets.shards[pet.family] -= materials.petShards;
            
            // ç²å–è¦ºé†’å½¢æ…‹æ•¸æ“š
            const awakenedPetData = PETS[pet.awakening.nextStage];
            if (!awakenedPetData) {
                addLog('å¯µç‰©', 'â“ è¦ºé†’å¤±æ•—ï¼šè¦ºé†’å½¢æ…‹ä¸å­˜åœ¨');
                return false;
            }
            
            // ä¿ç•™ç­‰ç´šå’Œç¶“é©—
            const oldLevel = pet.level;
            const oldExp = pet.exp;
            const oldName = pet.name;
            
            // æ›´æ–°å¯µç‰©æ•¸æ“š
            pet.baseId = awakenedPetData.id;
            pet.name = awakenedPetData.name;
            pet.stage = awakenedPetData.stage;
            pet.rarity = awakenedPetData.rarity;
            pet.icon = awakenedPetData.icon;
            pet.skills = JSON.parse(JSON.stringify(awakenedPetData.skills));
            pet.evolution = null; // è¦ºé†’å¾Œç„¡æ³•å†é€²åŒ–
            pet.awakening = null;
            
            // é‡æ–°è¨ˆç®—å±¬æ€§
            pet.stats.atk = awakenedPetData.baseStats.atk + awakenedPetData.growthRate.atk * (oldLevel - 1);
            pet.stats.def = awakenedPetData.baseStats.def + awakenedPetData.growthRate.def * (oldLevel - 1);
            pet.stats.hp = awakenedPetData.baseStats.hp + awakenedPetData.growthRate.hp * (oldLevel - 1);
            pet.stats.maxHp = pet.stats.hp;
            
            // è¨˜éŒ„åœ–é‘‘
            if (!gameState.codex.pets[awakenedPetData.id]) {
                gameState.codex.pets[awakenedPetData.id] = {
                    id: awakenedPetData.id,
                    name: awakenedPetData.name,
                    family: awakenedPetData.family,
                    stage: awakenedPetData.stage,
                    rarity: awakenedPetData.rarity,
                    obtained: true,
                    firstObtainTime: Date.now()
                };
                gameState.codex.stats.totalPetsObtained++;
            }
            
            const rarityColor = getRarityColor('eternal');
            addLog('å¯µç‰©', `ğŸŒŸ ${oldName} è¦ºé†’æˆ <span style="color: ${rarityColor}">Eternal</span> ${pet.icon} ${pet.name}ï¼`, true);
            
            saveGame();
            return true;
        }
        
        // ç²å–è£å‚™çš„å¯µç‰©
        function getEquippedPet() {
            initPetSystem();
            if (!gameState.pets.equipped) return null;
            return gameState.pets.collection.find(p => p.instanceId === gameState.pets.equipped);
        }
        
        // å¯µç‰©è¡Œå‹•å‡½æ•¸ï¼ˆç”¨æ–¼æ¸¬è©¦ï¼‰
        function petAction() {
            const equippedPet = getEquippedPet();
            if (!equippedPet) return;
            if (!gameState.combat || !gameState.combat.active) return;
            if (!gameState.combat.enemy || gameState.combat.enemy.hp <= 0) return;
            
            const enemy = gameState.combat.enemy;
            
            // éš¨æ©Ÿé¸æ“‡ä¸€å€‹æŠ€èƒ½
            if (equippedPet.skills && equippedPet.skills.length > 0) {
                const skill = equippedPet.skills[Math.floor(Math.random() * equippedPet.skills.length)];
                
                // åˆ¤å®šè§¸ç™¼æ©Ÿç‡
                if (Math.random() < skill.chance) {
                    // æŠ€èƒ½è§¸ç™¼ï¼
                    let skillMessage = `${equippedPet.icon} ${equippedPet.name} ä½¿ç”¨äº† ${skill.name}ï¼`;
                    
                    if (skill.type === 'damage') {
                        const petDamage = Math.floor(equippedPet.stats.atk * skill.multiplier);
                        enemy.hp -= petDamage;
                        skillMessage += ` é€ æˆ ${petDamage} é»å‚·å®³ï¼`;
                    } else if (skill.type === 'heal') {
                        const healAmount = Math.floor(gameState.player.maxHp * skill.value);
                        const actualHeal = Math.min(healAmount, gameState.player.maxHp - gameState.player.hp);
                        gameState.player.hp += actualHeal;
                        skillMessage += ` å›å¾© ${actualHeal} é»ç”Ÿå‘½å€¼ï¼`;
                    } else if (skill.type === 'buff') {
                        if (skill.stat === 'atk') {
                            const buffValue = Math.floor(gameState.player.atk * skill.value);
                            gameState.player.atk += buffValue;
                            skillMessage += ` æå‡æ”»æ“ŠåŠ›ï¼`;
                        } else if (skill.stat === 'def') {
                            const buffValue = Math.floor(gameState.player.def * skill.value);
                            gameState.player.def += buffValue;
                            skillMessage += ` æå‡é˜²ç¦¦åŠ›ï¼`;
                        }
                    } else if (skill.type === 'aoe') {
                        const aoeDamage = Math.floor(equippedPet.stats.atk * skill.multiplier);
                        enemy.hp -= aoeDamage;
                        skillMessage += ` ç¾¤é«”æ”»æ“Šé€ æˆ ${aoeDamage} é»å‚·å®³ï¼`;
                    } else if (skill.type === 'true_damage') {
                        const trueDamage = Math.floor(enemy.maxHp * skill.value);
                        enemy.hp -= trueDamage;
                        skillMessage += ` é€ æˆ ${trueDamage} é»çœŸå¯¦å‚·å®³ï¼`;
                    } else if (skill.type === 'devour') {
                        const devourDamage = Math.floor(enemy.maxHp * skill.value);
                        enemy.hp -= devourDamage;
                        const healAmount = Math.floor(devourDamage * 0.5);
                        gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                        skillMessage += ` åå™¬é€ æˆ ${devourDamage} é»å‚·å®³ä¸¦å›å¾© ${healAmount} é»ç”Ÿå‘½ï¼`;
                    }
                    
                    addLog('å¯µç‰©', skillMessage);
                    addPetExp(equippedPet.instanceId, 5);
                } else {
                    // æŠ€èƒ½æœªè§¸ç™¼ï¼Œæ™®é€šæ”»æ“Š
                    const petAttack = Math.floor(equippedPet.stats.atk * 0.5);
                    enemy.hp -= petAttack;
                    addLog('å¯µç‰©', `${equippedPet.icon} ${equippedPet.name} é€²è¡Œæ™®é€šæ”»æ“Šï¼Œé€ æˆ ${petAttack} é»å‚·å®³`);
                    addPetExp(equippedPet.instanceId, 2);
                }
            }
        }
        
        // ========== å¯µç‰© UI å‡½æ•¸ ==========
        
        // æ‰“é–‹å¯µç‰©é¢æ¿
        function openPetModal() {
            updatePetModal();
            document.getElementById('pet-modal').classList.add('active');
        }
        
        // é—œé–‰å¯µç‰©é¢æ¿
        function closePetModal() {
            document.getElementById('pet-modal').classList.remove('active');
        }
        
        // åˆ‡æ›å¯µç‰©é é¢
        function switchPetTab(tab) {
            // éš±è—æ‰€æœ‰é é¢
            document.getElementById('pet-eggs-content').style.display = 'none';
            document.getElementById('pet-collection-content').style.display = 'none';
            document.getElementById('pet-materials-content').style.display = 'none';
            
            // é‡ç½®æ‰€æœ‰æŒ‰éˆ•æ¨£å¼
            document.getElementById('pet-tab-eggs').style.background = 'rgba(255, 255, 255, 0.1)';
            document.getElementById('pet-tab-eggs').style.color = '#7a8fb8';
            document.getElementById('pet-tab-collection').style.background = 'rgba(255, 255, 255, 0.1)';
            document.getElementById('pet-tab-collection').style.color = '#7a8fb8';
            document.getElementById('pet-tab-materials').style.background = 'rgba(255, 255, 255, 0.1)';
            document.getElementById('pet-tab-materials').style.color = '#7a8fb8';
            
            // é¡¯ç¤ºé¸ä¸­çš„é é¢
            if (tab === 'eggs') {
                document.getElementById('pet-eggs-content').style.display = 'block';
                document.getElementById('pet-tab-eggs').style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                document.getElementById('pet-tab-eggs').style.color = 'white';
            } else if (tab === 'collection') {
                document.getElementById('pet-collection-content').style.display = 'block';
                document.getElementById('pet-tab-collection').style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                document.getElementById('pet-tab-collection').style.color = 'white';
            } else if (tab === 'materials') {
                document.getElementById('pet-materials-content').style.display = 'block';
                document.getElementById('pet-tab-materials').style.background = 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)';
                document.getElementById('pet-tab-materials').style.color = 'white';
            }
        }
        
        // æ›´æ–°å¯µç‰©é¢æ¿
        function updatePetModal() {
            updateEquippedPetDisplay();
            updatePetEggsList();
            updatePetCollectionList();
            updatePetMaterials();
        }
        
        // æ›´æ–°ç•¶å‰è£å‚™çš„å¯µç‰©é¡¯ç¤º
        function updateEquippedPetDisplay() {
            const equippedPet = getEquippedPet();
            const equippedPetInfo = document.getElementById('equipped-pet-info');
            
            if (!equippedPet) {
                equippedPetInfo.innerHTML = 'ç„¡';
                return;
            }
            
            const rarityColor = getRarityColor(equippedPet.rarity);
            const skillsHtml = equippedPet.skills.map(skill => {
                const chancePercent = Math.round(skill.chance * 100);
                return `<div style="font-size: 0.75rem; color: #7a8fb8; margin-top: 3px;">â€¢ ${skill.name} (${chancePercent}%)</div>`;
            }).join('');
            
            equippedPetInfo.innerHTML = `
                <div style="display: flex; gap: 15px; align-items: center;">
                    <div style="font-size: 3rem;">${equippedPet.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-size: 1.2rem; font-weight: bold; color: ${rarityColor}; margin-bottom: 5px;">${equippedPet.name}</div>
                        <div style="color: #7a8fb8; font-size: 0.9rem;">Lv.${equippedPet.level} | <span style="color: ${rarityColor};">${getRarityLabel(equippedPet.rarity)}</span></div>
                        <div style="margin-top: 8px;">
                            <div style="font-size: 0.85rem; color: #00ff88;">âš”ï¸ ${equippedPet.stats.atk} | ğŸ›¡ï¸ ${equippedPet.stats.def} | â¤ï¸ ${equippedPet.stats.hp}/${equippedPet.stats.maxHp}</div>
                        </div>
                        ${skillsHtml}
                    </div>
                    <button onclick="unequipPet()" style="padding: 8px 15px; background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);">å¸ä¸‹</button>
                </div>
            `;
        }
        
        // æ›´æ–°å¯µç‰©è›‹åˆ—è¡¨
        function updatePetEggsList() {
            const eggsList = document.getElementById('pet-eggs-list');
            
            if (!gameState.pets.eggs || gameState.pets.eggs.length === 0) {
                eggsList.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #7a8fb8; padding: 30px;">ä½ é‚„æ²’æœ‰å¯µç‰©è›‹ï¼Œå»ç¬¬3æˆ–ç¬¬4å€åŸŸæ‰“æ€ªå§ï¼</div>';
                return;
            }
            
            eggsList.innerHTML = gameState.pets.eggs.map((egg, index) => {
                const familyNames = {
                    'dragon': 'ğŸ‰ é¾æ—',
                    'mecha': 'ğŸ¤– æ©Ÿæ¢°æ—',
                    'void': 'ğŸ‘ï¸ è™›ç©ºæ—'
                };
                const familyName = familyNames[egg.family] || 'æœªçŸ¥';
                const obtainedDate = new Date(egg.obtainedAt).toLocaleString('zh-TW');
                
                return `
                    <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 8px; border: 2px solid rgba(255, 215, 0, 0.3);">
                        <div style="text-align: center; font-size: 3rem; margin-bottom: 10px;">ğŸ¥š</div>
                        <div style="font-size: 1.1rem; font-weight: bold; color: #ffd700; text-align: center; margin-bottom: 8px;">${familyName}å¯µç‰©è›‹</div>
                        <div style="color: #7a8fb8; font-size: 0.85rem; text-align: center; margin-bottom: 10px;">ç²å¾—æ™‚é–“ï¼š${obtainedDate}</div>
                        <button onclick="hatchPetEgg(${index})" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);">ğŸ£ å­µåŒ–</button>
                    </div>
                `;
            }).join('');
        }
        
        // æ›´æ–°å¯µç‰©æ”¶è—åˆ—è¡¨
        function updatePetCollectionList() {
            const collectionList = document.getElementById('pet-collection-list');
            
            if (!gameState.pets.collection || gameState.pets.collection.length === 0) {
                collectionList.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #7a8fb8; padding: 30px;">ä½ é‚„æ²’æœ‰å¯µç‰©ï¼Œå­µåŒ–å¯µç‰©è›‹ç²å¾—å§ï¼</div>';
                return;
            }
            
            collectionList.innerHTML = gameState.pets.collection.map(pet => {
                const rarityColor = getRarityColor(pet.rarity);
                const isEquipped = gameState.pets.equipped === pet.instanceId;
                const expPercent = pet.expToNext > 0 ? (pet.exp / pet.expToNext * 100).toFixed(1) : 100;
                
                // æŠ€èƒ½åˆ—è¡¨
                const skillsHtml = pet.skills.map(skill => {
                    const chancePercent = Math.round(skill.chance * 100);
                    return `<div style="font-size: 0.75rem; color: #7a8fb8; margin-top: 3px;">â€¢ ${skill.name} (${chancePercent}%): ${skill.description}</div>`;
                }).join('');
                
                // é€²åŒ–æŒ‰éˆ•
                let evolutionButton = '';
                if (pet.evolution) {
                    const canEvolve = pet.level >= pet.evolution.requiredLevel;
                    const materials = pet.evolution.materials;
                    const hasStone = gameState.materials.evolutionStone >= materials.evolutionStone;
                    const hasShards = (gameState.pets.shards[pet.family] || 0) >= materials.petShards;
                    const canAfford = hasStone && hasShards;
                    
                    if (canEvolve && canAfford) {
                        evolutionButton = `<button onclick="evolvePet('${pet.instanceId}')" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #8a2be2 0%, #da70d6 100%);">ğŸ”„ é€²åŒ–</button>`;
                    } else {
                        const reason = !canEvolve ? `Lv.${pet.evolution.requiredLevel}` : 'ææ–™ä¸è¶³';
                        evolutionButton = `<button disabled style="flex: 1; padding: 8px; opacity: 0.5;">ğŸ”„ é€²åŒ– (${reason})</button>`;
                    }
                }
                
                // è¦ºé†’æŒ‰éˆ•
                let awakeningButton = '';
                if (pet.awakening) {
                    const canAwaken = pet.level >= pet.awakening.requiredLevel;
                    const materials = pet.awakening.materials;
                    const hasSource = gameState.materials.eternalSource >= materials.eternalSource;
                    const hasShards = (gameState.pets.shards[pet.family] || 0) >= materials.petShards;
                    const canAfford = hasSource && hasShards;
                    
                    if (canEvolve && canAfford) {
                        awakeningButton = `<button onclick="awakenPet('${pet.instanceId}')" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #e040fb 0%, #ffd700 100%);">â­ è¦ºé†’</button>`;
                    } else {
                        const reason = !canAwaken ? `Lv.${pet.awakening.requiredLevel}` : 'ææ–™ä¸è¶³';
                        awakeningButton = `<button disabled style="flex: 1; padding: 8px; opacity: 0.5;">â­ è¦ºé†’ (${reason})</button>`;
                    }
                }
                
                return `
                    <div style="background: rgba(250, 112, 154, 0.1); padding: 15px; border-radius: 8px; border: 2px solid ${isEquipped ? rarityColor : 'rgba(250, 112, 154, 0.3)'}; ${isEquipped ? 'box-shadow: 0 0 15px ' + rarityColor + ';' : ''}">
                        <div style="display: flex; gap: 15px; margin-bottom: 10px;">
                            <div style="font-size: 3rem;">${pet.icon}</div>
                            <div style="flex: 1;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: ${rarityColor}; margin-bottom: 3px;">${pet.name} ${isEquipped ? 'âœ…' : ''}</div>
                                <div style="color: #7a8fb8; font-size: 0.85rem;">Lv.${pet.level} | <span style="color: ${rarityColor};">${getRarityLabel(pet.rarity)}</span></div>
                                <div style="margin-top: 5px;">
                                    <div style="font-size: 0.8rem; color: #00ff88;">âš”ï¸ ${pet.stats.atk} | ğŸ›¡ï¸ ${pet.stats.def} | â¤ï¸ ${pet.stats.hp}/${pet.stats.maxHp}</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ç¶“é©—æ¢ -->
                        <div style="margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.75rem; color: #7a8fb8; margin-bottom: 3px;">
                                <span>EXP</span>
                                <span>${pet.exp}/${pet.expToNext} (${expPercent}%)</span>
                            </div>
                            <div style="background: rgba(0, 0, 0, 0.3); height: 8px; border-radius: 4px; overflow: hidden;">
                                <div style="background: linear-gradient(90deg, #00ff88 0%, #00d9ff 100%); height: 100%; width: ${expPercent}%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                        
                        <!-- æŠ€èƒ½åˆ—è¡¨ -->
                        <div style="background: rgba(0, 0, 0, 0.2); padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                            <div style="font-size: 0.85rem; font-weight: bold; color: #00d9ff; margin-bottom: 5px;">ğŸ¯ æŠ€èƒ½</div>
                            ${skillsHtml}
                        </div>
                        
                        <!-- æŒ‰éˆ•å€ -->
                        <div style="display: flex; gap: 8px;">
                            ${isEquipped ? 
                                '<button onclick="unequipPet()" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #f5576c 0%, #f093fb 100%);">ğŸ“¤ å¸ä¸‹</button>' :
                                `<button onclick="equipPet('${pet.instanceId}')" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">âœ… è£å‚™</button>`
                            }
                            ${evolutionButton}
                            ${awakeningButton}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // æ›´æ–°å¯µç‰©ææ–™é¡¯ç¤º
        function updatePetMaterials() {
            initPetSystem();
            document.getElementById('evolution-stone-count').textContent = gameState.materials.evolutionStone || 0;
            document.getElementById('eternal-source-count').textContent = gameState.materials.eternalSource || 0;
            document.getElementById('dragon-shards-count').textContent = gameState.pets.shards['dragon'] || 0;
            document.getElementById('mecha-shards-count').textContent = gameState.pets.shards['mecha'] || 0;
            document.getElementById('void-shards-count').textContent = gameState.pets.shards['void'] || 0;
        }

        function openRegionModal() {
            const modal = document.getElementById('region-modal');
            const list = document.getElementById('region-list');
            
            list.innerHTML = REGIONS.map((region, index) => {
                const locked = gameState.player.level < region.level;
                return `
                    <button 
                        style="width: 100%; margin-bottom: 10px; padding: 15px; text-align: left; ${locked ? 'opacity: 0.5;' : ''}"
                        ${locked ? 'disabled' : ''}
                        onclick="changeRegion(${index})"
                    >
                        <strong>${region.name}</strong> (Lv.${region.level}+)<br>
                        <small>é›£åº¦Ã—${region.difficulty} çå‹µÃ—${region.reward}</small>
                    </button>
                `;
            }).join('');
            
            modal.classList.add('active');
        }

        function closeRegionModal() {
            document.getElementById('region-modal').classList.remove('active');
        }

        function changeRegion(index) {
            gameState.region = index;
            gameState.battleProgress = 0;
            addLog('ç³»çµ±', `å·²åˆ‡æ›åˆ° ${REGIONS[index].name}`);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šåˆ‡æ›å€åŸŸ
            updateQuestProgress('switch_region', 1);
            
            updateUI();
            closeRegionModal();
            
            // åˆ‡æ›å€åŸŸå¾Œç«‹å³å­˜æª”
            saveGame();
        }

        let currentGeneralShopTab = 'recovery';
        
        function openShopModal() {
            const modal = document.getElementById('shop-modal');
            switchGeneralShopTab('recovery');
            modal.classList.add('active');
        }
        
        function switchGeneralShopTab(tab) {
            currentGeneralShopTab = tab;
            const items = document.getElementById('shop-items');
            
            // åˆ†é¡æ¨™ç±¤
            const tabs = `
                <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="switchGeneralShopTab('recovery')" style="flex: 1; min-width: 80px; background: ${tab === 'recovery' ? '#00d9ff' : 'rgba(0, 217, 255, 0.1)'}; color: ${tab === 'recovery' ? '#0a1628' : '#00d9ff'};">ğŸ“¦ å›å¾©</button>
                    <button onclick="switchGeneralShopTab('battle')" style="flex: 1; min-width: 80px; background: ${tab === 'battle' ? '#00d9ff' : 'rgba(0, 217, 255, 0.1)'}; color: ${tab === 'battle' ? '#0a1628' : '#00d9ff'};">ğŸ² æˆ°é¬¥</button>
                    <button onclick="switchGeneralShopTab('other')" style="flex: 1; min-width: 80px; background: ${tab === 'other' ? '#00d9ff' : 'rgba(0, 217, 255, 0.1)'}; color: ${tab === 'other' ? '#0a1628' : '#00d9ff'};">ğŸ“š å…¶ä»–</button>
                </div>
            `;
            
            let content = '';
            if (tab === 'recovery') {
                content = renderGeneralRecoveryShop();
            } else if (tab === 'battle') {
                content = renderGeneralBattleShop();
            } else if (tab === 'other') {
                content = renderGeneralOtherShop();
            }
            
            items.innerHTML = tabs + content;
        }
        
        function renderGeneralRecoveryShop() {
            const items = [
                // HPç™¾åˆ†æ¯”å›å¾©è—¥æ°´
                { name: 'å°å‹ç”Ÿå‘½è—¥æ°´', desc: '[ç«‹å³] å›å¤25%æœ€å¤§HP', price: 25, type: 'hp_percent', value: 0.25, icon: 'ğŸ§ª' },
                { name: 'ä¸­å‹ç”Ÿå‘½è—¥æ°´', desc: '[ç«‹å³] å›å¤40%æœ€å¤§HP', price: 45, type: 'hp_percent', value: 0.40, icon: 'ğŸ§ª' },
                { name: 'å¤§å‹ç”Ÿå‘½è—¥æ°´', desc: '[ç«‹å³] å›å¤60%æœ€å¤§HP', price: 75, type: 'hp_percent', value: 0.60, icon: 'ğŸ§ª' },
                { name: 'å®Œå…¨æ¢å¾©è—¥æ°´', desc: '[ç«‹å³] å›å¤100%æœ€å¤§HP', price: 150, type: 'hp_percent', value: 1.00, icon: 'âœ¨' },
                // APå›ºå®šå›å¾©è—¥æ°´
                { name: 'å°å‹èƒ½é‡è—¥æ°´', desc: '[ç«‹å³] æ¢å¾©5 AP', price: 30, type: 'ap_fixed', value: 5, icon: 'âš¡' },
                { name: 'ä¸­å‹èƒ½é‡è—¥æ°´', desc: '[ç«‹å³] æ¢å¾©10 AP', price: 55, type: 'ap_fixed', value: 10, icon: 'âš¡' },
                { name: 'å¤§å‹èƒ½é‡è—¥æ°´', desc: '[ç«‹å³] æ¢å¾©20 AP', price: 100, type: 'ap_fixed', value: 20, icon: 'âš¡' },
                // çµ„åˆè—¥æ°´
                { name: 'æˆ°é¬¥è£œçµ¦åŒ…', desc: '[ç«‹å³] å›å¤50%æœ€å¤§HP + 10 AP', price: 110, type: 'both_percent', hpPercent: 0.50, ap: 10, icon: 'ğŸ' },
                { name: 'å®Œå…¨è£œçµ¦åŒ…', desc: '[ç«‹å³] å›å¤100%æœ€å¤§HP + 20 AP', price: 220, type: 'both_percent', hpPercent: 1.00, ap: 20, icon: 'ğŸ' },
                // æŒçºŒå›å¾©è—¥æ°´
                { name: 'å†ç”Ÿè—¥åŠ‘', desc: '[æŒçºŒ5æˆ°] æ¯å›åˆå›å¾©5%æœ€å¤§HP', price: 80, type: 'hp_regen', value: 0.05, duration: 5, icon: 'ğŸ’š' },
                { name: 'æ´»åŠ›è—¥åŠ‘', desc: '[æŒçºŒ3æˆ°] æ¯å›åˆå›å¾©10%æœ€å¤§HP + 2 AP', price: 120, type: 'both_regen', hpValue: 0.10, apValue: 2, duration: 3, icon: 'ğŸ’š' }
            ];
            
            return items.map(item => `
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: bold; color: #4CAF50;">${item.icon || 'ğŸ§ª'} ${item.name}</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">${item.desc}</div>
                    </div>
                    <button onclick='buyGeneralItem(${JSON.stringify(item)})' style="padding: 8px 16px;">ğŸ’° ${item.price}</button>
                </div>
            `).join('');
        }
        
        function renderGeneralBattleShop() {
            const items = [
                { name: 'ç…™éœ§å½ˆ', desc: '[æŒçºŒ1æˆ°] æ•µäººæ”»æ“ŠåŠ›-25%', price: 45, type: 'smoke_bomb', value: 0.25, duration: 1, icon: 'ğŸ’¨' },
                { name: 'å¼·åŒ–è—¥æ°´', desc: '[æŒçºŒ3æˆ°] æ”»æ“Š+15%ã€é˜²ç¦¦+15%', price: 65, type: 'power_potion', duration: 3, icon: 'ğŸ’ª' },
                { name: 'åµæŸ¥å·è»¸', desc: '[ä½¿ç”¨3æ¬¡] é¡¯ç¤ºæ•µäººè©³ç´°è³‡è¨Š(HP/ATK/DEF/æ‰è½ç‡)', price: 50, type: 'scout_scroll', value: 3, icon: 'ğŸ”' },
                { name: 'ç¶“é©—è—¥æ°´', desc: '[æŒçºŒ3æˆ°] ç¶“é©—ç²å¾—+40%', price: 55, type: 'exp_potion', value: 0.4, duration: 3, icon: 'ğŸ“š' },
                { name: 'å¹¸é‹è—¥æ°´', desc: '[æŒçºŒ3æˆ°] æ‰è½ç‡+35%', price: 60, type: 'luck_potion', value: 0.35, duration: 3, icon: 'ğŸ€' },
                { name: 'ç‹‚æˆ°è—¥åŠ‘', desc: '[æŒçºŒ5æˆ°] æ”»æ“Š+25%ã€é˜²ç¦¦-10%', price: 70, type: 'berserk_potion', duration: 5, icon: 'ğŸ”¥' }
            ];
            
            return items.map(item => `
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: bold; color: #FF9800;">${item.icon || 'ğŸ²'} ${item.name}</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">${item.desc}</div>
                    </div>
                    <button onclick='buyGeneralItem(${JSON.stringify(item)})' style="padding: 8px 16px;">ğŸ’° ${item.price}</button>
                </div>
            `).join('');
        }
        
        function renderGeneralOtherShop() {
            const items = [
                { name: 'èƒŒåŒ…æ“´å……åˆ¸', desc: '[æ°¸ä¹…] æ°¸ä¹…å¢åŠ èƒŒåŒ… +5 æ ¼(æœ€å¤š10æ¬¡)', price: 120, type: 'bag_expand', value: 5, maxPurchase: 10, icon: 'ğŸ’' },
                { name: 'é«”åŠ›è—¥æ°´', desc: '[ç«‹å³] ç«‹å³å›å¾© 10 é»é«”åŠ›', price: 80, type: 'ap_potion', value: 10, icon: 'âš¡' },
                { name: 'é‡ç½®çŸ³', desc: '[æ¯æ—¥1æ¬¡] é‡ç½®æ‰€æœ‰æ¯æ—¥ä»»å‹™', price: 150, type: 'reset_daily', maxPurchase: 1, resetDaily: true, icon: 'ğŸ”„' },
                { name: 'ç”Ÿå‘½çµæ™¶', desc: '[æ°¸ä¹…] æ°¸ä¹…å¢åŠ æœ€å¤§HP +50', price: 100, type: 'hp_crystal', value: 50, icon: 'ğŸ’–' },
                { name: 'è­·èº«ç¬¦', desc: '[ä¸€æ¬¡æ€§] å—åˆ°è‡´å‘½å‚·æ™‚ä¿ç•™1HP', price: 110, type: 'guardian_charm', value: 1, icon: 'ğŸ›¡ï¸' },
                { name: 'ç¥ç¦è—¥æ°´', desc: '[æŒçºŒ5æˆ°] æ‰€æœ‰å±¬æ€§+8%', price: 85, type: 'blessing_potion', duration: 5, icon: 'âœ¨' }
            ];
            
            return items.map(item => `
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="font-weight: bold; color: #2196F3;">ğŸ“š ${item.name}</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">${item.desc}</div>
                    </div>
                    <button onclick='buyGeneralItem(${JSON.stringify(item)})' style="padding: 8px 16px;">ğŸ’° ${item.price}</button>
                </div>
            `).join('');
        }
        
        function renderCompanionShop() {
            initCompanionSystem();
            // å•†åº—åªè³£ Common å“è³ªéš¨å¾
            const companionList = Object.values(COMPANIONS).filter(c => c.rarity === 'common');
            
            return companionList.map(companion => {
                const owned = gameState.companions.owned.find(c => c.id === companion.id);
                const isOwned = !!owned;
                const rarityColor = getRarityColor(companion.rarity);
                const typeIcon = { heal: 'ğŸ’š', buff: 'â¬†ï¸', debuff: 'â¬‡ï¸', resource: 'ğŸ’°' }[companion.type] || 'â“';
                
                let skillsHtml = companion.skills.map(skill => 
                    `<div style="color: #7a8fb8; font-size: 0.75rem; margin: 2px 0;">â€¢ ${skill.description}</div>`
                ).join('');
                
                return `
                    <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: ${rarityColor}; margin-bottom: 3px;">${typeIcon} ${companion.name}</div>
                                <div style="font-size: 0.8rem; color: #7a8fb8; margin-bottom: 5px;">${companion.description}</div>
                                <div style="font-size: 0.75rem; color: ${rarityColor}; margin-bottom: 5px;">ğŸ† ${companion.rarity}</div>
                                <div style="background: rgba(0, 0, 0, 0.3); padding: 5px; border-radius: 5px;">
                                    <div style="color: #00ff88; font-size: 0.8rem; font-weight: bold; margin-bottom: 3px;">âœ¨ æŠ€èƒ½</div>
                                    ${skillsHtml}
                                </div>
                            </div>
                            <div style="text-align: right; margin-left: 15px;">
                                ${isOwned ? 
                                    '<div style="background: #00ff88; color: #000; padding: 8px 16px; border-radius: 5px; font-weight: bold;">âœ… å·²æ“æœ‰</div>' :
                                    `<button onclick="buyCompanion('${companion.id}')" style="padding: 8px 16px; background: linear-gradient(135deg, #00d9ff 0%, #00a8cc 100%);">ğŸ’° ${companion.price}</button>`
                                }
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderCardShop() {
            // å•†åº—åªè²©å”®Commonå“è³ªå¡ç‰Œ
            const cardList = Object.values(CARDS).filter(c => c.rarity === 'common');
            
            // æŒ‰å“è³ªåˆ†çµ„
            const rarityOrder = ['Common'];
            const cardsByRarity = {};
            rarityOrder.forEach(rarity => {
                cardsByRarity[rarity] = cardList.filter(c => c.rarity === rarity);
            });
            
            let html = '';
            rarityOrder.forEach(rarity => {
                if (cardsByRarity[rarity].length > 0) {
                    const rarityColor = getRarityColor(rarity);
                    html += `<div style="margin: 20px 0; padding: 10px; background: rgba(0, 217, 255, 0.03); border-radius: 8px;">`;
                    html += `<h3 style="color: ${rarityColor}; margin-bottom: 10px;">ğŸƒ ${rarity} å“è³ª</h3>`;
                    
                    cardsByRarity[rarity].forEach(card => {
                        const owned = gameState.cards.collection.find(c => c.id === card.id);
                        const isOwned = !!owned;
                        const typeIcon = { attack: 'ğŸ—¡ï¸', defense: 'ğŸ›¡ï¸', support: 'âœ¨', resource: 'ğŸ’°', special: 'ğŸŒŸ' }[card.type] || 'â“';
                        
                        // è§£ææ•ˆæœï¼ˆç›´æ¥ä½¿ç”¨descriptionï¼‰
                        let effectsHtml = '';
                        if (card.description) {
                            effectsHtml = `<div style="color: #7a8fb8; font-size: 0.75rem; margin: 2px 0;">â€¢ ${card.description}</div>`;
                        }
                        
                        html += `
                            <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid ${rarityColor}; border-radius: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                    <div style="flex: 1;">
                                        <div style="font-weight: bold; color: ${rarityColor}; margin-bottom: 3px;">${card.icon} ${card.name}</div>
                                        <div style="font-size: 0.8rem; color: #7a8fb8; margin-bottom: 5px;">${typeIcon} ${card.type} | ğŸƒ ${card.series}</div>
                                        ${effectsHtml ? `
                                        <div style="background: rgba(0, 0, 0, 0.3); padding: 5px; border-radius: 5px; margin-top: 5px;">
                                            <div style="color: #00ff88; font-size: 0.8rem; font-weight: bold; margin-bottom: 3px;">âœ¨ æ•ˆæœ</div>
                                            ${effectsHtml}
                                        </div>` : ''}
                                    </div>
                                    <div style="text-align: right; margin-left: 15px;">
                                        ${isOwned ? 
                                            '<div style="background: #00ff88; color: #000; padding: 8px 16px; border-radius: 5px; font-weight: bold;">âœ… å·²æ“æœ‰</div>' :
                                            `<button onclick="buyCard('${card.id}')" style="padding: 8px 16px; background: linear-gradient(135deg, ${rarityColor} 0%, ${rarityColor}88 100%);">ğŸ’° ${card.price}</button>`
                                        }
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
            });
            
            return html;
        }
        
        function buyCard(cardId) {
            const card = CARDS[cardId];
            if (!card) {
                addLog('å•†åº—', 'å¡ç‰Œä¸å­˜åœ¨ï¼');
                return;
            }
            
            if (gameState.player.gold < card.price) {
                addLog('å•†åº—', 'é‡‘å¹£ä¸è¶³ï¼');
                return;
            }
            
            const owned = gameState.cards.collection.find(c => c.id === cardId);
            if (owned) {
                addLog('å•†åº—', `ä½ å·²ç¶“æ“æœ‰ ${card.name}ï¼`);
                return;
            }
            
            gameState.player.gold -= card.price;
            getCard(cardId);
            switchGeneralShopTab('card'); // é‡æ–°æ¸²æŸ“å•†åº—
            updateDisplay();
            playSound('purchase');
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå•†åº—è³¼è²·
            updateQuestProgress('shop_purchase', 1);
        }
        
        // ç¢ç‰‡å•†åº—æ¸²æŸ“
        function renderShardShop() {
            const cardList = Object.values(CARDS);
            
            // æŒ‰å“è³ªåˆ†çµ„
            const rarities = ['Legendary', 'Epic', 'Rare', 'Fine', 'Common'];
            const groupedCards = {};
            rarities.forEach(r => {
                groupedCards[r] = cardList.filter(c => c.rarity === r);
            });
            
            // ç¢ç‰‡å…Œæ›æˆæœ¬ï¼ˆæ¯”å•†åº—è³¼è²·ä¾¿å®œï¼‰
            const shardCosts = {
                'Common': 5,      // 5å€‹ç¢ç‰‡å…Œæ›1å¼µCommonå¡ç‰Œ
                'Fine': 15,       // 15å€‹ç¢ç‰‡å…Œæ›1å¼µFineå¡ç‰Œ
                'Rare': 50,       // 50å€‹ç¢ç‰‡å…Œæ›1å¼µRareå¡ç‰Œ
                'Epic': 150,      // 150å€‹ç¢ç‰‡å…Œæ›1å¼µEpicå¡ç‰Œ
                'Legendary': 500  // 500å€‹ç¢ç‰‡å…Œæ›1å¼µLegendaryå¡ç‰Œ
            };
            
            let html = '<div style="margin-bottom: 15px; padding: 12px; background: rgba(138, 43, 226, 0.1); border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">';
            html += '<h3 style="margin: 0 0 10px 0; color: rgba(138, 43, 226, 1);">ğŸ’ ç¢ç‰‡å…Œæ›</h3>';
            html += '<p style="margin: 0; color: #888; font-size: 0.9rem;">ä½¿ç”¨å°æ‡‰å“è³ªçš„ç¢ç‰‡å…Œæ›å¡ç‰Œï¼Œæ¯”å•†åº—è³¼è²·æ›´åŠƒç®—ï¼</p>';
            
            // é¡¯ç¤ºç•¶å‰ç¢ç‰‡
            html += '<div style="margin-top: 10px; display: flex; gap: 10px; flex-wrap: wrap;">';
            rarities.forEach(rarity => {
                const shards = gameState.cards.shards[rarity] || 0;
                const color = getRarityColor(rarity);
                html += `<div style="padding: 5px 10px; background: rgba(0,0,0,0.2); border-radius: 4px; border: 1px solid ${color};">`;
                html += `<span style="color: ${color}; font-weight: bold;">${rarity}</span>: ${shards} å€‹`;
                html += `</div>`;
            });
            html += '</div></div>';
            
            // æŒ‰å“è³ªåˆ†çµ„é¡¯ç¤º
            rarities.forEach(rarity => {
                const cards = groupedCards[rarity];
                if (cards.length === 0) return;
                
                const color = getRarityColor(rarity);
                const shardCost = shardCosts[rarity];
                const currentShards = gameState.cards.shards[rarity] || 0;
                
                html += `<div style="margin-bottom: 20px;">`;
                html += `<h3 style="color: ${color}; margin-bottom: 10px;">${rarity} (éœ€è¦ ${shardCost} å€‹ç¢ç‰‡)</h3>`;
                html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">`;
                
                cards.forEach(card => {
                    const owned = gameState.cards.collection.find(c => c.id === card.id);
                    const canAfford = currentShards >= shardCost;
                    
                    html += `<div style="background: rgba(138, 43, 226, 0.05); padding: 12px; border-radius: 8px; border: 2px solid ${color};">`;
                    html += `<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">`;
                    html += `<span style="font-size: 2rem;">${card.icon}</span>`;
                    html += `<div style="flex: 1;">`;
                    html += `<div style="font-weight: bold; color: ${color};">${card.name}</div>`;
                    html += `<div style="font-size: 0.85rem; color: #888;">${card.type} | ${card.series}</div>`;
                    html += `</div></div>`;
                    html += `<div style="font-size: 0.9rem; color: #ccc; margin-bottom: 10px;">${card.description}</div>`;
                    
                    if (owned) {
                        html += `<button disabled style="width: 100%; padding: 8px; background: #555; color: #888; border: none; border-radius: 4px; cursor: not-allowed;">âœ… å·²æ“æœ‰</button>`;
                    } else if (!canAfford) {
                        html += `<button disabled style="width: 100%; padding: 8px; background: #555; color: #888; border: none; border-radius: 4px; cursor: not-allowed;">ğŸ’ ${shardCost} ç¢ç‰‡ï¼ˆä¸è¶³ï¼‰</button>`;
                    } else {
                        html += `<button onclick="buyCardWithShards('${card.id}', '${rarity}', ${shardCost})" style="width: 100%; padding: 8px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 4px; cursor: pointer;">ğŸ’ å…Œæ›ï¼ˆ${shardCost} ç¢ç‰‡ï¼‰</button>`;
                    }
                    html += `</div>`;
                });
                
                html += `</div></div>`;
            });
            
            return html;
        }
        
        // ä½¿ç”¨ç¢ç‰‡è³¼è²·å¡ç‰Œ
        function buyCardWithShards(cardId, rarity, shardCost) {
            const card = CARDS[cardId];
            if (!card) {
                addLog('ç¢ç‰‡å•†åº—', 'å¡ç‰Œä¸å­˜åœ¨ï¼');
                return;
            }
            
            const currentShards = gameState.cards.shards[rarity] || 0;
            if (currentShards < shardCost) {
                addLog('ç¢ç‰‡å•†åº—', 'ç¢ç‰‡ä¸è¶³ï¼');
                return;
            }
            
            const owned = gameState.cards.collection.find(c => c.id === cardId);
            if (owned) {
                addLog('ç¢ç‰‡å•†åº—', `ä½ å·²ç¶“æ“æœ‰ ${card.name}ï¼`);
                return;
            }
            
            // æ‰£é™¤ç¢ç‰‡
            gameState.cards.shards[rarity] -= shardCost;
            
            // ç²å¾—å¡ç‰Œ
            getCard(cardId);
            
            const rarityColor = getRarityColor(rarity);
            addLog('ç¢ç‰‡å•†åº—', `ä½¿ç”¨ <span style="color: ${rarityColor}">${shardCost}</span> å€‹ç¢ç‰‡å…Œæ›äº† ${card.icon} <span style="color: ${rarityColor}">${card.name}</span>ï¼`);
            
            // é‡æ–°æ¸²æŸ“å•†åº—
            switchGeneralShopTab('shard');
            updateDisplay();
            playSound('purchase');
        }
        
        function buyCompanion(companionId) {
            const companion = COMPANIONS[companionId];
            if (!companion) {
                addLog('å•†åº—', 'éš¨å¾ä¸å­˜åœ¨ï¼');
                return;
            }
            
            if (gameState.player.gold < companion.price) {
                addLog('å•†åº—', 'é‡‘å¹£ä¸è¶³ï¼');
                return;
            }
            
            const owned = gameState.companions.owned.find(c => c.id === companionId);
            if (owned) {
                addLog('å•†åº—', `ä½ å·²ç¶“æ“æœ‰ ${companion.name}ï¼`);
                return;
            }
            
            gameState.player.gold -= companion.price;
            obtainCompanion(companionId);
            switchGeneralShopTab('companion'); // é‡æ–°æ¸²æŸ“å•†åº—
            updateDisplay();
            playSound('purchase');
        }

        function closeShopModal() {
            document.getElementById('shop-modal').classList.remove('active');
        }

        function buyGeneralItem(item) {
            if (gameState.player.gold < item.price) {
                addLog('å•†åº—', 'é‡‘å¹£ä¸è¶³ï¼');
                return;
            }
            
            // æª¢æŸ¥è³¼è²·æ¬¡æ•¸é™åˆ¶
            if (item.maxPurchase) {
                if (!gameState.player.shopPurchases) gameState.player.shopPurchases = {};
                const purchaseKey = item.type + '_' + item.name;
                
                // å¦‚æœæ˜¯æ¯æ—¥é‡ç½®çš„ç‰©å“ï¼Œæª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®
                if (item.resetDaily) {
                    if (!gameState.player.shopPurchases[purchaseKey]) {
                        gameState.player.shopPurchases[purchaseKey] = { count: 0, lastReset: Date.now() };
                    }
                    
                    const purchaseData = gameState.player.shopPurchases[purchaseKey];
                    const lastResetDate = new Date(purchaseData.lastReset);
                    const nowDate = new Date();
                    
                    // æª¢æŸ¥æ˜¯å¦è·¨å¤©
                    if (lastResetDate.getDate() !== nowDate.getDate() || 
                        lastResetDate.getMonth() !== nowDate.getMonth() || 
                        lastResetDate.getFullYear() !== nowDate.getFullYear()) {
                        purchaseData.count = 0;
                        purchaseData.lastReset = Date.now();
                    }
                    
                    if (purchaseData.count >= item.maxPurchase) {
                        addLog('å•†åº—', `${item.name} ä»Šæ—¥å·²é”åˆ°è³¼è²·ä¸Šé™ï¼`);
                        return;
                    }
                } else {
                    // æ°¸ä¹…é™åˆ¶
                    const currentPurchases = gameState.player.shopPurchases[purchaseKey] || 0;
                    
                    if (currentPurchases >= item.maxPurchase) {
                        addLog('å•†åº—', `${item.name} å·²é”åˆ°è³¼è²·ä¸Šé™ï¼`);
                        return;
                    }
                }
            }
            
            gameState.player.gold -= item.price;
                trackShopPurchase();
            
            switch(item.type) {
                case 'hp':
                    // HPè—¥æ°´æ·»åŠ åˆ°èƒŒåŒ…ï¼ˆä½¿ç”¨å †ç–Šç³»çµ±ï¼‰
                    const hpPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'hp_fixed', // å›ºå®šæ•¸å€¼å›å¾©
                        recovery: item.value, // å›ºå®šæ•¸å€¼
                        desc: `å›å¾©${item.value} HP`,
                        color: '#4CAF50'
                    };
                    addConsumableToInventory(hpPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'ap':
                    // APè—¥æ°´æ·»åŠ åˆ°èƒŒåŒ…ï¼ˆä½¿ç”¨å †ç–Šç³»çµ±ï¼‰
                    const apPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'ap_fixed', // å›ºå®šæ•¸å€¼å›å¾©
                        recovery: item.value, // å›ºå®šæ•¸å€¼
                        desc: `æ¢å¾©${item.value} AP`,
                        color: '#2196F3'
                    };
                    addConsumableToInventory(apPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'both':
                    // ä¾¿ç•¶ï¼ˆHP+APï¼‰æ·»åŠ åˆ°èƒŒåŒ…ï¼ˆä½¿ç”¨å †ç–Šç³»çµ±ï¼‰
                    const bothPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'both_fixed', // åŒæ™‚å›å¾©HPå’ŒAP
                        hpRecovery: item.hp,
                        apRecovery: item.ap,
                        desc: `å›å¾©${item.hp} HP + ${item.ap} AP`,
                        color: '#FF9800'
                    };
                    addConsumableToInventory(bothPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'hp_percent':
                    // ç™¾åˆ†æ¯”HPè—¥æ°´
                    const hpPercentPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'hp_percent',
                        recovery: item.value,
                        description: item.desc,
                        color: '#4CAF50'
                    };
                    addConsumableToInventory(hpPercentPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'ap_fixed':
                    // å›ºå®šAPè—¥æ°´
                    const apFixedPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'ap_potion',
                        recovery: item.value,
                        description: item.desc,
                        color: '#2196F3'
                    };
                    addConsumableToInventory(apFixedPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'both_percent':
                    // ç™¾åˆ†æ¯”çµ„åˆè—¥æ°´
                    const bothPercentPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'both_percent',
                        hpPercent: item.hpPercent,
                        apRecovery: item.ap,
                        description: item.desc,
                        color: '#FF9800'
                    };
                    addConsumableToInventory(bothPercentPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'hp_regen':
                    // æŒçºŒHPå›å¾©è—¥æ°´
                    const hpRegenPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'hp_regen',
                        regenValue: item.value,
                        duration: item.duration,
                        description: item.desc,
                        color: '#4CAF50'
                    };
                    addConsumableToInventory(hpRegenPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'both_regen':
                    // æŒçºŒçµ„åˆå›å¾©è—¥æ°´
                    const bothRegenPotion = {
                        id: Date.now() + Math.random(),
                        name: item.name,
                        type: 'consumable',
                        subtype: 'both_regen',
                        hpRegenValue: item.hpValue,
                        apRegenValue: item.apValue,
                        duration: item.duration,
                        description: item.desc,
                        color: '#FF9800'
                    };
                    addConsumableToInventory(bothRegenPotion);
                    gameState.stats.items++;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå·²æ·»åŠ åˆ°èƒŒåŒ…ï¼`);
                    break;
                case 'hp_crystal':
                    gameState.player.maxHp += item.value;
                    gameState.player.hp += item.value; // åŒæ™‚å›å¾©å¢åŠ çš„HP
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæœ€å¤§HPæ°¸ä¹… +${item.value}ï¼ç•¶å‰æœ€å¤§HPï¼š${gameState.player.maxHp}`);
                    updateUI();
                    break;
                case 'guardian_charm':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'è­·èº«ç¬¦', type: 'guardian', value: item.value, duration: 999 });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œç²å¾—è‡´å‘½å‚·ä¿è­·ï¼`);
                    break;
                case 'blessing_potion':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'ç¥ç¦(æ”»æ“Š)', type: 'atk', value: 0.08, duration: item.duration });
                    gameState.player.buffs.push({ name: 'ç¥ç¦(é˜²ç¦¦)', type: 'def', value: 0.08, duration: item.duration });
                    gameState.player.buffs.push({ name: 'ç¥ç¦(çˆ†æ“Š)', type: 'crit', value: 8, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œç²å¾—å…¨å±¬æ€§+8% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'smoke_bomb':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'ç…™éœ§å½ˆ', type: 'enemy_atk_debuff', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œä¸‹æ¬¡æˆ°é¬¥æ•µäººæ”»æ“ŠåŠ›-25%ï¼`);
                    break;
                case 'power_potion':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'å¼·åŒ–(æ”»æ“Š)', type: 'atk', value: 0.15, duration: item.duration });
                    gameState.player.buffs.push({ name: 'å¼·åŒ–(é˜²ç¦¦)', type: 'def', value: 0.15, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ”»æ“Š+15%ã€é˜²ç¦¦+15% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'scout_scroll':
                    if (!gameState.scoutInfo) gameState.scoutInfo = {};
                    gameState.scoutInfo.remaining = item.value;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ¥ä¸‹ä¾†${item.value}å ´æˆ°é¬¥å¯æŸ¥çœ‹æ•µäººè©³ç´°è³‡è¨Šï¼`);
                    break;
                case 'exp_potion':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'ç¶“é©—è—¥æ°´', type: 'exp', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œç¶“é©—ç²å¾—+40% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'luck_potion':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'å¹¸é‹è—¥æ°´', type: 'drop', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ‰è½ç‡+35% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'berserk_potion':
                    if (!gameState.player.buffs) gameState.player.buffs = [];
                    gameState.player.buffs.push({ name: 'ç‹‚æˆ°(æ”»æ“Š)', type: 'atk', value: 0.25, duration: item.duration });
                    gameState.player.buffs.push({ name: 'ç‹‚æˆ°(å‰¯ä½œç”¨)', type: 'def', value: -0.1, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ”»æ“Š+25%ã€é˜²ç¦¦-10% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'bag_expand':
                    // ç›´æ¥å¢åŠ  maxInventory
                    if (!gameState.maxInventory) gameState.maxInventory = 50;
                    gameState.maxInventory += item.value;
                    
                    // è¨˜éŒ„è³¼è²·æ¬¡æ•¸
                    if (item.maxPurchase) {
                        const purchaseKey = item.type + '_' + item.name;
                        if (!gameState.player.shopPurchases) gameState.player.shopPurchases = {};
                        gameState.player.shopPurchases[purchaseKey] = (gameState.player.shopPurchases[purchaseKey] || 0) + 1;
                        const remaining = item.maxPurchase - gameState.player.shopPurchases[purchaseKey];
                        addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼ŒèƒŒåŒ…å®¹é‡æ°¸ä¹… +${item.value}ï¼ç•¶å‰ä¸Šé™ï¼š${gameState.maxInventory}ï¼ˆå‰©é¤˜ ${remaining} æ¬¡ï¼‰`);
                    } else {
                        addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼ŒèƒŒåŒ…å®¹é‡æ°¸ä¹… +${item.value}ï¼ç•¶å‰ä¸Šé™ï¼š${gameState.maxInventory}`);
                    }
                    updateUI();
                    break;
                case 'ap_potion':
                    const apToRecover = Math.min(item.value, gameState.player.maxAp - gameState.player.ap);
                    gameState.player.ap += apToRecover;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå›å¾©äº† ${apToRecover} é»é«”åŠ›ï¼`);
                    updateUI();
                    break;

                case 'reset_daily':
                    if (gameState.dailyQuests && gameState.dailyQuests.quests && gameState.dailyQuests.quests.length > 0) {
                        const resetCount = gameState.dailyQuests.quests.length;
                        
                        // é‡ç½®æ‰€æœ‰æ¯æ—¥ä»»å‹™
                        gameState.dailyQuests.quests.forEach(quest => {
                            quest.progress = 0;
                            quest.accepted = false;
                        });
                        
                        // æ¸…ç©ºå·²å®Œæˆåˆ—è¡¨
                        gameState.dailyQuests.completed = [];
                        
                        // è¨˜éŒ„è³¼è²·æ¬¡æ•¸
                        if (item.maxPurchase) {
                            const purchaseKey = item.type + '_' + item.name;
                            if (!gameState.player.shopPurchases) gameState.player.shopPurchases = {};
                            
                            if (item.resetDaily) {
                                // æ¯æ—¥é‡ç½®çš„ç‰©å“
                                if (!gameState.player.shopPurchases[purchaseKey]) {
                                    gameState.player.shopPurchases[purchaseKey] = { count: 0, lastReset: Date.now() };
                                }
                                gameState.player.shopPurchases[purchaseKey].count += 1;
                            } else {
                                // æ°¸ä¹…é™åˆ¶
                                gameState.player.shopPurchases[purchaseKey] = (gameState.player.shopPurchases[purchaseKey] || 0) + 1;
                            }
                        }
                        
                        addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œé‡ç½®äº† ${resetCount} å€‹æ¯æ—¥ä»»å‹™ï¼`);
                        updateUI();
                    } else {
                        addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œä½†æ²’æœ‰æ¯æ—¥ä»»å‹™å¯ä»¥é‡ç½®ã€‚`);
                    }
                    break;

            }
            
            // æ›´æ–°å•†åº—è³¼è²·ä»»å‹™é€²åº¦
            updateQuestProgress('shop_purchase', 1);
            
            updateUI();
            
            // å¦‚æœèƒŒåŒ…çª—å£æ˜¯æ‰“é–‹çš„ï¼Œåˆ·æ–°èƒŒåŒ…é¡¯ç¤º
            const bagModal = document.getElementById('bag-modal');
            if (bagModal && bagModal.classList.contains('active')) {
                openBagModal();
            }
            
            saveGame();
        }

        function openSalvageModal() {
            const modal = document.getElementById('salvage-modal');
            const items = document.getElementById('salvage-items');
            
            // éæ¿¾ null ç‰©å“
            gameState.inventory = gameState.inventory.filter(item => item !== null && item !== undefined);
            
            // åªé¡¯ç¤ºè£å‚™é¡å‹çš„ç‰©å“ï¼Œéæ¿¾æ‰æ¶ˆè€—å“
            const equipmentItems = gameState.inventory.filter(item => item && item.type && item.type !== 'consumable');
            
            if (equipmentItems.length === 0) {
                items.innerHTML = '<p style="color: #7a8fb8; text-align: center; padding: 20px;">æ²’æœ‰å¯åˆ†è§£çš„è£å‚™</p>';
            } else {
                items.innerHTML = equipmentItems.map(item => {
                    // é˜²ç¦¦æ€§æª¢æŸ¥
                    if (!item || !item.rarity) {
                        return '';
                    }
                    const rarity = RARITIES.find(r => r.name === item.rarity);
                    return `
                        <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="color: ${item.color}; font-weight: bold;">${item.name}</div>
                                <div style="font-size: 0.85rem; color: #7a8fb8;">åˆ†è§£ç²å¾— ${rarity.shards} ç¢ç‰‡</div>
                            </div>
                            <button onclick="salvageItem('${item.id}')" style="padding: 8px 16px;">åˆ†è§£</button>
                        </div>
                    `;
                }).join('');
            }
            
            modal.classList.add('active');
        }

        function closeSalvageModal() {
            document.getElementById('salvage-modal').classList.remove('active');
        }

        // ========== ç¢ç‰‡å•†åº—ç³»çµ± ==========
        
        let currentShopTab = 'equipment';
        
        function openShardShopModal() {
            const modal = document.getElementById('shard-shop-modal');
            document.getElementById('shop-shards-display').textContent = gameState.player.shards;
            switchShopTab('equipment');
            modal.classList.add('active');
        }
        
        function closeShardShopModal() {
            document.getElementById('shard-shop-modal').classList.remove('active');
        }
        
        function switchShopTab(tab) {
            currentShopTab = tab;
            
            // æ›´æ–°æŒ‰éˆ•æ¨£å¼
            ['equipment', 'consumable', 'special'].forEach(t => {
                const btn = document.getElementById(`shop-tab-${t}`);
                if (t === tab) {
                    btn.style.background = '#00d9ff';
                    btn.style.color = '#0a1628';
                } else {
                    btn.style.background = '';
                    btn.style.color = '';
                }
            });
            
            // æ›´æ–°å…§å®¹
            const content = document.getElementById('shop-content');
            switch(tab) {
                case 'equipment':
                    content.innerHTML = renderEquipmentShop();
                    break;
                case 'consumable':
                    content.innerHTML = renderConsumableShop();
                    break;
                case 'special':
                    content.innerHTML = renderSpecialShop();
                    break;
            }
        }
        
        function renderEquipmentShop() {
            const items = [
                { rarity: 'uncommon', label: 'å„ªè³ªè£å‚™', price: 10, color: '#4CAF50' },
                { rarity: 'fine', label: 'ç²¾è‰¯è£å‚™', price: 20, color: '#2196F3' },
                { rarity: 'rare', label: 'ç¨€æœ‰è£å‚™', price: 40, color: '#9C27B0' },
                { rarity: 'epic', label: 'å²è©©è£å‚™', price: 80, color: '#FF9800' },
                { rarity: 'legendary', label: 'å‚³èªªè£å‚™', price: 150, color: '#F44336' },
                { rarity: 'mythic', label: 'ç¥è©±è£å‚™', price: 300, color: '#FFD700' }
            ];
            
            return items.map(item => `
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: ${item.color}; font-weight: bold;">ğŸª ${item.label}</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">éš¨æ©Ÿç²å¾—ä¸€ä»¶${item.label}</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #4EA5FF; font-weight: bold; margin-bottom: 5px;">ğŸ”· ${item.price}</div>
                        <button onclick="buyEquipment('${item.rarity}', ${item.price})" style="padding: 6px 12px;">è³¼è²·</button>
                    </div>
                </div>
            `).join('');
        }
        
        let currentConsumableTab = 'recovery';
        
        function switchConsumableTab(tab) {
            currentConsumableTab = tab;
            switchShopTab('consumable'); // é‡æ–°æ¸²æŸ“
        }
        
        function renderConsumableShop() {
            // åˆ†é¡æ¨™ç±¤
            const tabs = `
                <div style="display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button onclick="switchConsumableTab('recovery')" style="flex: 1; min-width: 70px; padding: 6px; font-size: 0.85rem; background: ${currentConsumableTab === 'recovery' ? '#00d9ff' : 'rgba(0, 217, 255, 0.1)'}; color: ${currentConsumableTab === 'recovery' ? '#0a1628' : '#00d9ff'};">ğŸ“¦ å›å¾©</button>
                    <button onclick="switchConsumableTab('buff')" style="flex: 1; min-width: 70px; padding: 6px; font-size: 0.85rem; background: ${currentConsumableTab === 'buff' ? '#00d9ff' : 'rgba(0, 217, 255, 0.1)'}; color: ${currentConsumableTab === 'buff' ? '#0a1628' : '#00d9ff'};">âš¡ å¢ç›Š</button>
                    <button onclick="switchConsumableTab('exp')" style="flex: 1; min-width: 70px; padding: 6px; font-size: 0.85rem; background: ${currentConsumableTab === 'exp' ? '#00d9ff' : 'rgba(0, 217, 255, 0.1)'}; color: ${currentConsumableTab === 'exp' ? '#0a1628' : '#00d9ff'};">ğŸ“š ç¶“é©—</button>
                </div>
            `;
            
            let items = [];
            if (currentConsumableTab === 'recovery') {
                items = [
                    { name: 'å°å‹è—¥æ°´', desc: 'å›å¾©15% HP', price: 2, type: 'hp', value: 0.15 },
                    { name: 'ä¸­å‹è—¥æ°´', desc: 'å›å¾©25% HP', price: 4, type: 'hp', value: 0.25 },
                    { name: 'å¤§å‹è—¥æ°´', desc: 'å›å¾©35% HP', price: 6, type: 'hp', value: 0.35 },
                    { name: 'è¶…ç´šè—¥æ°´', desc: 'å›å¾©50% HP', price: 10, type: 'hp', value: 0.5 },
                    { name: 'å®Œå…¨å›å¾©è—¥æ°´', desc: 'å›å¾©100% HP', price: 18, type: 'hp', value: 1.0 },
                    { name: 'èƒ½é‡é£²æ–™', desc: 'æ¢å¾©5 AP', price: 12, type: 'ap', value: 5 },
                    { name: 'è¬èƒ½è—¥æ°´', desc: 'å›å¾©100% HP + 5 AP', price: 25, type: 'both', hp: 1.0, ap: 5 }
                ];
            } else if (currentConsumableTab === 'buff') {
                items = [
                    { name: 'åŠ›é‡è—¥æ°´', desc: 'æ”»æ“Š+20% (æŒ‰10æˆ°)', price: 15, type: 'buff_atk', value: 0.2, duration: 10 },
                    { name: 'é˜²ç¦¦è—¥æ°´', desc: 'é˜²ç¦¦+20% (æŒ‰10æˆ°)', price: 15, type: 'buff_def', value: 0.2, duration: 10 },
                    { name: 'æ•æ·è—¥æ°´', desc: 'çˆ†æ“Š+10% (æŒ‰10æˆ°)', price: 15, type: 'buff_crit', value: 10, duration: 10 },
                    { name: 'ç‹‚æš´è—¥æ°´', desc: 'æ”»æ“Š+30%/é˜²ç¦¦-10% (æŒ‰5æˆ°)', price: 25, type: 'buff_berserk', atk: 0.3, def: -0.1, duration: 5 },
                    { name: 'å …éŸŒè—¥æ°´', desc: 'é˜²ç¦¦+30%/æ”»æ“Š-10% (æŒ‰5æˆ°)', price: 25, type: 'buff_tank', def: 0.3, atk: -0.1, duration: 5 },
                    { name: 'å¹¸é‹è—¥æ°´', desc: 'æ‰è½+50% (æŒ‰10æˆ°)', price: 20, type: 'buff_drop', value: 0.5, duration: 10 },
                    { name: 'ç¶“é©—è—¥æ°´', desc: 'ç¶“é©—+50% (æŒ‰10æˆ°)', price: 18, type: 'buff_exp', value: 0.5, duration: 10 },
                    { name: 'å…¨èƒ½è—¥æ°´', desc: 'å…¨å±¬æ€§+15% (æŒ‰10æˆ°)', price: 40, type: 'buff_all', atk: 0.15, def: 0.15, crit: 5, duration: 10 }
                ];
            } else if (currentConsumableTab === 'exp') {
                items = [
                    { name: 'å°å‹ç¶“é©—æ›¸', desc: 'ç²å¾—300ç¶“é©—', price: 5, type: 'exp', value: 300 },
                    { name: 'ä¸­å‹ç¶“é©—æ›¸', desc: 'ç²å¾—700ç¶“é©—', price: 10, type: 'exp', value: 700 },
                    { name: 'å¤§å‹ç¶“é©—æ›¸', desc: 'ç²å¾—1500ç¶“é©—', price: 20, type: 'exp', value: 1500 }
                ];
            }
            
            return tabs + items.map(item => `
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #4CAF50; font-weight: bold;">ğŸ§ª ${item.name}</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">${item.desc}</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #4EA5FF; font-weight: bold; margin-bottom: 5px;">ğŸ”· ${item.price}</div>
                        <button onclick='buyConsumable(${JSON.stringify(item)})' style="padding: 6px 12px;">è³¼è²·</button>
                    </div>
                </div>
            `).join('');
        }
        
        function renderSpecialShop() {
            return `
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #00BCD4; font-weight: bold;">ğŸ å¥—è£å¯¶ç®±</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">éš¨æ©Ÿç²å¾—ä¸€ä»¶å¥—è£è£å‚™</div>
                        <div style="font-size: 0.75rem; color: #ff9800; margin-top: 3px;">æ¯æ—¥1æ¬¡</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #4EA5FF; font-weight: bold; margin-bottom: 5px;">ğŸ”· 200</div>
                        <button onclick="buySpecialItem('set_box')" style="padding: 6px 12px;">è³¼è²·</button>
                    </div>
                </div>
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #F44336; font-weight: bold;">ğŸª å‚³èªªå¯¶ç®±</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">éš¨æ©Ÿç²å¾—ä¸€ä»¶å‚³èªªè£å‚™</div>
                        <div style="font-size: 0.75rem; color: #ff9800; margin-top: 3px;">æ¯æ—¥3æ¬¡</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #4EA5FF; font-weight: bold; margin-bottom: 5px;">ğŸ”· 100</div>
                        <button onclick="buySpecialItem('legendary_box')" style="padding: 6px 12px;">è³¼è²·</button>
                    </div>
                </div>
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #FFD700; font-weight: bold;">ğŸ“œ æŠ€èƒ½é‡ç½®å·</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">é‡æ–°é¸æ“‡æŠ€èƒ½</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #4EA5FF; font-weight: bold; margin-bottom: 5px;">ğŸ”· 50</div>
                        <button onclick="buySpecialItem('skill_reset')" style="padding: 6px 12px;">è³¼è²·</button>
                    </div>
                </div>
                <div style="padding: 12px; margin: 8px 0; background: rgba(0, 217, 255, 0.05); border: 1px solid rgba(0, 217, 255, 0.3); border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: #4CAF50; font-weight: bold;">ğŸ’ èƒŒåŒ…æ“´å……</div>
                        <div style="font-size: 0.85rem; color: #7a8fb8;">èƒŒåŒ…ä¸Šé™+1æ ¼ï¼ˆæœ€å¤š100æ ¼ï¼‰</div>
                    </div>
                    <div style="text-align: right;">
                        <div style="color: #4EA5FF; font-weight: bold; margin-bottom: 5px;">ğŸ”· 100</div>
                        <button onclick="buySpecialItem('bag_expand')" style="padding: 6px 12px;">è³¼è²·</button>
                    </div>
                </div>
            `;
        }
        

        
        // è³¼è²·è£å‚™
        function buyEquipment(rarity, price) {
            if (gameState.player.shards < price) {
                addLog('ç³»çµ±', 'ç¢ç‰‡ä¸è¶³ï¼');
                return;
            }
            
            gameState.player.shards -= price;
            
            // ç”Ÿæˆéš¨æ©Ÿè£å‚™ï¼ˆè½‰æ›å“è³ªåç¨±ï¼‰
            const rarityName = RARITY_NAME_MAP[rarity] || 'Common';
            const item = generateItem('normal', rarityName);
            if (item) {
                gameState.inventory.push(item);
                gameState.stats.items++;
                // çµ±è¨ˆå‚³èªªè£å‚™
                        if (item.rarity === 'legendary') {
                    gameState.stats.legendaryItems = (gameState.stats.legendaryItems || 0) + 1;
                }
                addLog('å•†åº—', `èŠ±è²» ${price} ğŸ”· ç¢ç‰‡è³¼è²·äº† ${item.name}ï¼`);
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
                updateQuestProgress('collect_equipment', 1);
                if (item.rarity === 'Rare' || item.rarity === 'Epic' || item.rarity === 'Legendary' || item.rarity === 'Set') {
                    updateQuestProgress('collect_rare', 1);
                }
                if (item.rarity === 'Legendary') {
                    updateQuestProgress('collect_legendary', 1);
                }
                
                // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå•†åº—è³¼è²·
                updateQuestProgress('shop_purchase', 1);
            }
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('shop-shards-display').textContent = gameState.player.shards;
            updateUI();
            saveGame();
        }
        
        // è³¼è²·æ¶ˆè€—å“
        function buyConsumable(item) {
            if (gameState.player.shards < item.price) {
                addLog('ç³»çµ±', 'ç¢ç‰‡ä¸è¶³ï¼');
                return;
            }
            
            gameState.player.shards -= item.price;
            
            if (!gameState.player.buffs) gameState.player.buffs = [];
            
            // æ ¹æ“šé¡å‹è™•ç†
            switch(item.type) {
                case 'hp':
                    const healAmount = Math.floor(gameState.player.maxHp * item.value);
                    gameState.player.hp = Math.min(gameState.player.hp + healAmount, gameState.player.maxHp);
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå›å¾©äº† ${healAmount} HPï¼`);
                    break;
                case 'ap':
                    gameState.player.ap = Math.min(gameState.player.ap + item.value, gameState.player.maxAp);
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ¢å¾©äº† ${item.value} APï¼`);
                    break;
                case 'both':
                    const healHp = Math.floor(gameState.player.maxHp * item.hp);
                    gameState.player.hp = Math.min(gameState.player.hp + healHp, gameState.player.maxHp);
                    gameState.player.ap = Math.min(gameState.player.ap + item.ap, gameState.player.maxAp);
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå›å¾©äº† ${healHp} HP å’Œ ${item.ap} APï¼`);
                    break;
                case 'exp':
                    gameState.player.exp += item.value;
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œç²å¾—äº† ${item.value} ç¶“é©—ï¼`);
                    if (gameState.player.exp >= gameState.player.expToNext) {
                        levelUp();
                    }
                    break;
                case 'buff_atk':
                    gameState.player.buffs.push({ name: item.name, type: 'atk', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ”»æ“Š+20% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_def':
                    gameState.player.buffs.push({ name: item.name, type: 'def', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œé˜²ç¦¦+20% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_crit':
                    gameState.player.buffs.push({ name: item.name, type: 'crit', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œçˆ†æ“Š+10% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_berserk':
                    gameState.player.buffs.push({ name: item.name, type: 'atk', value: item.atk, duration: item.duration });
                    gameState.player.buffs.push({ name: item.name + '(å‰¯ä½œç”¨)', type: 'def', value: item.def, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ”»æ“Š+30%/é˜²ç¦¦-10% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_tank':
                    gameState.player.buffs.push({ name: item.name, type: 'def', value: item.def, duration: item.duration });
                    gameState.player.buffs.push({ name: item.name + '(å‰¯ä½œç”¨)', type: 'atk', value: item.atk, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œé˜²ç¦¦+30%/æ”»æ“Š-10% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_drop':
                    gameState.player.buffs.push({ name: item.name, type: 'drop', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œæ‰è½+50% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_exp':
                    gameState.player.buffs.push({ name: item.name, type: 'exp', value: item.value, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œç¶“é©—+50% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
                case 'buff_all':
                    gameState.player.buffs.push({ name: item.name + '(æ”»æ“Š)', type: 'atk', value: item.atk, duration: item.duration });
                    gameState.player.buffs.push({ name: item.name + '(é˜²ç¦¦)', type: 'def', value: item.def, duration: item.duration });
                    gameState.player.buffs.push({ name: item.name + '(çˆ†æ“Š)', type: 'crit', value: item.crit, duration: item.duration });
                    addLog('å•†åº—', `è³¼è²·äº† ${item.name}ï¼Œå…¨å±¬æ€§+15% (æŒçºŒ${item.duration}æˆ°)ï¼`);
                    break;
            }
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('shop-shards-display').textContent = gameState.player.shards;
            updateUI();
            saveGame();
        }
        
        // è³¼è²·ç‰¹æ®Šç‰©å“
        function buySpecialItem(itemType) {
            let price = 0;
            let itemName = '';
            
            switch(itemType) {
                case 'set_box':
                    price = 280; // 200 â†’ 280 (+40%)
                    itemName = 'å¥—è£å¯¶ç®±';
                    break;
                case 'legendary_box':
                    price = 140; // 100 â†’ 140 (+40%)
                    itemName = 'å‚³èªªå¯¶ç®±';
                    break;
                case 'skill_reset':
                    price = 70; // 50 â†’ 70 (+40%)
                    itemName = 'æŠ€èƒ½é‡ç½®å·';
                    break;
                case 'bag_expand':
                    price = 150; // 100 â†’ 150 (+50%)
                    itemName = 'èƒŒåŒ…æ“´å……';
                    break;
            }
            
            if (gameState.player.shards < price) {
                addLog('ç³»çµ±', 'ç¢ç‰‡ä¸è¶³ï¼');
                return;
            }
            
            gameState.player.shards -= price;
            
            switch(itemType) {
                case 'set_box':
                    const setItem = generateItem('normal', 'Set');
                    if (setItem && addToInventory(setItem)) {
                        gameState.stats.items++;
                        addLog('å•†åº—', `èŠ±è²» ${price} ğŸ”· ç¢ç‰‡è³¼è²·äº†å¥—è£å¯¶ç®±ï¼Œç²å¾—äº† ${setItem.name}ï¼`);
                        
                        // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
                        updateQuestProgress('collect_equipment', 1);
                        updateQuestProgress('collect_rare', 1); // å¥—è£ç®—ç¨€æœ‰
                        
                        updateQuestProgress('shop_purchase', 1);
                    }
                    break;
                case 'legendary_box':
                    const legendaryItem = generateItem('normal', 'Legendary');
                    if (legendaryItem && addToInventory(legendaryItem)) {
                        gameState.stats.items++;
                        gameState.stats.legendaryItems = (gameState.stats.legendaryItems || 0) + 1;
                        addLog('å•†åº—', `èŠ±è²» ${price} ğŸ”· ç¢ç‰‡è³¼è²·äº†å‚³èªªå¯¶ç®±ï¼Œç²å¾—äº† ${legendaryItem.name}ï¼`);
                        
                        // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
                        updateQuestProgress('collect_equipment', 1);
                        updateQuestProgress('collect_rare', 1);
                        updateQuestProgress('collect_legendary', 1);
                        
                        updateQuestProgress('shop_purchase', 1);
                    }
                    break;
                case 'skill_reset':
                    // æŠ€èƒ½é‡ç½®å·æ·»åŠ åˆ°èƒŒåŒ…
                    const skillResetItem = {
                        id: Date.now() + Math.random(),
                        name: 'æŠ€èƒ½é‡ç½®å·',
                        type: 'consumable',
                        subType: 'skill_reset',
                        desc: 'ä½¿ç”¨å¾Œå¯ä»¥é‡æ–°é¸æ“‡æŠ€èƒ½',
                        color: '#FFD700'
                    };
                    if (addToInventory(skillResetItem, false)) {
                        gameState.stats.items++;
                    } else {
                        gameState.player.shards += price; // é€€æ¬¾
                        return;
                    }
                    addLog('å•†åº—', `èŠ±è²» ${price} ğŸ”· ç¢ç‰‡è³¼è²·äº†æŠ€èƒ½é‡ç½®å·ï¼å·²æ·»åŠ åˆ°èƒŒåŒ…ã€‚`);
                    updateQuestProgress('shop_purchase', 1);
                    break;
                case 'bag_expand':
                    // èƒŒåŒ…æ“´å……å·æ·»åŠ åˆ°èƒŒåŒ…
                    const bagExpandItem = {
                        id: Date.now() + Math.random(),
                        name: 'èƒŒåŒ…æ“´å……å·',
                        type: 'consumable',
                        subType: 'bag_expand',
                        desc: 'ä½¿ç”¨å¾ŒèƒŒåŒ…ä¸Šé™+1æ ¼ï¼ˆæœ€å¤š100æ ¼ï¼‰',
                        color: '#4CAF50'
                    };
                    if (addToInventory(bagExpandItem, false)) {
                        gameState.stats.items++;
                    } else {
                        gameState.player.shards += price; // é€€æ¬¾
                        return;
                    }
                    addLog('å•†åº—', `èŠ±è²» ${price} ğŸ”· ç¢ç‰‡è³¼è²·äº†èƒŒåŒ…æ“´å……å·ï¼å·²æ·»åŠ åˆ°èƒŒåŒ…ã€‚`);
                    updateQuestProgress('shop_purchase', 1);
                    break;
            }
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('shop-shards-display').textContent = gameState.player.shards;
            updateUI();
            saveGame();
        }
        


        function salvageItem(itemId) {
            const item = gameState.inventory.find(i => i.id == itemId);
            if (!item) return;
            
            const rarity = RARITIES.find(r => r.name === item.rarity);
            gameState.player.shards += rarity.shards;
            gameState.inventory = gameState.inventory.filter(i => i.id != itemId);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šåˆ†è§£è£å‚™
            updateQuestProgress('salvage_equipment', 1);
            
            addLog('åˆ†è§£', `åˆ†è§£äº† ${item.name}ï¼Œç²å¾— ${rarity.shards} ç¢ç‰‡`);
            updateUI();
            openSalvageModal(); // é‡æ–°æ‰“é–‹ä»¥æ›´æ–°åˆ—è¡¨
        }

        function openHowToPlay() {
            document.getElementById('how-to-play-modal').classList.add('active');
        }

        function closeHowToPlay() {
            document.getElementById('how-to-play-modal').classList.remove('active');
        }

        // ========== è¿­ä»£ç³»çµ± ==========
        
        // æª¢æŸ¥æ˜¯å¦å®Œæˆæ‰€æœ‰Boss
        function checkAllBossesCompleted() {
            // ç°¡åŒ–ç‰ˆï¼šåªè¦ç­‰ç´šé”åˆ°100å°±èªç‚ºå®Œæˆ
            // å¯¦éš›æ‡‰è©²æª¢æŸ¥gameState.iteration.completedBosses
            return gameState.player.level >= 100;
        }
        
        // è¨ˆç®—è¿­ä»£é»æ•¸
        function calculateIterationPoints() {
            const kills = gameState.stats.kills || 0;
            const legendary = gameState.stats.legendaryItems || 0;
            const shards = gameState.player.shards || 0;
            
            // IP = 10 + floor(æ“Šæ•—æ•¸/1000) + floor(å‚³èªªè£å‚™/10) + floor(ç¢ç‰‡/5000) + æˆå°±IP
            let ip = 10;
            ip += Math.floor(kills / 1000);
            ip += Math.floor(legendary / 10);
            ip += Math.floor(shards / 5000);
            // æˆå°±IPç›®å‰ç‚º0ï¼Œæœªä¾†å¯æ“´å±•
            
            return ip;
        }
        
        // è¨ˆç®—ç¢ç‰‡ä¿ç•™æ¯”ä¾‹
        function getShardRetentionRate() {
            const iterationCount = gameState.iteration.count || 0;
            if (iterationCount === 0) return 0.10;  // 10%
            if (iterationCount === 1) return 0.15;  // 15%
            if (iterationCount === 2) return 0.20;  // 20%
            return 0.25;  // 25%
        }
        
        // ç²å¾—è¿­ä»£ç¨±è™Ÿ
        function getIterationTitle(count) {
            if (count === 1) return 'ğŸ”„ åˆæ¬¡è¿­ä»£è€…';
            if (count === 2) return 'ğŸ”„ äºŒæ¬¡è¿­ä»£è€…';
            if (count >= 5 && count < 10) return 'ğŸ”„ è³‡æ·±è¿­ä»£è€…';
            if (count >= 10 && count < 20) return 'ğŸ”„ è¿­ä»£å¤§å¸«';
            if (count >= 20) return 'ğŸ”„ æ°¸æ†è¿­ä»£è€…';
            return 'ğŸ”„ è¿­ä»£è€…';
        }
        
        // æ‰“é–‹è¿­ä»£æ¨¡æ…‹è¦–çª—
        function openIterationModal() {
            // æª¢æŸ¥æ¢ä»¶
            if (gameState.player.level < 100) {
                addLog('ç³»çµ±', 'éœ€è¦é”åˆ°100ç´šæ‰èƒ½è¿­ä»£ï¼');
                return;
            }
            
            if (!checkAllBossesCompleted()) {
                addLog('ç³»çµ±', 'éœ€è¦å®Œæˆæ‰€æœ‰å€åŸŸBossæ‰èƒ½è¿­ä»£ï¼');
                return;
            }
            
            // è¨ˆç®—çå‹µ
            const nextCount = (gameState.iteration.count || 0) + 1;
            const ip = calculateIterationPoints();
            const retentionRate = getShardRetentionRate();
            const retainedShards = Math.floor(gameState.player.shards * retentionRate);
            const title = getIterationTitle(nextCount);
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('iteration-next-count').textContent = nextCount;
            document.getElementById('iteration-current-level').textContent = gameState.player.level;
            document.getElementById('iteration-current-kills').textContent = gameState.stats.kills || 0;
            document.getElementById('iteration-current-legendary').textContent = gameState.stats.legendaryItems || 0;
            document.getElementById('iteration-current-shards').textContent = gameState.player.shards || 0;
            document.getElementById('iteration-reward-ip').textContent = `+${ip} IP`;
            document.getElementById('iteration-reward-shards').textContent = `${retainedShards} (${Math.floor(retentionRate * 100)}%)`;
            document.getElementById('iteration-reward-title').textContent = title;
            
            // é¡¯ç¤ºæ¨¡æ…‹è¦–çª—
            document.getElementById('iteration-modal').classList.add('active');
        }
        
        // é—œé–‰è¿­ä»£æ¨¡æ…‹è¦–çª—
        function closeIterationModal() {
            document.getElementById('iteration-modal').classList.remove('active');
        }
        
        // ç¢ºèªè¿­ä»£
        function confirmIteration() {
            // å†æ¬¡ç¢ºèª
            const confirmed = confirm('âš ï¸ æœ€å¾Œç¢ºèªï¼\n\nä½ çš„ç­‰ç´šã€è£å‚™ã€é‡‘å¹£å°‡æœƒè¢«é‡ç½®ï¼\n\nç¢ºå®šè¦ç¹¼çºŒå—ï¼Ÿ');
            if (!confirmed) return;
            
            // è¨ˆç®—çå‹µ
            const ip = calculateIterationPoints();
            const retentionRate = getShardRetentionRate();
            const retainedShards = Math.floor(gameState.player.shards * retentionRate);
            
            // æ›´æ–°è¿­ä»£æ•¸æ“š
            gameState.iteration.count = (gameState.iteration.count || 0) + 1;
            gameState.iteration.totalIP = (gameState.iteration.totalIP || 0) + ip;
            gameState.iteration.availableIP = (gameState.iteration.availableIP || 0) + ip;
            
            // é‡ç½®ç©å®¶æ•¸æ“š
            const savedClass = gameState.player.class;
            const savedSkill = gameState.player.skill;
            const savedName = gameState.player.name;
            const savedTalents = gameState.iteration.talents || {};
            
            // é‡ç½®ç‚ºåˆå§‹ç‹€æ…‹
            const classData = CLASSES[savedClass];
            gameState.player.level = 1;
            gameState.player.exp = 0;
            gameState.player.expToNext = 100;
            gameState.player.hp = classData.hp;
            gameState.player.maxHp = classData.hp;
            gameState.player.ap = 100;
            gameState.player.maxAp = 100;
            gameState.player.gold = 200;
            gameState.player.shards = retainedShards;  // ä¿ç•™ç¢ç‰‡
            gameState.player.atk = classData.atk;
            gameState.player.def = classData.def;
            gameState.player.crit = classData.crit;
            gameState.player.critDmg = classData.critDmg;
            gameState.player.dmgRed = 0;
            gameState.player.lifeSteal = 0;
            gameState.player.armorPen = 0;
            gameState.player.bossDmg = 0;
            gameState.player.equipment = {
                weapon: null,
                armor: null,
                accessory1: null,
                accessory2: null
            };
            gameState.player.buffs = [];
            gameState.player.classBonus = {};
            
            // ä¿ç•™è·æ¥­ã€æŠ€èƒ½ã€åç¨±
            gameState.player.class = savedClass;
            gameState.player.skill = savedSkill;
            gameState.player.name = savedName;
            
            // é‡ç½®å€åŸŸé€²åº¦
            gameState.region = 0;
            gameState.battleProgress = 0;
            
            // é‡ç½®èƒŒåŒ…
            gameState.inventory = [];
            
            // é‡ç½®çµ±è¨ˆï¼ˆä¿ç•™ç¸½éŠæˆ²æ™‚é–“ï¼‰
            const oldStartTime = gameState.stats.startTime;
            gameState.stats = {
                kills: 0,
                items: 0,
                startTime: Date.now(),
                legendaryItems: 0,
                currentWinStreak: 0,
                maxWinStreak: 0
            };
            
            // é—œé–‰æ¨¡æ…‹è¦–çª—
            closeIterationModal();
            
            // æ›´æ–°UI
            updateUI();
            updateEquipmentSlots();
            
            // é¡¯ç¤ºè¨Šæ¯
            addLog('ç³»çµ±', `âœ¨ è¿­ä»£å®Œæˆï¼`);
            addLog('ç³»çµ±', `ğŸ“ ç²å¾— ${ip} é»è¿­ä»£é»æ•¸ï¼`);
            addLog('ç³»çµ±', `ğŸ”· ä¿ç•™ ${retainedShards} ç¢ç‰‡ï¼`);
            addLog('ç³»çµ±', `ğŸ† ç²å¾—ç¨±è™Ÿï¼š${getIterationTitle(gameState.iteration.count)}`);
            addLog('ç³»çµ±', `æ­¡è¿å›åˆ°æ•¸ä½æ·±æ·µï¼é–‹å§‹ä½ çš„ç¬¬ ${gameState.iteration.count} æ¬¡è¿­ä»£ä¹‹æ—…ï¼`);
            
            // è‡ªå‹•å­˜æª”
            saveGame();
        }
        
        // ========== å¤©è³¦ç³»çµ±å‡½æ•¸ ==========
        
        let currentTalentTab = 'combat';
        
        function openTalentsModal() {
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('talents-iteration-count').textContent = gameState.iteration.count || 0;
            document.getElementById('talents-available-ip').textContent = gameState.iteration.availableIP || 0;
            document.getElementById('talents-total-ip').textContent = gameState.iteration.totalIP || 0;
            
            // é¡¯ç¤ºç¬¬ä¸€å€‹åˆ†é 
            switchTalentTab('combat');
            
            // é¡¯ç¤ºæ¨¡æ…‹è¦–çª—
            document.getElementById('talents-modal').style.display = 'flex';
        }
        
        function closeTalentsModal() {
            document.getElementById('talents-modal').style.display = 'none';
        }
        
        // ========== åœ–é‘‘UIå‡½æ•¸ ==========
        
        let currentCodexTab = 'monsters';
        
        function openCodexModal() {
            // ç¢ºä¿åœ–é‘‘ç³»çµ±å·²åˆå§‹åŒ–
            if (!gameState.codex || Object.keys(gameState.codex.monsters).length === 0) {
                initCodexSystem();
            }
            
            currentCodexTab = 'monsters';
            switchCodexTab('monsters');
            document.getElementById('codex-modal').style.display = 'flex';
        }
        
        function closeCodexModal() {
            document.getElementById('codex-modal').style.display = 'none';
        }
        
        function switchCodexTab(tab) {
            currentCodexTab = tab;
            
            // æ›´æ–°æ¨™ç±¤æ¨£å¼
            const tabs = ['monsters', 'equipment', 'companions', 'cards'];
            tabs.forEach(t => {
                const btn = document.getElementById(`codex-tab-${t}`);
                if (t === tab) {
                    btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    btn.style.color = 'white';
                    btn.style.fontWeight = 'bold';
                } else {
                    btn.style.background = 'rgba(255, 255, 255, 0.1)';
                    btn.style.color = '#7a8fb8';
                    btn.style.fontWeight = 'normal';
                }
            });
            
            // æ›´æ–°é€²åº¦
            updateCodexProgress(tab);
            
            // æ›´æ–°å…§å®¹
            if (tab === 'monsters') {
                renderMonstersCodex();
            } else if (tab === 'equipment') {
                renderEquipmentCodex();
            } else if (tab === 'companions') {
                renderCompanionsCodex();
            } else if (tab === 'cards') {
                renderCardsCodex();
            }
        }
        
        function updateCodexProgress(category) {
            const progress = getCodexProgress(category);
            document.getElementById('codex-progress-text').textContent = `${progress.unlocked}/${progress.total} (${progress.percentage}%)`;
            document.getElementById('codex-progress-bar').style.width = `${progress.percentage}%`;
        }
        
        function renderMonstersCodex() {
            const content = document.getElementById('codex-content');
            let html = '';
            
            // æŒ‰å€åŸŸåˆ†çµ„
            const regions = {};
            for (const monsterName in gameState.codex.monsters) {
                const monster = gameState.codex.monsters[monsterName];
                if (!regions[monster.region]) {
                    regions[monster.region] = [];
                }
                regions[monster.region].push(monster);
            }
            
            // æ¸²æŸ“æ¯å€‹å€åŸŸ
            for (const regionName in regions) {
                const monsters = regions[regionName];
                const regionProgress = monsters.filter(m => m.unlocked).length;
                const regionTotal = monsters.length;
                
                html += `
                    <div style="background: rgba(0, 217, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.2); margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #00d9ff; margin: 0;">${regionName}</h3>
                            <span style="color: #7a8fb8; font-size: 0.9rem;">${regionProgress}/${regionTotal}</span>
                        </div>
                `;
                
                // æ¸²æŸ“æ€ªç‰©
                monsters.forEach(monster => {
                    const unlocked = monster.unlocked;
                    const isBoss = monster.type === 'boss';
                    const isElite = monster.type === 'elite';
                    let bgColor, borderColor;
                    if (isBoss) {
                        bgColor = 'rgba(255, 0, 0, 0.1)';
                        borderColor = 'rgba(255, 0, 0, 0.3)';
                    } else if (isElite) {
                        bgColor = 'rgba(255, 165, 0, 0.1)';
                        borderColor = 'rgba(255, 165, 0, 0.3)';
                    } else {
                        bgColor = 'rgba(255, 255, 255, 0.05)';
                        borderColor = 'rgba(255, 255, 255, 0.1)';
                    }
                    
                    html += `
                        <div style="background: ${bgColor}; padding: 10px; border-radius: 6px; border: 1px solid ${borderColor}; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: ${unlocked ? '#00d9ff' : '#555'}; margin-bottom: 5px;">
                                        ${monster.icon} ${unlocked ? monster.name : '???'}
                                        ${isBoss ? '<span style="color: #ff4444; font-size: 0.8rem; margin-left: 5px;">[BOSS]</span>' : ''}
                                        ${isElite ? '<span style="color: #ffa500; font-size: 0.8rem; margin-left: 5px;">[ç²¾è‹±]</span>' : ''}
                                    </div>
                                    ${unlocked ? `
                                        <div style="color: #7a8fb8; font-size: 0.85rem;">
                                            æ“Šæ®ºæ•¸ï¼š<span style="color: #00d9ff; font-weight: bold;">${monster.killCount}</span> æ¬¡
                                        </div>
                                        <div style="margin-top: 8px;">
                                            ${renderMonsterRewards(monster)}
                                        </div>
                                    ` : `
                                        <div style="color: #555; font-size: 0.85rem;">å°šæœªè§£é–</div>
                                    `}
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
            
            content.innerHTML = html;
        }
        
        function renderMonsterRewards(monster) {
            const milestones = [10, 50, 100, 500, 1000];
            let html = '<div style="display: flex; gap: 5px; flex-wrap: wrap;">';
            
            milestones.forEach(milestone => {
                const reached = monster.killCount >= milestone;
                const collected = monster.rewardsCollected.includes(milestone);
                const reward = getMonsterReward(monster.type, milestone);
                
                let btnStyle = '';
                let btnText = '';
                let btnOnclick = '';
                
                if (collected) {
                    btnStyle = 'background: rgba(0, 255, 0, 0.2); color: #4CAF50; border: 1px solid rgba(0, 255, 0, 0.3); cursor: default;';
                    btnText = `âœ… ${milestone}`;
                    btnOnclick = '';
                } else if (reached) {
                    btnStyle = 'background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; cursor: pointer;';
                    btnText = `ğŸ ${milestone}`;
                    btnOnclick = `onclick="claimMonsterReward('${monster.name}', ${milestone}); renderMonstersCodex();"`;
                } else {
                    btnStyle = 'background: rgba(255, 255, 255, 0.05); color: #555; border: 1px solid rgba(255, 255, 255, 0.1); cursor: default;';
                    btnText = `ğŸ”’ ${milestone}`;
                    btnOnclick = '';
                }
                
                let rewardText = [];
                if (reward.gold > 0) rewardText.push(`ğŸ’°${reward.gold}`);
                if (reward.exp > 0) rewardText.push(`â­${reward.exp}`);
                if (reward.shards > 0) rewardText.push(`ğŸ’${reward.shards}`);
                if (reward.item) rewardText.push(`ğŸ${reward.item}`);
                if (reward.title) rewardText.push(`ğŸ†ç¨±è™Ÿ`);
                
                html += `
                    <button ${btnOnclick} style="padding: 6px 10px; border-radius: 5px; font-size: 0.8rem; ${btnStyle}" title="${rewardText.join(', ')}">
                        ${btnText}
                    </button>
                `;
            });
            
            html += '</div>';
            return html;
        }
        
        function renderEquipmentCodex() {
            const content = document.getElementById('codex-content');
            let html = '';
            
            // æŒ‰å€åŸŸåˆ†çµ„é¡¯ç¤ºå¥—è£è£å‚™
            const regions = ['å…¥é–€é–‹ç™¼å±¤', 'ç ”ç™¼æ ¸å¿ƒå±¤', 'è³‡æ–™è£‚ç¸«', 'æ·±äº•è‡¨ç•Œå±¤'];
            
            regions.forEach(regionName => {
                // ç²å–è©²å€åŸŸçš„æ‰€æœ‰è£å‚™
                const set1Equipment = Object.values(gameState.codex.equipment).filter(e => e.region === regionName && e.setNumber === 1);
                const set2Equipment = Object.values(gameState.codex.equipment).filter(e => e.region === regionName && e.setNumber === 2);
                
                if (set1Equipment.length === 0 && set2Equipment.length === 0) return;
                
                // å€åŸŸæ¨™é¡Œ
                html += `
                    <div style="background: rgba(0, 217, 255, 0.08); padding: 15px; border-radius: 10px; border: 2px solid rgba(0, 217, 255, 0.3); margin-bottom: 20px;">
                        <h2 style="color: #00d9ff; margin: 0 0 15px 0; text-align: center;">ğŸ¯ ${regionName}</h2>
                `;
                
                // ç¬¬ä¸€å¥—
                if (set1Equipment.length > 0) {
                    const obtained1 = set1Equipment.filter(e => e.obtained).length;
                    const total1 = set1Equipment.length;
                    const setName1 = set1Equipment[0].setName;
                    
                    html += `
                        <div style="background: rgba(255, 215, 0, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); margin-bottom: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="color: #FFD700; font-weight: bold;">â‘  ${setName1}</div>
                                <span style="color: #7a8fb8; font-size: 0.9rem;">${obtained1}/${total1}</span>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px;">
                    `;
                    
                    set1Equipment.forEach(equipment => {
                        const obtained = equipment.obtained;
                        html += `
                            <div style="background: ${obtained ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.3)'}; padding: 8px; border-radius: 6px; border: 1px solid ${obtained ? 'rgba(255, 215, 0, 0.4)' : 'rgba(255, 255, 255, 0.1)'}; text-align: center;">
                                <div style="font-size: 1.3rem; margin-bottom: 5px;">${equipment.icon}</div>
                                <div style="font-size: 0.8rem; color: ${obtained ? '#FFD700' : '#555'}; font-weight: bold;">
                                    ${obtained ? equipment.name : '???'}
                                </div>
                                ${obtained ? `
                                    <div style="font-size: 0.7rem; color: #7a8fb8; margin-top: 3px;">
                                        ç²å¾— ${equipment.obtainCount} æ¬¡
                                    </div>
                                ` : `
                                    <div style="font-size: 0.7rem; color: #555; margin-top: 3px;">å°šæœªç²å¾—</div>
                                `}
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                // ç¬¬äºŒå¥—
                if (set2Equipment.length > 0) {
                    const obtained2 = set2Equipment.filter(e => e.obtained).length;
                    const total2 = set2Equipment.length;
                    const setName2 = set2Equipment[0].setName;
                    
                    html += `
                        <div style="background: rgba(138, 43, 226, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <div style="color: #9370DB; font-weight: bold;">â‘¡ ${setName2}</div>
                                <span style="color: #7a8fb8; font-size: 0.9rem;">${obtained2}/${total2}</span>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px;">
                    `;
                    
                    set2Equipment.forEach(equipment => {
                        const obtained = equipment.obtained;
                        html += `
                            <div style="background: ${obtained ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.3)'}; padding: 8px; border-radius: 6px; border: 1px solid ${obtained ? 'rgba(138, 43, 226, 0.4)' : 'rgba(255, 255, 255, 0.1)'}; text-align: center;">
                                <div style="font-size: 1.3rem; margin-bottom: 5px;">${equipment.icon}</div>
                                <div style="font-size: 0.8rem; color: ${obtained ? '#9370DB' : '#555'}; font-weight: bold;">
                                    ${obtained ? equipment.name : '???'}
                                </div>
                                ${obtained ? `
                                    <div style="font-size: 0.7rem; color: #7a8fb8; margin-top: 3px;">
                                        ç²å¾— ${equipment.obtainCount} æ¬¡
                                    </div>
                                ` : `
                                    <div style="font-size: 0.7rem; color: #555; margin-top: 3px;">å°šæœªç²å¾—</div>
                                `}
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                }
                
                html += `
                    </div>
                `;
            });
            
            content.innerHTML = html;
        }
        
        function renderCompanionsCodex() {
            const content = document.getElementById('codex-content');
            let html = '';
            
            // æŒ‰é¡å‹åˆ†çµ„
            const typeGroups = {
                'attack': { name: 'æ”»æ“Šå‹', icon: 'âš”ï¸', companions: [] },
                'defense': { name: 'é˜²ç¦¦å‹', icon: 'ğŸ›¡ï¸', companions: [] },
                'heal': { name: 'æ¢å¾©å‹', icon: 'â¤ï¸', companions: [] },
                'balance': { name: 'å¹³è¡¡å‹', icon: 'âš–ï¸', companions: [] }
            };
            
            // åˆ†çµ„éš¨å¾
            for (const companionId in gameState.codex.companions) {
                const companion = gameState.codex.companions[companionId];
                const companionData = COMPANIONS[companionId];
                if (companionData && typeGroups[companionData.type]) {
                    typeGroups[companionData.type].companions.push({ ...companion, data: companionData });
                }
            }
            
            // æ¸²æŸ“æ¯å€‹é¡å‹
            for (const typeKey in typeGroups) {
                const group = typeGroups[typeKey];
                if (group.companions.length === 0) continue;
                
                const obtainedCount = group.companions.filter(c => c.obtained).length;
                const totalCount = group.companions.length;
                
                html += `
                    <div style="background: rgba(0, 217, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.2); margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #00d9ff; margin: 0;">${group.icon} ${group.name}</h3>
                            <span style="color: #7a8fb8; font-size: 0.9rem;">${obtainedCount}/${totalCount}</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                `;
                
                group.companions.forEach(companion => {
                    const obtained = companion.obtained;
                    const rarityColor = getRarityColor(companion.rarity);
                    
                    html += `
                        <div style="background: ${obtained ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.3)'}; padding: 10px; border-radius: 6px; border: 1px solid ${obtained ? rarityColor : 'rgba(255, 255, 255, 0.1)'};">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <div style="font-size: 2rem;">${obtained ? companion.data.icon : 'â“'}</div>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: ${obtained ? rarityColor : '#555'}; margin-bottom: 3px;">
                                        ${obtained ? companion.name : '???'}
                                    </div>
                                    ${obtained ? `
                                        <div style="font-size: 0.75rem; color: #7a8fb8;">
                                            ${companion.data.description}
                                        </div>
                                    ` : `
                                        <div style="font-size: 0.75rem; color: #555;">å°šæœªç²å¾—</div>
                                    `}
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            if (html === '') {
                html = '<div style="color: #7a8fb8; text-align: center; padding: 20px;">æ²’æœ‰éš¨å¾æ•¸æ“š</div>';
            }
            content.innerHTML = html;
        }
        
        function renderCardsCodex() {
            const content = document.getElementById('codex-content');
            let html = '';
            
            // æŒ‰ç³»åˆ—åˆ†çµ„
            const seriesGroups = {};
            
            for (const cardId in gameState.codex.cards) {
                const card = gameState.codex.cards[cardId];
                const cardData = CARDS[cardId];
                if (!cardData) continue;
                
                const series = cardData.series || 'å…¶ä»–';
                if (!seriesGroups[series]) {
                    seriesGroups[series] = [];
                }
                seriesGroups[series].push({ ...card, data: cardData });
            }
            
            // æ¸²æŸ“æ¯å€‹ç³»åˆ—
            for (const series in seriesGroups) {
                const cards = seriesGroups[series];
                const obtainedCount = cards.filter(c => c.obtained).length;
                const totalCount = cards.length;
                
                html += `
                    <div style="background: rgba(0, 217, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.2); margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="color: #00d9ff; margin: 0;">ğŸ´ ${series}ç³»åˆ—</h3>
                            <span style="color: #7a8fb8; font-size: 0.9rem;">${obtainedCount}/${totalCount}</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px;">
                `;
                
                cards.forEach(card => {
                    const obtained = card.obtained;
                    const rarityColor = getRarityColor(card.rarity);
                    
                    html += `
                        <div style="background: ${obtained ? 'rgba(255, 255, 255, 0.05)' : 'rgba(0, 0, 0, 0.3)'}; padding: 10px; border-radius: 6px; border: 1px solid ${obtained ? rarityColor : 'rgba(255, 255, 255, 0.1)'};">
                            <div style="text-align: center; margin-bottom: 5px;">
                                <div style="font-size: 2rem;">${obtained ? card.data.icon : 'â“'}</div>
                            </div>
                            <div style="font-weight: bold; color: ${obtained ? rarityColor : '#555'}; text-align: center; margin-bottom: 5px;">
                                ${obtained ? card.name : '???'}
                            </div>
                            ${obtained ? `
                                <div style="font-size: 0.75rem; color: #7a8fb8; text-align: center;">
                                    ${card.data.description}
                                </div>
                            ` : `
                                <div style="font-size: 0.75rem; color: #555; text-align: center;">å°šæœªç²å¾—</div>
                            `}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            if (html === '') {
                html = '<div style="color: #7a8fb8; text-align: center; padding: 20px;">æ²’æœ‰å¡ç‰Œæ•¸æ“š</div>';
            }
            
            content.innerHTML = html;
        }
        
        // ========== æ¯æ—¥ä»»å‹™UIå‡½æ•¸ ==========
        function openTitlesModal() {
            document.getElementById('titles-modal').style.display = 'flex';
            // ä½¿ç”¨ setTimeout ç¢ºä¿ DOM å·²ç¶“é¡¯ç¤º
            setTimeout(() => {
                updateTitlesUI();
            }, 0);
        }
        
        function closeTitlesModal() {
            document.getElementById('titles-modal').style.display = 'none';
        }
        
        let currentTitleCategory = 'all'; // ç¨±è™Ÿåˆ†é¡ç‹€æ…‹
        
        function switchTitleCategory(category) {
            currentTitleCategory = category;
            
            // æ›´æ–°åˆ†é¡æ¨£å¼
            document.querySelectorAll('.title-category-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`title-cat-${category}`).classList.add('active');
            
            // æ¸²æŸ“ç¨±è™Ÿå…§å®¹
            renderTitles(category);
        }
        
        function updateTitlesUI() {
            // æ›´æ–°ç•¶å‰ç¨±è™Ÿé¡¯ç¤º
            const equippedTitle = gameState.titles.equipped;
            if (equippedTitle) {
                const titleData = TITLES_DATA[equippedTitle];
                if (titleData) {
                    document.getElementById('current-title-display').textContent = titleData.name;
                    document.getElementById('current-title-display').style.color = getTitleRarityColor(titleData.rarity);
                    
                    // é¡¯ç¤ºåŠ æˆ
                    let bonusText = '';
                    for (const [attr, value] of Object.entries(titleData.bonus)) {
                        const attrName = {
                            maxHp: 'ç”Ÿå‘½',
                            atk: 'æ”»æ“Š',
                            def: 'é˜²ç¦¦',
                            crit: 'æš´æ“Š',
                            critDmg: 'æš´å‚·',
                            goldBonus: 'é‡‘å¹£',
                            expBonus: 'ç¶“é©—',
                            shardBonus: 'ç¢ç‰‡'
                        }[attr] || attr;
                        bonusText += `${attrName}+${value}% `;
                    }
                    document.getElementById('current-title-bonus').textContent = bonusText;
                } else {
                    document.getElementById('current-title-display').textContent = 'ç„¡';
                    document.getElementById('current-title-bonus').textContent = '';
                }
            } else {
                document.getElementById('current-title-display').textContent = 'ç„¡';
                document.getElementById('current-title-display').style.color = '#FFD700';
                document.getElementById('current-title-bonus').textContent = '';
            }
            
            // æ¸²æŸ“ç¨±è™Ÿåˆ—è¡¨
            switchTitleCategory(currentTitleCategory);
        }
        
        function renderTitles(category) {
            const container = document.getElementById('titles-content');
            
            // å°‡ TITLES_DATA ç‰©ä»¶è½‰æ›ç‚ºé™£åˆ—ï¼Œä¸¦åŠ ä¸Š id å±¬æ€§
            let titlesArray = Object.entries(TITLES_DATA).map(([id, data]) => ({
                id: id,
                ...data
            }));
            
            // éæ¿¾ç¨±è™Ÿ
            let titlesToShow = titlesArray;
            if (category !== 'all') {
                if (category === 'codex') {
                    // åœ–é‘‘é¡åˆ¥åŒ…å«æ‰€æœ‰ codex_ é–‹é ­çš„ç¨±è™Ÿ
                    titlesToShow = titlesArray.filter(t => t.category && t.category.startsWith('codex_'));
                } else {
                    titlesToShow = titlesArray.filter(t => t.category === category);
                }
            }
            
            let html = '';
            titlesToShow.forEach(title => {
                const isUnlocked = gameState.titles.unlocked.includes(title.id);
                const isEquipped = gameState.titles.equipped === title.id;
                const rarityClass = `title-rarity-${title.rarity}`;
                const lockedClass = isUnlocked ? '' : 'locked';
                const equippedClass = isEquipped ? 'equipped' : '';
                
                // ç²å–é€²åº¦è³‡è¨Š
                let progressText = '';
                if (!isUnlocked && title.condition) {
                    const progress = getTitleProgress(title);
                    progressText = `<div style="font-size: 0.75rem; color: #888; margin-top: 5px;">${progress}</div>`;
                }
                
                // ç²å–åŠ æˆè³‡è¨Š
                let bonusText = '';
                for (const [attr, value] of Object.entries(title.bonus)) {
                    const attrName = {
                        maxHp: 'ç”Ÿå‘½',
                        atk: 'æ”»æ“Š',
                        def: 'é˜²ç¦¦',
                        crit: 'æš´æ“Š',
                        critDmg: 'æš´å‚·',
                        goldBonus: 'é‡‘å¹£',
                        expBonus: 'ç¶“é©—',
                        shardBonus: 'ç¢ç‰‡'
                    }[attr] || attr;
                    bonusText += `${attrName}+${value}% `;
                }
                
                // ç²å–æ–¹æ³•èªªæ˜
                let howToGetText = '';
                if (!isUnlocked && title.howToGet) {
                    howToGetText = `<div style="font-size: 0.7rem; color: #66ccff; margin-top: 5px; padding: 5px; background: rgba(78, 165, 255, 0.1); border-radius: 3px; border-left: 2px solid #4EA5FF;">ğŸ’¡ ç²å–æ–¹æ³•ï¼š${title.howToGet}</div>`;
                }
                
                html += `
                    <div class="title-card ${rarityClass} ${lockedClass} ${equippedClass}" 
                         onclick="${isUnlocked ? `equipTitle('${title.id}')` : ''}" 
                         style="${!isUnlocked ? 'cursor: not-allowed;' : ''}">
                        <div class="title-name">${isUnlocked ? title.name : 'ï¼Ÿï¼Ÿï¼Ÿ'}</div>
                        <div style="font-size: 0.75rem; color: #7a8fb8; margin: 5px 0;">${isUnlocked ? title.desc : 'æœªè§£é–'}</div>
                        <div style="font-size: 0.85rem; color: #4EA5FF; margin-top: 5px;">${bonusText}</div>
                        ${progressText}
                        ${howToGetText}
                        ${isEquipped ? '<div style="margin-top: 5px; color: #FFD700; font-weight: bold;">â˜… å·²è£å‚™</div>' : ''}
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function getTitleRarityColor(rarity) {
            const colors = {
                common: '#c8c8c8',
                rare: '#4EA5FF',
                epic: '#a335ee',
                legendary: '#FFD700'
            };
            return colors[rarity] || '#fff';
        }
        
        function getTitleProgress(title) {
            if (!title.condition) return '';
            
            const cond = title.condition;
            const progress = gameState.titles.progress;
            
            if (cond.type === 'kills') {
                const current = progress.totalKills || 0;
                return `æ“Šæ®º: ${current}/${cond.value}`;
            } else if (cond.type === 'level') {
                return `ç­‰ç´š: ${gameState.level}/${cond.value}`;
            } else if (cond.type === 'gold') {
                const current = progress.totalGoldEarned || 0;
                return `é‡‘å¹£: ${current}/${cond.value}`;
            } else if (cond.type === 'shards') {
                const current = progress.totalShardsEarned || 0;
                return `ç¢ç‰‡: ${current}/${cond.value}`;
            } else if (cond.type === 'iterations') {
                return `è¿­ä»£: ${gameState.iteration.count}/${cond.value}`;
            } else if (cond.type === 'playtime') {
                const current = progress.totalPlaytime || 0;
                const hours = Math.floor(current / 3600);
                return `éŠæˆ²æ™‚é–“: ${hours}/${cond.value}å°æ™‚`;
            } else if (cond.type === 'quests') {
                const current = progress.totalQuestsCompleted || 0;
                return `ä»»å‹™: ${current}/${cond.value}`;
            } else if (cond.type === 'bosses') {
                const current = progress.bossesKilled || 0;
                return `Boss: ${current}/${cond.value}`;
            } else if (cond.type === 'equipment') {
                const current = progress.legendaryEquipped || 0;
                return `å‚³èªªè£å‚™: ${current}/${cond.value}`;
            } else if (cond.type === 'talents') {
                let totalTalentLevel = 0;
                for (const level of Object.values(gameState.iteration.talents)) {
                    totalTalentLevel += level;
                }
                return `å¤©è³¦ç­‰ç´š: ${totalTalentLevel}/${cond.value}`;
            } else if (cond.type === 'migration') {
                // é·ç§»ç¨±è™Ÿçš„ç‰¹æ®Šè™•ç†
                if (cond.value === 'v2_iteration_optimized') {
                    return 'èˆŠå­˜æª”é·ç§»è‡³ v2.0 å³å¯è§£é–';
                } else if (cond.value === 'v2_pioneer') {
                    return 'Lv.15+ èˆŠå­˜æª”é·ç§»è‡³ v2.0 å³å¯è§£é–';
                } else if (cond.value === 'v2_iteration_vanguard') {
                    return 'Lv.50+ èˆŠå­˜æª”é·ç§»è‡³ v2.0 å³å¯è§£é–';
                }
                return 'ç‰¹æ®Šæ¢ä»¶è§£é–';
            }
            
            return '';
        }
        

        
        function switchTalentTab(tabName) {
            currentTalentTab = tabName;
            
            // æ›´æ–°åˆ†é æ¨£å¼
            document.querySelectorAll('.talent-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.getElementById(`talent-tab-${tabName}`).classList.add('active');
            
            // æ¸²æŸ“å¤©è³¦å…§å®¹
            renderTalents(tabName);
        }
        
        function renderTalents(seriesName) {
            const series = ITERATION_TALENTS[seriesName];
            if (!series) return;
            
            const container = document.getElementById('talents-content');
            let html = `<h3 style="color: #4EA5FF; margin-bottom: 15px;">${series.name}</h3>`;
            
            for (const [talentId, talent] of Object.entries(series.talents)) {
                const currentLevel = gameState.iteration.talents[talentId] || 0;
                const isMaxLevel = currentLevel >= talent.maxLevel;
                const nextCost = isMaxLevel ? 0 : talent.cost[currentLevel];
                const canUpgrade = !isMaxLevel && (gameState.iteration.availableIP || 0) >= nextCost;
                
                // è¨ˆç®—ç•¶å‰æ•ˆæœ
                const currentEffect = currentLevel > 0 ? talent.effect(currentLevel) : {};
                const nextEffect = !isMaxLevel ? talent.effect(currentLevel + 1) : {};
                
                html += `
                    <div class="talent-card ${isMaxLevel ? 'max-level' : ''}">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <div style="font-size: 1.1rem; font-weight: bold; color: ${isMaxLevel ? '#FFD700' : '#4EA5FF'}; margin-bottom: 5px;">
                                    ${talent.name}
                                    <span style="font-size: 0.9rem; color: #7a8fb8; margin-left: 8px;">
                                        Lv.${currentLevel}/${talent.maxLevel}
                                    </span>
                                </div>
                                <div style="color: #7a8fb8; font-size: 0.85rem; margin-bottom: 8px;">${talent.desc}</div>
                            </div>
                        </div>
                        
                        ${currentLevel > 0 ? `
                            <div style="background: rgba(78, 165, 255, 0.1); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                                <div style="color: #4EA5FF; font-size: 0.85rem; font-weight: bold; margin-bottom: 4px;">âœ… ç•¶å‰æ•ˆæœï¼š</div>
                                <div style="color: #7a8fb8; font-size: 0.8rem;">${formatTalentEffect(currentEffect)}</div>
                            </div>
                        ` : ''}
                        
                        ${!isMaxLevel ? `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="color: #7a8fb8; font-size: 0.85rem;">
                                    ä¸‹ä¸€ç´šï¼š${formatTalentEffect(nextEffect)}
                                </div>
                                <button 
                                    class="talent-upgrade-btn" 
                                    onclick="upgradeTalent('${seriesName}', '${talentId}')"
                                    ${!canUpgrade ? 'disabled' : ''}
                                >
                                    ${canUpgrade ? `â¬†ï¸ å‡ç´š (${nextCost} IP)` : `ğŸ”’ éœ€è¦ ${nextCost} IP`}
                                </button>
                            </div>
                        ` : `
                            <div style="text-align: center; color: #FFD700; font-weight: bold; padding: 8px; background: rgba(255, 215, 0, 0.1); border-radius: 6px;">
                                â­ å·²æ»¿ç´š
                            </div>
                        `}
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function formatTalentEffect(effect) {
            const parts = [];
            if (effect.atk) parts.push(`æ”»æ“Š+${effect.atk}%`);
            if (effect.def) parts.push(`é˜²ç¦¦+${effect.def}%`);
            if (effect.hp) parts.push(`ç”Ÿå‘½+${effect.hp}%`);
            if (effect.crit) parts.push(`æš´æ“Šç‡+${effect.crit}%`);
            if (effect.critDmg) parts.push(`æš´æ“Šå‚·å®³+${effect.critDmg}%`);
            if (effect.bossDmg) parts.push(`Bosså‚·å®³+${effect.bossDmg}%`);
            if (effect.dmgRed) parts.push(`æ¸›å‚·+${effect.dmgRed}%`);
            if (effect.lifeSteal) parts.push(`å¸è¡€+${effect.lifeSteal}%`);
            if (effect.goldBonus) parts.push(`é‡‘å¹£+${effect.goldBonus}%`);
            if (effect.expBonus) parts.push(`ç¶“é©—+${effect.expBonus}%`);
            if (effect.dropBonus) parts.push(`æ‰è½ç‡+${effect.dropBonus}%`);
            if (effect.shardBonus) parts.push(`ç¢ç‰‡+${effect.shardBonus}%`);
            if (effect.maxAp) parts.push(`æœ€å¤§é«”åŠ›+${effect.maxAp}`);
            if (effect.apRegenSpeed) parts.push(`é«”åŠ›å›å¾©-${effect.apRegenSpeed}%`);
            if (effect.bagSize) parts.push(`èƒŒåŒ…+${effect.bagSize}æ ¼`);
            if (effect.startGold) parts.push(`èµ·å§‹é‡‘å¹£+${effect.startGold}`);
            return parts.join('ã€');
        }
        
        function upgradeTalent(seriesName, talentId) {
            const talent = ITERATION_TALENTS[seriesName].talents[talentId];
            const currentLevel = gameState.iteration.talents[talentId] || 0;
            
            // æª¢æŸ¥æ˜¯å¦å·²æ»¿ç´š
            if (currentLevel >= talent.maxLevel) {
                alert('å¤©è³¦å·²æ»¿ç´šï¼');
                return;
            }
            
            // æª¢æŸ¥IPæ˜¯å¦è¶³å¤ 
            const cost = talent.cost[currentLevel];
            if ((gameState.iteration.availableIP || 0) < cost) {
                alert(`IPä¸è¶³ï¼éœ€è¦ ${cost} IP`);
                return;
            }
            
            // æ¶ˆè€—IP
            gameState.iteration.availableIP -= cost;
            
            // å‡ç´šå¤©è³¦
            gameState.iteration.talents[talentId] = currentLevel + 1;
            
            // æ‡‰ç”¨å¤©è³¦æ•ˆæœ
            applyTalentBonuses();
            
            // æ›´æ–°é¡¯ç¤º
            document.getElementById('talents-available-ip').textContent = gameState.iteration.availableIP;
            renderTalents(seriesName);
            updateUI();
            
            // é¡¯ç¤ºè¨Šæ¯
            addLog('å¤©è³¦', `âœ¨ ${talent.name} å‡ç´šåˆ° Lv.${currentLevel + 1}ï¼`);
            
            // å­˜æª”
            saveGame();
        }
        
        function applyTalentBonuses() {
            // é‡ç½®å¤©è³¦åŠ æˆ
            let bonuses = {
                atk: 0, def: 0, hp: 0, crit: 0, critDmg: 0, bossDmg: 0,
                dmgRed: 0, lifeSteal: 0, goldBonus: 0, expBonus: 0,
                dropBonus: 0, shardBonus: 0, maxAp: 0, bagSize: 0, startGold: 0
            };
            
            // éæ­·æ‰€æœ‰å¤©è³¦
            for (const seriesName in ITERATION_TALENTS) {
                const series = ITERATION_TALENTS[seriesName];
                for (const talentId in series.talents) {
                    const level = gameState.iteration.talents[talentId] || 0;
                    if (level > 0) {
                        const talent = series.talents[talentId];
                        const effect = talent.effect(level);
                        for (const key in effect) {
                            bonuses[key] = (bonuses[key] || 0) + effect[key];
                        }
                    }
                }
            }
            
            // æ‡‰ç”¨åŠ æˆåˆ°ç©å®¶å±¬æ€§
            // ç™¾åˆ†æ¯”åŠ æˆ
            const baseStats = getBaseStats();
            if (bonuses.atk) gameState.player.atk = Math.floor(baseStats.atk * (1 + bonuses.atk / 100));
            if (bonuses.def) gameState.player.def = Math.floor(baseStats.def * (1 + bonuses.def / 100));
            if (bonuses.hp) {
                const newMaxHp = Math.floor(baseStats.hp * (1 + bonuses.hp / 100));
                const hpRatio = gameState.player.hp / gameState.player.maxHp;
                gameState.player.maxHp = newMaxHp;
                gameState.player.hp = Math.floor(newMaxHp * hpRatio);
            }
            if (bonuses.crit) gameState.player.crit = baseStats.crit + bonuses.crit;
            if (bonuses.critDmg) gameState.player.critDmg = baseStats.critDmg + bonuses.critDmg;
            
            // ç›´æ¥åŠ æˆ
            if (bonuses.bossDmg) gameState.player.bossDmg = (gameState.player.bossDmg || 0) + bonuses.bossDmg;
            if (bonuses.dmgRed) gameState.player.dmgRed = (gameState.player.dmgRed || 0) + bonuses.dmgRed;
            if (bonuses.lifeSteal) gameState.player.lifeSteal = (gameState.player.lifeSteal || 0) + bonuses.lifeSteal;
            
            // é«”åŠ›ä¸Šé™
            if (bonuses.maxAp) {
                const oldMaxAp = gameState.player.maxAp;
                gameState.player.maxAp = 100 + bonuses.maxAp;
                // å¦‚æœç•¶å‰APç­‰æ–¼èˆŠçš„æœ€å¤§å€¼ï¼Œä¹Ÿå¢åŠ ç•¶å‰AP
                if (gameState.player.ap === oldMaxAp) {
                    gameState.player.ap = gameState.player.maxAp;
                }
            }
            
            // å„²å­˜å…¶ä»–åŠ æˆä¾›å…¶ä»–ç³»çµ±ä½¿ç”¨
            gameState.talentBonuses = bonuses;
        }
        
        function getBaseStats() {
            // ç²å–åŸºç¤å±¬æ€§ï¼ˆä¸å«å¤©è³¦åŠ æˆï¼‰
            const classData = CLASSES[gameState.player.class];
            const level = gameState.player.level;
            
            return {
                atk: classData.atk + (level - 1) * 2,
                def: classData.def + (level - 1) * 1,
                hp: classData.hp + (level - 1) * 10,
                crit: classData.crit,
                critDmg: classData.critDmg
            };
        }
        
        // åœ¨è®€å–å­˜æª”å¾Œæ‡‰ç”¨å¤©è³¦åŠ æˆ
        function applyTalentBonusesOnLoad() {
            // ç©ºå‡½æ•¸ï¼Œä¿ç•™ä»¥ä¾¿æœªä¾†æ“´å±•
        }

        // ========== æ¯æ—¥ä»»å‹™ç³»çµ± ==========
        
        // ç”Ÿæˆæ¯æ—¥ä»»å‹™
        function generateDailyQuests() {
            const quests = [];
            const pool = [...DAILY_QUEST_POOL];
            
            // éš¨æ©Ÿé¸æ“‡5å€‹ä»»å‹™
            for (let i = 0; i < 5 && pool.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * pool.length);
                const quest = { ...pool[randomIndex], progress: 0 };
                quests.push(quest);
                pool.splice(randomIndex, 1);
            }
            
            return quests;
        }
        
        // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®æ¯æ—¥ä»»å‹™
        function checkDailyQuestReset() {
            // å®‰å…¨æª¢æŸ¥ï¼šå¦‚æœæ¯æ—¥ä»»å‹™æœªåˆå§‹åŒ–ï¼Œå…ˆåˆå§‹åŒ–
            if (!gameState.dailyQuests) {
                resetDailyQuests();
                return true;
            }
            
            const now = new Date();
            const lastReset = new Date(gameState.dailyQuests.lastReset || 0);
            
            // æª¢æŸ¥æ˜¯å¦æ˜¯ä¸åŒçš„æ—¥æœŸï¼ˆæ¯”è¼ƒå¹´æœˆæ—¥ï¼‰
            if (now.getFullYear() !== lastReset.getFullYear() ||
                now.getMonth() !== lastReset.getMonth() ||
                now.getDate() !== lastReset.getDate()) {
                resetDailyQuests();
                return true;
            }
            return false;
        }
        
        // é‡ç½®æ¯æ—¥ä»»å‹™
        function resetDailyQuests() {
            // ä¿å­˜èˆŠçš„totalCompleted
            const oldTotalCompleted = (gameState.dailyQuests && gameState.dailyQuests.totalCompleted) ? gameState.dailyQuests.totalCompleted : 0;
            
            // è¨˜éŒ„ä»Šå¤© 00:00 çš„æ™‚é–“æˆ³
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            gameState.dailyQuests = {
                lastReset: today.getTime(),
                quests: generateDailyQuests(),
                completed: [],
                rewardsClaimed: {
                    three: false,
                    five: false
                },
                refreshCount: 3, // æ¯æ—¥é‡ç½®3æ¬¡
                totalCompleted: oldTotalCompleted
            };
            addLog('ç³»çµ±', 'ğŸ“‹ æ¯æ—¥ä»»å‹™å·²é‡ç½®ï¼');
            saveGame();
        }
        
        // æ›´æ–°ä»»å‹™é€²åº¦
        function updateQuestProgress(type, value = 1, replaceMode = false) {
            if (!gameState.dailyQuests || !gameState.dailyQuests.quests) return;
            
            let updated = false;
            gameState.dailyQuests.quests.forEach(quest => {
                // è·³éå·²å®Œæˆçš„ä»»å‹™
                if (gameState.dailyQuests.completed && gameState.dailyQuests.completed.includes(quest.id)) return;
                
                // æª¢æŸ¥ä»»å‹™é¡å‹æ˜¯å¦åŒ¹é…
                if (quest.type === type) {
                    const oldProgress = quest.progress || 0;
                    
                    // æ ¹æ“šæ¨¡å¼æ›´æ–°é€²åº¦
                    if (replaceMode) {
                        // æ›¿æ›æ¨¡å¼ï¼šç”¨æ–¼è¨˜éŒ„æœ€å¤§å€¼ï¼ˆå¦‚ç„¡ç›¡æ¨¡å¼å±¤æ•¸ï¼‰
                        quest.progress = Math.max(oldProgress, Math.min(value, quest.target));
                    } else if (type === 'win_streak') {
                        // é€£å‹ä»»å‹™ç‰¹æ®Šè™•ç†ï¼šç›´æ¥è¨­å®šç‚ºç•¶å‰é€£å‹æ•¸ï¼Œä¸ç´¯åŠ 
                        quest.progress = Math.min(value, quest.target);
                    } else {
                        // ç´¯åŠ æ¨¡å¼ï¼šæ­£å¸¸ç´¯åŠ é€²åº¦
                        quest.progress = Math.min(oldProgress + value, quest.target);
                    }
                    
                    updated = true;
                    
                    // é¡¯ç¤ºä»»å‹™é€²åº¦æ›´æ–°
                    if (quest.progress !== oldProgress) {
                        addLog('ä»»å‹™', `ğŸ“‹ ${quest.name}: ${quest.progress}/${quest.target}`);
                        
                        // æª¢æŸ¥æ˜¯å¦å®Œæˆ
                        if (quest.progress >= quest.target) {
                            addLog('ä»»å‹™', `âœ… ä»»å‹™å®Œæˆï¼š${quest.name}ï¼è«‹é»æ“Šä»»å‹™é¢æ¿é ˜å–çå‹µï¼`);
                        }
                    }
                }
            });
            
            if (updated) {
                updateDailyQuestsUI();
            }
        }
        
        // å®Œæˆä»»å‹™
        function completeQuest(quest) {
            // æ¨™è¨˜ç‚ºå·²å®Œæˆ
            gameState.dailyQuests.completed.push(quest.id);
            gameState.dailyQuests.totalCompleted++;
            
            // çµ¦äºˆçå‹µ
            if (quest.rewards.gold > 0) {
                gameState.player.gold += quest.rewards.gold;
                addLog('ä»»å‹™', `ğŸ’° ç²å¾— ${quest.rewards.gold} é‡‘å¹£`);
            }
            if (quest.rewards.shards > 0) {
                gameState.player.shards += quest.rewards.shards;
                addLog('ä»»å‹™', `ğŸ”· ç²å¾— ${quest.rewards.shards} ç¢ç‰‡`);
            }
            if (quest.rewards.exp > 0) {
                gameState.player.exp += quest.rewards.exp;
                // æª¢æŸ¥å‡ç´š
                if (gameState.player.exp >= gameState.player.expToNext) {
                    levelUp();
                }
            }
            
            addLog('ä»»å‹™', `âœ… å®Œæˆä»»å‹™ï¼š${quest.name}`);
            
            // æª¢æŸ¥å®Œæˆåº¦çå‹µ
            checkQuestMilestones();
            
            // æª¢æŸ¥ç¨±è™Ÿ
            checkTitleUnlock('quests_completed', gameState.dailyQuests.totalCompleted);
            
            // æ›´æ–°UI
            updateDailyQuestsUI();
            updateUI();
            saveGame();
            
            // æ’­æ”¾éŸ³æ•ˆ
            playSound('item');
        }
        
        // æª¢æŸ¥å®Œæˆåº¦çå‹µ
        function checkQuestMilestones() {
            const completed = gameState.dailyQuests.completed.length;
            
            // å®Œæˆ3å€‹ä»»å‹™
            if (completed >= 3 && !gameState.dailyQuests.rewardsClaimed.three) {
                gameState.dailyQuests.rewardsClaimed.three = true;
                gameState.player.gold += 200;
                gameState.player.shards += 3;
                addLog('ä»»å‹™', 'ğŸ å®Œæˆåº¦çå‹µï¼š200ğŸ’° + 3ğŸ”·');
            }
            
            // å®Œæˆ5å€‹ä»»å‹™
            if (completed >= 5 && !gameState.dailyQuests.rewardsClaimed.five) {
                gameState.dailyQuests.rewardsClaimed.five = true;
                gameState.player.gold += 500;
                gameState.player.shards += 10;
                gameState.player.exp += 500;
                addLog('ä»»å‹™', 'ğŸ å…¨éƒ¨å®Œæˆçå‹±ï¼š500ğŸ’° + 10ğŸ”· + 500EXP');
                
                // æª¢æŸ¥å‡ç´š
                if (gameState.player.exp >= gameState.player.expToNext) {
                    levelUp();
                }
            }
        }
        
        // æ‰“é–‹æ¯æ—¥ä»»å‹™é¢æ¿
        function openDailyQuestsModal() {
            // æª¢æŸ¥æ˜¯å¦éœ€è¦é‡ç½®
            checkDailyQuestReset();
            
            // å¦‚æœæ²’æœ‰ä»»å‹™ï¼Œç”Ÿæˆæ–°ä»»å‹™
            if (!gameState.dailyQuests.quests || gameState.dailyQuests.quests.length === 0) {
                gameState.dailyQuests.quests = generateDailyQuests();
            }
            
            // ç¢ºä¿refreshCountå­˜åœ¨ï¼ˆå…¼å®¹èˆŠå­˜æª”ï¼‰
            if (gameState.dailyQuests.refreshCount === undefined) {
                gameState.dailyQuests.refreshCount = 3;
            }
            
            updateDailyQuestsUI();
            document.getElementById('daily-quests-modal').style.display = 'flex';
        }
        
        function closeDailyQuestsModal() {
            document.getElementById('daily-quests-modal').style.display = 'none';
        }
        
        // æ›´æ–°æ¯æ—¥ä»»å‹™UI
        function updateDailyQuestsUI() {
            const container = document.getElementById('daily-quests-list');
            if (!container) return;
            
            const quests = gameState.dailyQuests.quests || [];
            const completed = gameState.dailyQuests.completed || [];
            
            let html = '<div class="quest-progress-bar">';
            html += `<div class="quest-progress-text">ä»Šæ—¥é€²åº¦ï¼š${completed.length}/5</div>`;
            html += `<div class="quest-progress-fill" style="width: ${completed.length * 20}%"></div>`;
            html += '</div>';
            
            // é‡ç½®æ¬¡æ•¸é¡¯ç¤º
            const refreshCount = gameState.dailyQuests.refreshCount || 0;
            html += '<div style="text-align: center; margin: 10px 0; padding: 8px; background: rgba(0, 217, 255, 0.08); border-radius: 6px; border: 1px solid rgba(0, 217, 255, 0.3);">';
            html += `<span style="color: #7a8fb8;">ğŸ”„ ä»Šæ—¥å‰©é¤˜é‡ç½®æ¬¡æ•¸ï¼š</span>`;
            html += `<span style="color: #00d9ff; font-weight: bold; font-size: 1.1rem;">${refreshCount}/3</span>`;
            html += '</div>';
            
            // å®Œæˆåº¦çå‹µ
            html += '<div class="quest-milestones">';
            html += '<div class="quest-milestone">';
            html += `<span class="${completed.length >= 3 ? 'completed' : ''}">å®Œæˆ3å€‹</span>`;
            html += '<span class="quest-milestone-reward">200ğŸ’° + 3ğŸ”·</span>';
            if (gameState.dailyQuests.rewardsClaimed.three) {
                html += '<span class="quest-claimed">âœ… å·²é ˜å–</span>';
            } else if (completed.length >= 3) {
                html += '<button onclick="claimMilestoneReward(3)" style="padding: 4px 12px; background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%); color: #0a1628; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: bold;">ğŸ é ˜å–</button>';
            }
            html += '</div>';
            html += '<div class="quest-milestone">';
            html += `<span class="${completed.length >= 5 ? 'completed' : ''}">å®Œæˆ5å€‹</span>`;
            html += '<span class="quest-milestone-reward">500ğŸ’° + 10ğŸ”· + 500EXP</span>';
            if (gameState.dailyQuests.rewardsClaimed.five) {
                html += '<span class="quest-claimed">âœ… å·²é ˜å–</span>';
            } else if (completed.length >= 5) {
                html += '<button onclick="claimMilestoneReward(5)" style="padding: 4px 12px; background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%); color: #0a1628; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: bold;">ğŸ é ˜å–</button>';
            }
            html += '</div>';
            html += '</div>';
            
            // ä»»å‹™åˆ—è¡¨
            html += '<div class="quest-list">';
            quests.forEach(quest => {
                const isCompleted = completed.includes(quest.id);
                const isAccepted = quest.accepted === true; // é è¨­ç‚ºæœªæ¥å–
                const progress = quest.progress || 0;
                const progressPercent = Math.min((progress / quest.target) * 100, 100);
                const canClaim = progress >= quest.target && !isCompleted;
                
                html += `<div class="quest-card ${isCompleted ? 'completed' : ''}">`;
                html += `<div class="quest-header">`;
                html += `<span class="quest-name">${quest.name}</span>`;
                html += `<span class="quest-difficulty ${quest.difficulty}">${getDifficultyText(quest.difficulty)}</span>`;
                html += `</div>`;
                html += `<div class="quest-desc">${quest.desc}</div>`;
                
                if (isAccepted) {
                    // å·²æ¥å–ï¼šé¡¯ç¤ºé€²åº¦
                    html += `<div class="quest-progress-container">`;
                    html += `<div class="quest-progress-bar-small">`;
                    html += `<div class="quest-progress-fill-small" style="width: ${progressPercent}%"></div>`;
                    html += `</div>`;
                    html += `<span class="quest-progress-text-small">${progress}/${quest.target}</span>`;
                    html += `</div>`;
                }
                
                html += `<div class="quest-rewards">`;
                if (quest.rewards.gold > 0) html += `<span>ğŸ’° ${quest.rewards.gold}</span>`;
                if (quest.rewards.shards > 0) html += `<span>ğŸ”· ${quest.rewards.shards}</span>`;
                if (quest.rewards.exp > 0) html += `<span>â­ ${quest.rewards.exp}</span>`;
                html += `</div>`;
                
                // ä»»å‹™ç‹€æ…‹å’ŒæŒ‰éˆ•
                html += '<div style="display: flex; gap: 8px; margin-top: 8px;">';
                
                if (isCompleted) {
                    html += `<div class="quest-completed-badge" style="flex: 1; margin: 0;">âœ… å·²å®Œæˆ</div>`;
                } else if (canClaim) {
                    html += `<button onclick="claimQuestReward('${quest.id}')" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%); color: #0a1628; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">ğŸ é ˜å–çå‹µ</button>`;
                } else if (!isAccepted) {
                    // æœªæ¥å–ï¼šé¡¯ç¤ºæ¥å–å’Œæ›´æ–°æŒ‰éˆ•
                    html += `<button onclick="acceptQuest('${quest.id}')" style="flex: 1; padding: 8px; background: linear-gradient(135deg, #00d9ff 0%, #0099cc 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">ğŸ“‹ æ¥å–ä»»å‹™</button>`;
                    
                    // æ›´æ–°ä»»å‹™æŒ‰éˆ•ï¼ˆåªåœ¨æœªæ¥å–æ™‚é¡¯ç¤ºï¼‰
                    if (gameState.dailyQuests.refreshCount > 0) {
                        html += `<button onclick="refreshQuest('${quest.id}')" style="padding: 8px 12px; background: linear-gradient(135deg, #ff9800 0%, #ff5722 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; white-space: nowrap;">ğŸ”„ æ›´æ–°</button>`;
                    }
                }
                
                html += '</div>';
                
                html += `</div>`;
            });
            html += '</div>';
            
            container.innerHTML = html;
            
            // æ›´æ–°é‡ç½®æ™‚é–“é¡¯ç¤ºï¼ˆé ‚éƒ¨ï¼‰
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 0, 0);
            const timeLeft = Math.max(0, tomorrow.getTime() - now.getTime());
            const hoursLeft = Math.floor(timeLeft / (60 * 60 * 1000));
            const minutesLeft = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
            const secondsLeft = Math.floor((timeLeft % (60 * 1000)) / 1000);
            
            const resetTimeEl = document.getElementById('quests-reset-time');
            if (resetTimeEl) {
                resetTimeEl.textContent = `${String(hoursLeft).padStart(2, '0')}:${String(minutesLeft).padStart(2, '0')}:${String(secondsLeft).padStart(2, '0')}`;
            }
            
            // æ›´æ–°ä»Šæ—¥å®Œæˆæ•¸
            const completedTodayEl = document.getElementById('quests-completed-today');
            if (completedTodayEl) {
                completedTodayEl.textContent = completed.length;
            }
        }
        
        function getDifficultyText(difficulty) {
            switch(difficulty) {
                case 'easy': return 'ç°¡å–®';
                case 'normal': return 'æ™®é€š';
                case 'hard': return 'å›°é›£';
                default: return 'æ™®é€š';
            }
        }
        
        // æ›´æ–°ä»»å‹™ï¼ˆéš¨æ©Ÿé‡ç½®ï¼‰
        function refreshQuest(questId) {
            if (!gameState.dailyQuests.refreshCount || gameState.dailyQuests.refreshCount <= 0) {
                addLog('ä»»å‹™', 'ä»Šæ—¥é‡ç½®æ¬¡æ•¸å·²ç”¨å®Œï¼');
                return;
            }
            
            const questIndex = gameState.dailyQuests.quests.findIndex(q => q.id === questId);
            if (questIndex === -1) return;
            
            // å¾ä»»å‹™æ± ä¸­éš¨æ©Ÿé¸æ“‡ä¸€å€‹æ–°ä»»å‹™
            const pool = [...DAILY_QUEST_POOL];
            const newQuest = pool[Math.floor(Math.random() * pool.length)];
            
            // æ›¿æ›ä»»å‹™
            gameState.dailyQuests.quests[questIndex] = {
                ...newQuest,
                progress: 0,
                accepted: false
            };
            
            // æ¸›å°‘é‡ç½®æ¬¡æ•¸
            gameState.dailyQuests.refreshCount--;
            
            addLog('ä»»å‹™', `ğŸ”„ å·²æ›´æ–°ä»»å‹™ï¼å‰©é¤˜é‡ç½®æ¬¡æ•¸ï¼š${gameState.dailyQuests.refreshCount}/3`);
            updateDailyQuestsUI();
            saveGame();
        }
        
        // æ¥å–ä»»å‹™
        function acceptQuest(questId) {
            const quest = gameState.dailyQuests.quests.find(q => q.id === questId);
            if (!quest) return;
            
            quest.accepted = true;
            addLog('ä»»å‹™', `ğŸ“‹ å·²æ¥å–ä»»å‹™ï¼š${quest.name}`);
            updateDailyQuestsUI();
            saveGame();
        }
        
        // é ˜å–å®Œæˆåº¦çå‹µ
        function claimMilestoneReward(count) {
            const completed = gameState.dailyQuests.completed || [];
            
            if (count === 3) {
                if (completed.length < 3) {
                    addLog('ä»»å‹™', 'é‚„æœªå®Œæˆ3å€‹ä»»å‹™ï¼');
                    return;
                }
                if (gameState.dailyQuests.rewardsClaimed.three) {
                    addLog('ä»»å‹™', 'å·²ç¶“é ˜å–éæ­¤çå‹±ï¼');
                    return;
                }
                gameState.player.gold += 200;
                gameState.player.shards += 3;
                gameState.dailyQuests.rewardsClaimed.three = true;
                addLog('ä»»å‹™', 'ğŸ é ˜å–å®Œæˆåº¦çå‹±ï¼š200ğŸ’° + 3ğŸ”·');
            } else if (count === 5) {
                if (completed.length < 5) {
                    addLog('ä»»å‹™', 'é‚„æœªå®Œæˆ5å€‹ä»»å‹™ï¼');
                    return;
                }
                if (gameState.dailyQuests.rewardsClaimed.five) {
                    addLog('ä»»å‹™', 'å·²ç¶“é ˜å–éæ­¤çå‹±ï¼');
                    return;
                }
                gameState.player.gold += 500;
                gameState.player.shards += 10;
                gameState.player.exp += 500;
                gameState.dailyQuests.rewardsClaimed.five = true;
                addLog('ä»»å‹™', 'ğŸ é ˜å–å®Œæˆåº¦çå‹±ï¼š500ğŸ’° + 10ğŸ”· + 500EXP');
                
                // æª¢æŸ¥å‡ç´š
                if (gameState.player.exp >= gameState.player.expToNext) {
                    levelUp();
                }
            }
            
            playSound('reward');
            updateDailyQuestsUI();
            updateUI();
            saveGame();
        }
        
        // é ˜å–ä»»å‹™çå‹µ
        function claimQuestReward(questId) {
            const quest = gameState.dailyQuests.quests.find(q => q.id === questId);
            if (!quest) return;
            
            const progress = quest.progress || 0;
            if (progress < quest.target) {
                addLog('ä»»å‹™', 'ä»»å‹™å°šæœªå®Œæˆï¼');
                return;
            }
            
            const completed = gameState.dailyQuests.completed || [];
            if (completed.includes(questId)) {
                addLog('ä»»å‹™', 'å·²ç¶“é ˜å–éçå‹µï¼');
                return;
            }
            
            // ç™¼æ”¾çå‹µ
            if (quest.rewards.gold > 0) {
                gameState.player.gold += quest.rewards.gold;
            }
            if (quest.rewards.shards > 0) {
                gameState.player.shards += quest.rewards.shards;
            }
            if (quest.rewards.exp > 0) {
                gameState.player.exp += quest.rewards.exp;
                // æª¢æŸ¥å‡ç´š
                if (gameState.player.exp >= gameState.player.expToNext) {
                    levelUp();
                }
            }
            
            // æ¨™è¨˜ç‚ºå·²å®Œæˆ
            gameState.dailyQuests.completed.push(questId);
            gameState.dailyQuests.totalCompleted = (gameState.dailyQuests.totalCompleted || 0) + 1;
            
            // çµ±è¨ˆä»»å‹™å®Œæˆæ•¸
            checkTitleUnlock('quests_completed', gameState.dailyQuests.totalCompleted);
            
            let rewardText = [];
            if (quest.rewards.gold > 0) rewardText.push(`${quest.rewards.gold}ğŸ’°`);
            if (quest.rewards.shards > 0) rewardText.push(`${quest.rewards.shards}ğŸ”·`);
            if (quest.rewards.exp > 0) rewardText.push(`${quest.rewards.exp}EXP`);
            
            addLog('ä»»å‹™', `ğŸ å®Œæˆä»»å‹™ï¼š${quest.name}ï¼Œçå‹±ï¼š${rewardText.join(' + ')}`);
            playSound('reward');
            
            updateDailyQuestsUI();
            updateUI();
            saveGame();
        }
        
        // ========== ç¨±è™Ÿç³»çµ± ==========
        
        // æª¢æŸ¥ç¨±è™Ÿè§£é–
        function checkTitleUnlock(type, value) {
            for (const titleId in TITLES_DATA) {
                const title = TITLES_DATA[titleId];
                
                // è·³éå·²è§£é–çš„ç¨±è™Ÿ
                if (gameState.titles.unlocked.includes(titleId)) continue;
                
                // æª¢æŸ¥æ¢ä»¶
                if (title.condition.type === type && value >= title.condition.value) {
                    unlockTitle(titleId);
                }
            }
        }
        
        // æª¢æŸ¥æ‰€æœ‰ç¨±è™Ÿè§£é–æ¢ä»¶ï¼ˆç„¡åƒæ•¸ç‰ˆæœ¬ï¼‰
        function checkTitleUnlocks() {
            if (!gameState.titles) return;
            
            const stats = gameState.stats || {};
            const player = gameState.player || {};
            
            // æª¢æŸ¥æˆ°é¬¥é¡ç¨±è™Ÿ
            checkTitleUnlock('kills', stats.kills || 0);
            checkTitleUnlock('boss_kills', stats.bossKills || 0);
            checkTitleUnlock('elite_kills', stats.eliteKills || 0);
            
            // æª¢æŸ¥æˆé•·é¡ç¨±è™Ÿ
            checkTitleUnlock('level', player.level || 1);
            checkTitleUnlock('exp_gained', stats.totalExpGained || 0);
            
            // æª¢æŸ¥è²¡å¯Œé¡ç¨±è™Ÿ
            checkTitleUnlock('gold_earned', stats.totalGoldEarned || 0);
            checkTitleUnlock('items_collected', stats.items || 0);
            checkTitleUnlock('legendary_items', stats.legendaryItems || 0);
            
            // æª¢æŸ¥æ¢ç´¢é¡ç¨±è™Ÿ
            checkTitleUnlock('battles_completed', stats.battlesCompleted || 0);
            checkTitleUnlock('regions_explored', stats.regionsExplored || 0);
            
            // æª¢æŸ¥ç‰¹æ®Šç¨±è™Ÿ
            checkTitleUnlock('iterations', gameState.iteration?.count || 0);
            checkTitleUnlock('quests_completed', gameState.dailyQuests?.totalCompleted || 0);
        }
        
        // è§£é–ç¨±è™Ÿ
        function unlockTitle(titleId) {
            const title = TITLES_DATA[titleId];
            if (!title) return;
            
            // æ·»åŠ åˆ°å·²è§£é–åˆ—è¡¨
            if (!gameState.titles.unlocked.includes(titleId)) {
                gameState.titles.unlocked.push(titleId);
                addLog('ç¨±è™Ÿ', `ğŸ† ç²å¾—ç¨±è™Ÿï¼š${title.name}`);
                
                // æ’­æ”¾éŸ³æ•ˆ
                playSound('levelup');
                
                // æ›´æ–°UI
                updateTitlesUI();
                saveGame();
            }
        }
        
        // è£å‚™ç¨±è™Ÿ
        function equipTitle(titleId) {
            if (!gameState.titles.unlocked.includes(titleId)) {
                alert('å°šæœªè§£é–æ­¤ç¨±è™Ÿï¼');
                return;
            }
            
            const title = TITLES_DATA[titleId];
            if (!title) {
                console.error(`ç¨±è™Ÿ ${titleId} ä¸å­˜åœ¨æ–¼ TITLES_DATA`);
                alert('ç¨±è™Ÿæ•¸æ“šéŒ¯èª¤ï¼');
                return;
            }
            
            // å–æ¶ˆè£å‚™
            if (gameState.titles.equipped === titleId) {
                if (confirm(`æ˜¯å¦è¦å¸ä¸‹ç¨±è™Ÿã€Œ${title.name}ã€ï¼Ÿ`)) {
                    gameState.titles.equipped = null;
                    addLog('ç¨±è™Ÿ', 'å·²å–æ¶ˆè£å‚™ç¨±è™Ÿ');
                    playSound('equip');
                    
                    // é‡æ–°è¨ˆç®—å±¬æ€§
                    recalculateStats();
                    updateUI();
                    updateTitlesUI();
                    saveGame();
                }
            } else {
                // è£å‚™æˆ–æ›´æ›ç¨±è™Ÿ
                let confirmMessage = `æ˜¯å¦è¦è£å‚™ç¨±è™Ÿã€Œ${title.name}ã€ï¼Ÿ`;
                
                // å¦‚æœå·²æœ‰è£å‚™çš„ç¨±è™Ÿï¼Œé¡¯ç¤ºæ›´æ›è¨Šæ¯
                if (gameState.titles.equipped) {
                    const currentTitle = TITLES_DATA[gameState.titles.equipped];
                    if (currentTitle) {
                        confirmMessage = `æ˜¯å¦è¦å°‡ç¨±è™Ÿå¾ã€Œ${currentTitle.name}ã€\næ›´æ›ç‚ºã€Œ${title.name}ã€ï¼Ÿ`;
                    }
                }
                
                if (confirm(confirmMessage)) {
                    gameState.titles.equipped = titleId;
                    addLog('ç¨±è™Ÿ', `è£å‚™ç¨±è™Ÿï¼š${title.name}`);
                    playSound('equip');
                    
                    // é‡æ–°è¨ˆç®—å±¬æ€§
                    recalculateStats();
                    updateUI();
                    updateTitlesUI();
                    saveGame();
                }
            }
        }
        
        // æ‡‰ç”¨ç¨±è™ŸåŠ æˆ
        function applyTitleBonuses() {
            if (!gameState.titles) return;
            const titleId = gameState.titles.equipped;
            if (!titleId) return;
            
            const title = TITLES_DATA[titleId];
            if (!title || !title.bonus) return;
            
            // æ‡‰ç”¨å±¬æ€§åŠ æˆ
            const bonus = title.bonus;
            const baseStats = getBaseStats();
            
            if (bonus.atk) gameState.player.atk += Math.floor(baseStats.atk * bonus.atk / 100);
            if (bonus.def) gameState.player.def += Math.floor(baseStats.def * bonus.def / 100);
            if (bonus.hp) {
                const hpBonus = Math.floor(baseStats.hp * bonus.hp / 100);
                gameState.player.maxHp += hpBonus;
                gameState.player.hp += hpBonus;
            }
            if (bonus.crit) gameState.player.crit += bonus.crit;
            if (bonus.critDmg) gameState.player.critDmg += bonus.critDmg;
            if (bonus.bossDmg) gameState.player.bossDmg = (gameState.player.bossDmg || 0) + bonus.bossDmg;
            if (bonus.dmgRed) gameState.player.dmgRed = (gameState.player.dmgRed || 0) + bonus.dmgRed;
            if (bonus.lifeSteal) gameState.player.lifeSteal = (gameState.player.lifeSteal || 0) + bonus.lifeSteal;
            
            // å„²å­˜åŠ æˆä¾›å…¶ä»–ç³»çµ±ä½¿ç”¨
            gameState.titleBonuses = bonus;
        }
        


        // ========== å­˜æª”ç³»çµ± ==========
        function saveGame() {
            try {
                // è¨˜éŒ„é›¢ç·šæ™‚é–“
                recordOfflineTime();
                
                // ç¢ºä¿å­˜æª”æ™‚åŒ…å«æœ€æ–°ç‰ˆæœ¬è™Ÿå’Œæ™‚é–“æˆ³
                gameState.version = GAME_VERSION;
                gameState.lastSaveTime = Date.now(); // è¨˜éŒ„å­˜æª”æ™‚é–“
                storage.setItem(SAVE_KEY, JSON.stringify(gameState));
                addLog('ç³»çµ±', 'éŠæˆ²å·²å­˜æª”ï¼');
            } catch (e) {
                addLog('ç³»çµ±', 'å­˜æª”å¤±æ•—ï¼');
            }
        }

        // è³‡æ–™é·ç§»å‡½æ•¸ï¼šè™•ç†èˆŠç‰ˆæœ¬å­˜æª”çš„ç›¸å®¹æ€§
        function migrateGameData(loadedState) {
            const savedVersion = loadedState.version || '0.0.0';
            
            // å¦‚æœæ²’æœ‰ç‰ˆæœ¬è™Ÿï¼Œè¦–ç‚ºèˆŠç‰ˆæœ¬
            if (!loadedState.version) {
                console.log('åµæ¸¬åˆ°èˆŠç‰ˆæœ¬å­˜æª”ï¼Œé€²è¡Œè³‡æ–™é·ç§»...');
                loadedState.version = GAME_VERSION;
            }
            
            // æœªä¾†ç‰ˆæœ¬æ›´æ–°æ™‚ï¼Œå¯ä»¥åœ¨é€™è£¡æ·»åŠ é·ç§»é‚è¼¯
            // ä¾‹å¦‚ï¼š
            // if (savedVersion < '1.1.0') {
            //     // é·ç§»åˆ° 1.1.0 çš„é‚è¼¯
            //     loadedState.newFeature = defaultValue;
            // }
            
	            // ç¢ºä¿å¿…è¦æ¬„ä½å­˜åœ¨
	            if (!loadedState.player.buffs) loadedState.player.buffs = [];
	            if (!loadedState.player.classBonus) loadedState.player.classBonus = {};
	            if (!loadedState.apRegenTime) loadedState.apRegenTime = Date.now();
	            if (!loadedState.hpRegenTime) loadedState.hpRegenTime = Date.now();
	            if (!loadedState.stats) {
	                loadedState.stats = {
	                    kills: 0,
	                    items: 0,
	                    startTime: Date.now()
	                };
	            }
	            
	            // ç¢ºä¿æ–°å±¬æ€§å­˜åœ¨ï¼ˆv1.1.0+ï¼‰
	            if (loadedState.player.dmgRed === undefined) loadedState.player.dmgRed = 0;
	            
	            // ç¢ºä¿è¿­ä»£ç³»çµ±å±¬æ€§å­˜åœ¨ï¼ˆv4.0+ï¼‰
	            if (!loadedState.iteration) {
	                loadedState.iteration = {
	                    count: 0,
	                    totalIP: 0,
	                    availableIP: 0,
	                    talents: {},
	                    completedBosses: []
	                };
	            }
            if (!loadedState.stats.legendaryItems) {
                loadedState.stats.legendaryItems = 0;
            }
            if (loadedState.stats.currentWinStreak === undefined) {
                loadedState.stats.currentWinStreak = 0;
            }
            if (loadedState.stats.maxWinStreak === undefined) {
                loadedState.stats.maxWinStreak = 0;
            }
	            if (loadedState.player.lifeSteal === undefined) loadedState.player.lifeSteal = 0;
	            if (loadedState.player.armorPen === undefined) loadedState.player.armorPen = 0;
	            if (loadedState.player.bossDmg === undefined) loadedState.player.bossDmg = 0;
	            
	            // ç¢ºä¿å‰¯æœ¬ç³»çµ±å±¬æ€§å­˜åœ¨
            if (!loadedState.dungeons) {
                loadedState.dungeons = {
                    records: {}
                };
            }
            if (!loadedState.dungeons.records) {
                loadedState.dungeons.records = {};
            }
            
            // é«”åŠ›ä¸Šé™æ›´æ–°ï¼šå¼·åˆ¶å°‡ maxAp è¨­ç‚º 100 (å¦‚æœèˆŠå­˜æª”ä¸æ˜¯ 100)
	            if (loadedState.player.maxAp !== 100) {
	                console.log(`é«”åŠ›ä¸Šé™å¾ ${loadedState.player.maxAp} é·ç§»è‡³ 100`);
	                loadedState.player.maxAp = 100;
	                // å¦‚æœç•¶å‰é«”åŠ›è¶…éæ–°ä¸Šé™ï¼Œå‰‡è¨­ç‚ºæ–°ä¸Šé™
	                if (loadedState.player.ap > 100) {
	                    loadedState.player.ap = 100;
	                }
	            }
	            
	            // æ·»åŠ æ–°å±¬æ€§çš„é»˜èªå€¼ï¼ˆç‰ˆæœ¬ 2.7+ï¼‰
            if (!loadedState.player.hpRegen) {
                loadedState.player.hpRegen = 0;
            }
            if (!loadedState.player.expBonus) {
                loadedState.player.expBonus = 0;
            }
            
            // ä¿®å¾©æ‰€æœ‰è£å‚™çš„hpRegenå’ŒexpBonuså­—æ®µ
            if (loadedState.inventory) {
                loadedState.inventory.forEach(item => {
                    if (item.type === 'weapon' || item.type === 'armor' || item.type === 'accessory') {
                        if (item.hpRegen === undefined) item.hpRegen = 0;
                        if (item.expBonus === undefined) item.expBonus = 0;
                    }
                });
            }
            
            // éš¨å¾ç³»çµ±é·ç§»ï¼ˆç‰ˆæœ¬ 3.0+ï¼‰
            if (!loadedState.companions) {
                loadedState.companions = {
                    owned: [],
                    active: null,
                    equipment: null,
                    shards: 0,
                    ownedEquipment: [],
                    cooldowns: {}
                };
            } else if (Array.isArray(loadedState.companions)) {
                // èˆŠç‰ˆæœ¬æ ¼å¼é·ç§»
                loadedState.companions = {
                    owned: loadedState.companions,
                    active: loadedState.activeCompanion || null,
                    equipment: null,
                    shards: 0,
                    ownedEquipment: [],
                    cooldowns: {}
                };
                delete loadedState.activeCompanion;
            }
            // ç¢ºä¿è£å‚™ç›¸é—œå­—æ®µå­˜åœ¨
            if (!loadedState.companions.ownedEquipment) {
                loadedState.companions.ownedEquipment = [];
            }
            if (loadedState.companions.equipment === undefined) {
                loadedState.companions.equipment = null;
            }
            if (loadedState.companions.shards === undefined) {
                loadedState.companions.shards = 0;
            }
            // ç¢ºä¿éš¨å¾ç³»çµ±å­å±¬æ€§å­˜åœ¨
            if (!loadedState.companions.owned) loadedState.companions.owned = [];
            if (loadedState.companions.active === undefined) loadedState.companions.active = null;
            if (!loadedState.companions.cooldowns) loadedState.companions.cooldowns = {};
            
            // é›¢ç·šæ”¶ç›Šç³»çµ±é·ç§»ï¼ˆç‰ˆæœ¬ 3.1+ï¼‰
            if (!loadedState.offline) {
                loadedState.offline = {
                    lastOnlineTime: Date.now(),
                    totalOfflineTime: 0,
                    rewardsClaimed: true,
                    stats: {
                        totalGoldEarned: 0,
                        totalExpEarned: 0,
                        claimCount: 0
                    }
                };
            }
            // ç¢ºä¿é›¢ç·šç³»çµ±å­å±¬æ€§å­˜åœ¨
            if (!loadedState.offline.lastOnlineTime) loadedState.offline.lastOnlineTime = Date.now();
            if (!loadedState.offline.totalOfflineTime) loadedState.offline.totalOfflineTime = 0;
            if (loadedState.offline.rewardsClaimed === undefined) loadedState.offline.rewardsClaimed = true;
            if (!loadedState.offline.stats) {
                loadedState.offline.stats = {
                    totalGoldEarned: 0,
                    totalExpEarned: 0,
                    claimCount: 0
                };
            }
            
            // å¡ç‰Œç³»çµ±é·ç§»ï¼ˆç‰ˆæœ¬ 3.2+ï¼‰
            if (!loadedState.cards) {
                loadedState.cards = {
                    slot1: null,
                    slot2: null,
                    collection: [],
                    shards: {},
                    stats: {
                        totalCardsObtained: 0,
                        totalCardsUpgraded: 0,
                        deckEffectsTriggered: 0
                    }
                };
            }
            // ç¢ºä¿å¡ç‰Œç³»çµ±å­å±¬æ€§å­˜åœ¨
            if (loadedState.cards.slot1 === undefined) loadedState.cards.slot1 = null;
            if (loadedState.cards.slot2 === undefined) loadedState.cards.slot2 = null;
            if (!loadedState.cards.collection) loadedState.cards.collection = [];
            if (!loadedState.cards.shards) loadedState.cards.shards = {};
            if (!loadedState.cards.stats) {
                loadedState.cards.stats = {
                    totalCardsObtained: 0,
                    totalCardsUpgraded: 0,
                    deckEffectsTriggered: 0
                };
            }
            
            // ä¿®å¾©å·²è£å‚™çš„è£å‚™
            if (loadedState.player.equipment) {
                Object.values(loadedState.player.equipment).forEach(item => {
                    if (item) {
                        if (item.hpRegen === undefined) item.hpRegen = 0;
                        if (item.expBonus === undefined) item.expBonus = 0;
                    }
                });
            }
            
            // ç¢ºä¿Ÿluckå’ŒgoldBonuså±¬æ€§å­˜åœ¨ï¼ˆv1.1.0+ï¼‰
            if (loadedState.player.luck === undefined) {
                loadedState.player.luck = 0;
            }
            if (loadedState.player.goldBonus === undefined) {
                loadedState.player.goldBonus = 0;
            }
            
            // æ•™å­¸ç³»çµ±å·²ç§»é™¤
            
            // ç¢ºä¿è‡ªå‹•å–è—¥ç›¸é—œå±¬æ€§å­˜åœ¨
            if (loadedState.autoPotion === undefined) {
                loadedState.autoPotion = false;
            }
            if (loadedState.autoPotionThreshold === undefined) {
                loadedState.autoPotionThreshold = 50;
            }
            if (loadedState.autoPotionMode === undefined) {
                loadedState.autoPotionMode = 'economy';
            }
            if (loadedState.autoPotionType === undefined) {
                loadedState.autoPotionType = 'best';
            }
            if (loadedState.potionCooldown === undefined) {
                loadedState.potionCooldown = 0;
            }
            
            // ç¢ºä¿endlessModeå±¬æ€§å­˜åœ¨
            if (!loadedState.endlessMode) {
                loadedState.endlessMode = {
                    unlocked: false,
                    active: false,
                    currentFloor: 1,
                    highestFloor: 0,
                    checkpoint: 1,
                    buffs: [],
                    stats: {
                        totalKills: 0,
                        totalGold: 0,
                        totalFloors: 0,
                        totalRuns: 0,
                        averageFloor: 0
                    }
                };
            }
            
            // ========== ç¶“é©—å€¼å„ªåŒ–é·ç§»å’Œè£œå„Ÿç³»çµ± (v2.0) ==========
            if (!loadedState.migration) {
                loadedState.migration = {};
            }
            
            // v2.0 é·ç§»ä»£ç¢¼å·²ç§»é™¤
            
            // ========== å¡ç‰Œ UUID é·ç§» (v3.0) ==========
            // ç‚ºèˆŠå­˜æª”ä¸­æ²’æœ‰ UUID çš„å¡ç‰Œæ·»åŠ  UUID
            if (loadedState.cards && loadedState.cards.collection) {
                let needsMigration = false;
                loadedState.cards.collection.forEach(card => {
                    if (!card.uuid) {
                        card.uuid = Date.now() + Math.random();
                        needsMigration = true;
                    }
                });
                
                // å¦‚æœ slot1/slot2 å­˜å„²çš„æ˜¯èˆŠçš„ IDï¼Œè½‰æ›ç‚º UUID
                if (needsMigration) {
                    // è½‰æ› slot1
                    if (loadedState.cards.slot1 && typeof loadedState.cards.slot1 === 'string') {
                        const card1 = loadedState.cards.collection.find(c => c.id === loadedState.cards.slot1);
                        if (card1) {
                            loadedState.cards.slot1 = card1.uuid;
                        } else {
                            loadedState.cards.slot1 = null;
                        }
                    }
                    
                    // è½‰æ› slot2
                    if (loadedState.cards.slot2 && typeof loadedState.cards.slot2 === 'string') {
                        const card2 = loadedState.cards.collection.find(c => c.id === loadedState.cards.slot2);
                        if (card2) {
                            loadedState.cards.slot2 = card2.uuid;
                        } else {
                            loadedState.cards.slot2 = null;
                        }
                    }
                    
                    console.log('âœ… å¡ç‰Œ UUID é·ç§»å®Œæˆ');
                }
            }
            
            return loadedState;
        }
        
        function loadGame() {
            try {
                const save = storage.getItem(SAVE_KEY);
                if (!save) {
                    alert('æ²’æœ‰æ‰¾åˆ°å­˜æª”ï¼');
                    return;
                }
                
                let loadedState = JSON.parse(save);
                
                // æª¢æŸ¥å­˜æª”æ™‚é–“ï¼Œæé†’ä½¿ç”¨è€…æª”æ¡ˆå¹´é½¡
                if (loadedState.lastSaveTime) {
                    const saveAge = Date.now() - loadedState.lastSaveTime;
                    const hoursAgo = Math.floor(saveAge / (1000 * 60 * 60));
                    if (hoursAgo > 0) {
                        console.log(`è®€å–åˆ° ${hoursAgo} å°æ™‚å‰çš„å­˜æª”`);
                    }
                }
                
                // åŸ·è¡Œè³‡æ–™é·ç§»
                loadedState = migrateGameData(loadedState);
                
                // è¼‰å…¥è³‡æ–™
                gameState = loadedState;
                
                // ä¿®å¾©èˆŠå­˜æª”ä¸­æ²’æœ‰quantityçš„è—¥æ°´
                fixLegacyConsumables();
                
                // åˆå§‹åŒ–åœ–é‘‘ç³»çµ±ï¼ˆç¢ºä¿èˆŠå­˜æª”ç›¸å®¹ï¼‰
                initCodexSystem();
                
                // é›¢ç·šé«”åŠ›æ¢å¾©è¨ˆç®—
                const now = Date.now();
                const offlineTime = now - (gameState.apRegenTime || now);
                // 2åˆ†é˜å›å¾©1é» (120000 æ¯«ç§’)
                const AP_REGEN_INTERVAL = 120000; // 2åˆ†é˜å›å¾©1é» 
                const apToRecover = Math.floor(offlineTime / AP_REGEN_INTERVAL);
                
                if (apToRecover > 0 && gameState.player.ap < gameState.player.maxAp) {
                    const actualRecovery = Math.min(apToRecover, gameState.player.maxAp - gameState.player.ap);
                    gameState.player.ap += actualRecovery;
                    
                    // æ›´æ–°é«”åŠ›å›å¾©æ™‚é–“æˆ³
                    gameState.apRegenTime = now - (offlineTime % AP_REGEN_INTERVAL);
                    
                    addLog('ç³»çµ±', `é›¢ç·šæœŸé–“æ¢å¾©äº† ${actualRecovery} é»é«”åŠ›ï¼`);
                } else {
                    // å³ä½¿æ²’æœ‰æ¢å¾©ï¼Œä¹Ÿè¦ç¢ºä¿æ™‚é–“æˆ³å­˜åœ¨
                    if (!gameState.apRegenTime) {
                        gameState.apRegenTime = now;
                    }
                }
                
                // é›¢ç·šç”Ÿå‘½æ¢å¾©è¨ˆç®—
                const hpOfflineTime = now - (gameState.hpRegenTime || now);
                // 5ç§’å›å¾©2%æœ€å¤§ç”Ÿå‘½ (5000 æ¯«ç§’)
                const HP_REGEN_INTERVAL = 5000; // 5ç§’å›å¾©2%æœ€å¤§ç”Ÿå‘½
                const regenCount = Math.floor(hpOfflineTime / HP_REGEN_INTERVAL);
                const hpToRecover = Math.floor(gameState.player.maxHp * 0.02 * regenCount); // æ¯æ¬¡å›å¾©2%æœ€å¤§ç”Ÿå‘½
                
                if (hpToRecover > 0 && gameState.player.hp < gameState.player.maxHp) {
                    const actualHpRecovery = Math.min(hpToRecover, gameState.player.maxHp - gameState.player.hp);
                    gameState.player.hp += actualHpRecovery;
                    
                    // æ›´æ–°ç”Ÿå‘½å›å¾©æ™‚é–“æˆ³
                    gameState.hpRegenTime = now - (hpOfflineTime % HP_REGEN_INTERVAL);
                    
                    addLog('ç³»çµ±', `é›¢ç·šæœŸé–“æ¢å¾©äº† ${actualHpRecovery} é»ç”Ÿå‘½å€¼ï¼`);
                } else {
                    // å³ä½¿æ²’æœ‰æ¢å¾©ï¼Œä¹Ÿè¦ç¢ºä¿æ™‚é–“æˆ³å­˜åœ¨
                    if (!gameState.hpRegenTime) {
                        gameState.hpRegenTime = now;
                    }
                }
                
                // éš±è—æ‰€æœ‰ç•«é¢
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('character-creation').style.display = 'none';
                
                // é¡¯ç¤ºéŠæˆ²ç•«é¢
                document.getElementById('game-main').style.display = 'block';
                
                // ç¢ºä¿æ¯æ—¥ä»»å‹™ç³»çµ±å­˜åœ¨ï¼ˆèˆŠå­˜æª”ç›¸å®¹ï¼‰
                if (!gameState.dailyQuests) {
                    gameState.dailyQuests = {
                        lastReset: Date.now(),
                        quests: [],
                        completed: [],
                        rewardsClaimed: { three: false, five: false },
                        totalCompleted: 0
                    };
                }
                
                // ç¢ºä¿ç¨±è™Ÿç³»çµ±å­˜åœ¨ï¼ˆèˆŠå­˜æª”ç›¸å®¹ï¼‰
                if (!gameState.titles) {
                    gameState.titles = {
                        unlocked: [],
                        equipped: null,
                        progress: {}
                    };
                }
                
                // æ•™å­¸ç³»çµ±å·²ç§»é™¤
                
                // æ‡‰ç”¨å¤©è³¦åŠ æˆ
                applyTalentBonusesOnLoad();
                
                updateUI();
                updateEquipmentSlots(); // æ›´æ–°è£å‚™é¡¯ç¤º
                addLog('ç³»çµ±', 'éŠæˆ²å·²è®€å–ï¼æ­¡è¿å›ä¾†ï¼Œ' + gameState.player.name + 'ï¼');
                
                // v2.0 é·ç§»é€šçŸ¥ä»£ç¢¼å·²ç§»é™¤
                
                // æª¢æŸ¥é›¢ç·šæ”¶ç›Š
                checkOfflineRewards();
                
                // è‡ªå‹•å­˜æª”ä»¥æ›´æ–°ç‰ˆæœ¬è™Ÿ
                saveGame();
            } catch (e) {
                console.error(e);
                alert('è®€å–å­˜æª”å¤±æ•—ï¼' + e.message);
            }
        }
        
        // ========== å­˜æª”åŒ¯å‡º/åŒ¯å…¥åŠŸèƒ½ ==========
        function exportSave() {
            try {
                // ç¢ºä¿æœ€æ–°è³‡æ–™å·²å­˜æª”
                gameState.version = GAME_VERSION;
                const saveData = JSON.stringify(gameState, null, 2);
                
                // å»ºç«‹ä¸‹è¼‰é€£çµ
                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // ä½¿ç”¨ç©å®¶åç¨±å’Œæ™‚é–“æˆ³ä½œç‚ºæª”å
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                a.download = `darui_save_${gameState.player.name}_${timestamp}.json`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                addLog('ç³»çµ±', 'å­˜æª”å·²åŒ¯å‡ºï¼');
            } catch (e) {
                console.error(e);
                addLog('ç³»çµ±', 'åŒ¯å‡ºå¤±æ•—ï¼');
            }
        }
        
        function importSave() {
            // è§¸ç™¼æª”æ¡ˆé¸æ“‡
            document.getElementById('import-file-input').click();
        }
        
        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // é©—è­‰è³‡æ–™æ ¼å¼
                    if (!importedData.player || !importedData.player.name) {
                        alert('ç„¡æ•ˆçš„å­˜æª”æª”æ¡ˆï¼');
                        return;
                    }
                    
                    // åŸ·è¡Œè³‡æ–™é·ç§»
                    const migratedData = migrateGameData(importedData);
                    
                    // è¼‰å…¥è³‡æ–™
                    gameState = migratedData;
                    
                    // æ›´æ–°æ™‚é–“æˆ³
                    gameState.lastSaveTime = Date.now();
                    
                    // å­˜å…¥ localStorage
                    storage.setItem(SAVE_KEY, JSON.stringify(gameState));
                    
                    // æ›´æ–°ç•Œé¢
                    document.getElementById('start-screen').style.display = 'none';
                    document.getElementById('character-creation').style.display = 'none';
                    document.getElementById('game-main').style.display = 'block';
                    
                    updateUI();
                    addLog('ç³»çµ±', 'å­˜æª”å·²åŒ¯å…¥ï¼æ­¡è¿å›ä¾†ï¼Œ' + gameState.player.name + 'ï¼');
                } catch (e) {
                    console.error(e);
                    alert('åŒ¯å…¥å¤±æ•—ï¼' + e.message);
                }
            };
            reader.readAsText(file);
         	        // æ¸…é™¤è¼¸å…¥æ¬„ä½ä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥é¸æ“‡åŒä¸€æª”æ¡ˆ
	        event.target.value = '';
	    }
	    
	    // ========== è‡ªå‹•å­˜æª”åŠŸèƒ½ ==========
	    // ç›£è½ç¶²é é—œé–‰æˆ–é›¢é–‹äº‹ä»¶ï¼Œåœ¨ç©å®¶é›¢é–‹å‰è‡ªå‹•å­˜æª”
	    window.addEventListener('beforeunload', (event) => {
	        // åªæœ‰åœ¨éŠæˆ²ä¸»ç•«é¢é¡¯ç¤ºæ™‚æ‰åŸ·è¡Œè‡ªå‹•å­˜æª”
	        if (document.getElementById('game-main').style.display === 'block') {
	            // ä½¿ç”¨åŒæ­¥çš„ localStorage ç¢ºä¿åœ¨é é¢å¸è¼‰å‰å®Œæˆå­˜å„²
            try {
                // ç¢ºä¿å­˜æª”æ™‚åŒ…å«æœ€æ–°ç‰ˆæœ¬è™Ÿå’Œæ™‚é–“æˆ³
                gameState.version = GAME_VERSION;
                gameState.lastSaveTime = Date.now();
                storage.setItem(SAVE_KEY, JSON.stringify(gameState));
                console.log('éŠæˆ²å·²åœ¨é›¢é–‹å‰è‡ªå‹•å­˜æª”ï¼');
	            } catch (e) {
	                console.error('è‡ªå‹•å­˜æª”å¤±æ•—ï¼', e);
	            }
	        }
	        // æ ¹æ“šè¦ç¯„ï¼Œä¸é˜»æ­¢é é¢å¸è¼‰
	    });
	    
	    // ç‚ºäº†ç¢ºä¿åœ¨æŸäº›è¡Œå‹•è£ç½®æˆ–ç‰¹å®šæƒ…æ³ä¸‹ä¹Ÿèƒ½è§¸ç™¼å­˜æª”ï¼Œ
	    // é¡å¤–ç›£è½ pagehide äº‹ä»¶ (é©ç”¨æ–¼æŸäº›ç€è¦½å™¨ï¼Œå¦‚ Safari)
	    window.addEventListener('pagehide', (event) => {
	        if (document.getElementById('game-main').style.display === 'block') {
             try {
                gameState.version = GAME_VERSION;
                gameState.lastSaveTime = Date.now();
                storage.setItem(SAVE_KEY, JSON.stringify(gameState));
                console.log('éŠæˆ²å·²åœ¨ pagehide æ™‚è‡ªå‹•å­˜æª”ï¼');
	            } catch (e) {
	                console.error('pagehide è‡ªå‹•å­˜æª”å¤±æ•—ï¼', e);
	            }
	        }
	    });
	    
	    
        // ========== å‰¯æœ¬ç³»çµ± ==========
        // ========== å‰¯æœ¬ç³»çµ±ï¼ˆä½¿ç”¨ç¾æœ‰APç³»çµ±ï¼‰==========

// å‰¯æœ¬é…ç½®æ•¸æ“š
const DUNGEONS_DATA = {
    exp: {
        id: 'exp',
        name: 'ä¿®ç…‰ä¹‹åœ°',
        type: 'exp',
        icon: 'ğŸ¯',
        description: 'å°ˆæ³¨æ–¼ä¿®ç…‰çš„å ´æ‰€ï¼Œå¯ç²å¾—å¤§é‡ç¶“é©—',
        difficulties: {
            easy: {
                id: 'exp_easy',
                name: 'ç°¡å–®',
                level: 5,
                ap: 5,
                dailyLimit: 5,
                enemy: {
                    name: 'ä¿®ç…‰å‚€å„¡',
                    hp: 300,
                    atk: 20,
                    def: 15,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 800,
                    gold: [200, 300]
                },
                firstClear: {
                    shards: 15,
                    gold: 500
                }
            },
            normal: {
                id: 'exp_normal',
                name: 'æ™®é€š',
                level: 15,
                ap: 8,
                dailyLimit: 5,
                enemy: {
                    name: 'é€²éšå‚€å„¡',
                    hp: 900,
                    atk: 40,
                    def: 30,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 2500,
                    gold: [400, 600]
                },
                firstClear: {
                    shards: 25,
                    gold: 1200
                }
            },
            hard: {
                id: 'exp_hard',
                name: 'å›°é›£',
                level: 30,
                ap: 12,
                dailyLimit: 4,
                enemy: {
                    name: 'é«˜ç´šå‚€å„¡',
                    hp: 2500,
                    atk: 80,
                    def: 60,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 7000,
                    gold: [800, 1200]
                },
                firstClear: {
                    shards: 40,
                    gold: 3000
                }
            },
            hell: {
                id: 'exp_hell',
                name: 'åœ°ç„',
                level: 50,
                ap: 18,
                dailyLimit: 3,
                enemy: {
                    name: 'ç²¾è‹±å‚€å„¡',
                    hp: 7000,
                    atk: 150,
                    def: 110,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 18000,
                    gold: [1500, 2500]
                },
                firstClear: {
                    shards: 60,
                    gold: 8000
                }
            },
            abyss: {
                id: 'exp_abyss',
                name: 'æ·±æ·µ',
                level: 70,
                ap: 25,
                dailyLimit: 2,
                enemy: {
                    name: 'çµ‚æ¥µå‚€å„¡',
                    hp: 18000,
                    atk: 280,
                    def: 200,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 45000,
                    gold: [3000, 5000]
                },
                firstClear: {
                    shards: 100,
                    gold: 20000
                }
            }
        }
    },
    gold: {
        id: 'gold',
        name: 'å¯¶è—æ´çªŸ',
        type: 'gold',
        icon: 'ğŸ’°',
        description: 'å……æ»¿è²¡å¯¶çš„æ´çªŸï¼Œå¯ç²å¾—å¤§é‡é‡‘å¹£',
        difficulties: {
            easy: {
                id: 'gold_easy',
                name: 'ç°¡å–®',
                level: 8,
                ap: 5,
                dailyLimit: 5,
                enemy: {
                    name: 'å¯¶ç®±æ€ª',
                    hp: 250,
                    atk: 15,
                    def: 10,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 300,
                    gold: [800, 1200]
                },
                firstClear: {
                    shards: 15,
                    gold: 2500
                }
            },
            normal: {
                id: 'gold_normal',
                name: 'æ™®é€š',
                level: 18,
                ap: 8,
                dailyLimit: 5,
                enemy: {
                    name: 'é»ƒé‡‘å¯¶ç®±æ€ª',
                    hp: 750,
                    atk: 35,
                    def: 25,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 900,
                    gold: [2500, 3500]
                },
                firstClear: {
                    shards: 25,
                    gold: 6000
                }
            },
            hard: {
                id: 'gold_hard',
                name: 'å›°é›£',
                level: 35,
                ap: 12,
                dailyLimit: 4,
                enemy: {
                    name: 'ç™½é‡‘å¯¶ç®±æ€ª',
                    hp: 2200,
                    atk: 70,
                    def: 50,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 2500,
                    gold: [7000, 10000]
                },
                firstClear: {
                    shards: 40,
                    gold: 15000
                }
            },
            hell: {
                id: 'gold_hell',
                name: 'åœ°ç„',
                level: 55,
                ap: 18,
                dailyLimit: 3,
                enemy: {
                    name: 'é‘½çŸ³å¯¶ç®±æ€ª',
                    hp: 6500,
                    atk: 140,
                    def: 100,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 6500,
                    gold: [18000, 25000]
                },
                firstClear: {
                    shards: 60,
                    gold: 40000
                }
            },
            abyss: {
                id: 'gold_abyss',
                name: 'æ·±æ·µ',
                level: 75,
                ap: 25,
                dailyLimit: 2,
                enemy: {
                    name: 'ç¥è©±å¯¶ç®±æ€ª',
                    hp: 17000,
                    atk: 260,
                    def: 190,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 16000,
                    gold: [45000, 60000]
                },
                firstClear: {
                    shards: 100,
                    gold: 100000
                }
            }
        }
    },
    equipment: {
        id: 'equipment',
        name: 'éºè·¡æ¢ç´¢',
        type: 'equipment',
        icon: 'âš”ï¸',
        description: 'å¤è€çš„éºè·¡ï¼Œå¯ç²å¾—é«˜å“è³ªè£å‚™',
        difficulties: {
            easy: {
                id: 'equipment_easy',
                name: 'ç°¡å–®',
                level: 10,
                ap: 8,
                dailyLimit: 4,
                enemy: {
                    name: 'éºè·¡å®ˆè¡›',
                    hp: 400,
                    atk: 30,
                    def: 20,
                    crit: 5,
                    critDmg: 150
                },
                rewards: {
                    exp: 500,
                    gold: [300, 500],
                    equipment: {
                        rarity: 'fine',
                        count: 1
                    }
                },
                firstClear: {
                    shards: 20,
                    equipment: {
                        rarity: 'rare',
                        count: 1
                    }
                }
            },
            normal: {
                id: 'equipment_normal',
                name: 'æ™®é€š',
                level: 22,
                ap: 12,
                dailyLimit: 4,
                enemy: {
                    name: 'ç²¾è‹±å®ˆè¡›',
                    hp: 1200,
                    atk: 60,
                    def: 45,
                    crit: 10,
                    critDmg: 160
                },
                rewards: {
                    exp: 1500,
                    gold: [600, 1000],
                    equipment: {
                        rarity: 'rare',
                        count: 1
                    }
                },
                firstClear: {
                    shards: 35,
                    equipment: {
                        rarity: 'epic',
                        count: 1
                    }
                }
            },
            hard: {
                id: 'equipment_hard',
                name: 'å›°é›£',
                level: 40,
                ap: 18,
                dailyLimit: 3,
                enemy: {
                    name: 'éºè·¡é ˜ä¸»',
                    hp: 3500,
                    atk: 120,
                    def: 90,
                    crit: 15,
                    critDmg: 170
                },
                rewards: {
                    exp: 4000,
                    gold: [1200, 2000],
                    equipment: {
                        rarity: 'epic',
                        count: 1
                    }
                },
                firstClear: {
                    shards: 55,
                    equipment: {
                        rarity: 'legendary',
                        count: 1
                    }
                }
            },
            hell: {
                id: 'equipment_hell',
                name: 'åœ°ç„',
                level: 60,
                ap: 25,
                dailyLimit: 2,
                enemy: {
                    name: 'éºè·¡éœ¸ä¸»',
                    hp: 9000,
                    atk: 220,
                    def: 160,
                    crit: 20,
                    critDmg: 180
                },
                rewards: {
                    exp: 10000,
                    gold: [2500, 4000],
                    equipment: {
                        rarity: 'legendary',
                        count: 1
                    }
                },
                firstClear: {
                    shards: 80,
                    equipment: {
                        rarity: 'legendary',
                        count: 2
                    }
                }
            },
            abyss: {
                id: 'equipment_abyss',
                name: 'æ·±æ·µ',
                level: 80,
                ap: 30,
                dailyLimit: 2,
                enemy: {
                    name: 'éºè·¡ç¥ç¥‡',
                    hp: 22000,
                    atk: 400,
                    def: 300,
                    crit: 25,
                    critDmg: 200
                },
                rewards: {
                    exp: 25000,
                    gold: [5000, 8000],
                    equipment: {
                        rarity: 'legendary',
                        count: 1,
                        mythicChance: 0.5
                    }
                },
                firstClear: {
                    shards: 150,
                    equipment: {
                        rarity: 'mythic',
                        count: 1
                    }
                }
            }
        }
    },
    material: {
        id: 'material',
        name: 'è³‡æºç¤¦å ´',
        type: 'material',
        icon: 'ğŸ’',
        description: 'è±å¯Œçš„è³‡æºç¤¦å ´ï¼Œå¯ç²å¾—å¼·åŒ–ææ–™',
        difficulties: {
            easy: {
                id: 'material_easy',
                name: 'ç°¡å–®',
                level: 12,
                ap: 6,
                dailyLimit: 5,
                enemy: {
                    name: 'å…ƒç´ ç”Ÿç‰©',
                    hp: 350,
                    atk: 25,
                    def: 18,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 450,
                    gold: [250, 400],
                    materials: {
                        enhanceStone: 8
                    }
                },
                firstClear: {
                    shards: 15,
                    materials: {
                        enhanceStone: 20
                    }
                }
            },
            normal: {
                id: 'material_normal',
                name: 'æ™®é€š',
                level: 25,
                ap: 10,
                dailyLimit: 5,
                enemy: {
                    name: 'é«˜ç´šå…ƒç´ ',
                    hp: 1000,
                    atk: 55,
                    def: 40,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 1300,
                    gold: [500, 800],
                    materials: {
                        enhanceStone: 15,
                        reforgeStone: 2
                    }
                },
                firstClear: {
                    shards: 30,
                    materials: {
                        enhanceStone: 40,
                        reforgeStone: 5
                    }
                }
            },
            hard: {
                id: 'material_hard',
                name: 'å›°é›£',
                level: 45,
                ap: 15,
                dailyLimit: 4,
                enemy: {
                    name: 'ç²¾è‹±å…ƒç´ ',
                    hp: 3000,
                    atk: 110,
                    def: 80,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 3500,
                    gold: [1000, 1600],
                    materials: {
                        enhanceStone: 30,
                        reforgeStone: 5
                    }
                },
                firstClear: {
                    shards: 50,
                    materials: {
                        enhanceStone: 80,
                        reforgeStone: 10
                    }
                }
            },
            hell: {
                id: 'material_hell',
                name: 'åœ°ç„',
                level: 65,
                ap: 22,
                dailyLimit: 3,
                enemy: {
                    name: 'å…ƒç´ é ˜ä¸»',
                    hp: 8000,
                    atk: 200,
                    def: 150,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 9000,
                    gold: [2000, 3200],
                    materials: {
                        enhanceStone: 60,
                        reforgeStone: 10
                    }
                },
                firstClear: {
                    shards: 75,
                    materials: {
                        enhanceStone: 150,
                        reforgeStone: 20
                    }
                }
            },
            abyss: {
                id: 'material_abyss',
                name: 'æ·±æ·µ',
                level: 85,
                ap: 28,
                dailyLimit: 2,
                enemy: {
                    name: 'å…ƒç´ å›ä¸»',
                    hp: 20000,
                    atk: 370,
                    def: 280,
                    crit: 0,
                    critDmg: 150
                },
                rewards: {
                    exp: 22000,
                    gold: [4000, 6500],
                    materials: {
                        enhanceStone: 120,
                        reforgeStone: 20
                    }
                },
                firstClear: {
                    shards: 120,
                    materials: {
                        enhanceStone: 300,
                        reforgeStone: 50
                    }
                }
            }
        }
    },
    boss: {
        id: 'boss',
        name: 'é­”ç‹åŸå ¡',
        type: 'boss',
        icon: 'ğŸ°',
        description: 'æŒ‘æˆ°å¼·å¤§çš„é­”ç‹ï¼Œç²å¾—è±åšçå‹µ',
        difficulties: {
            easy: {
                id: 'boss_easy',
                name: 'ç°¡å–®',
                level: 20,
                ap: 12,
                dailyLimit: 3,
                enemy: {
                    name: 'é­”ç‹ä¾è¡›',
                    hp: 1500,
                    atk: 50,
                    def: 35,
                    crit: 10,
                    critDmg: 160,
                    isBoss: true
                },
                rewards: {
                    exp: 2000,
                    gold: [800, 1500],
                    equipment: {
                        rarity: 'rare',
                        count: 1
                    },
                    materials: {
                        enhanceStone: 10
                    }
                },
                firstClear: {
                    shards: 40,
                    equipment: {
                        rarity: 'epic',
                        count: 1
                    }
                }
            },
            normal: {
                id: 'boss_normal',
                name: 'æ™®é€š',
                level: 35,
                ap: 18,
                dailyLimit: 2,
                enemy: {
                    name: 'é­”ç‹å°‡è»',
                    hp: 4500,
                    atk: 100,
                    def: 70,
                    crit: 15,
                    critDmg: 170,
                    isBoss: true
                },
                rewards: {
                    exp: 5000,
                    gold: [2000, 3500],
                    equipment: {
                        rarity: 'epic',
                        count: 1
                    },
                    materials: {
                        enhanceStone: 20,
                        reforgeStone: 5
                    }
                },
                firstClear: {
                    shards: 70,
                    equipment: {
                        rarity: 'legendary',
                        count: 1
                    }
                }
            },
            hard: {
                id: 'boss_hard',
                name: 'å›°é›£',
                level: 50,
                ap: 25,
                dailyLimit: 2,
                enemy: {
                    name: 'å‰¯é­”ç‹',
                    hp: 10000,
                    atk: 180,
                    def: 130,
                    crit: 20,
                    critDmg: 180,
                    isBoss: true
                },
                rewards: {
                    exp: 12000,
                    gold: [4000, 7000],
                    equipment: {
                        rarity: 'legendary',
                        count: 1
                    },
                    materials: {
                        enhanceStone: 40,
                        reforgeStone: 10
                    }
                },
                firstClear: {
                    shards: 100,
                    equipment: {
                        rarity: 'legendary',
                        count: 2
                    }
                }
            },
            hell: {
                id: 'boss_hell',
                name: 'åœ°ç„',
                level: 70,
                ap: 35,
                dailyLimit: 2,
                enemy: {
                    name: 'é­”ç‹',
                    hp: 25000,
                    atk: 320,
                    def: 230,
                    crit: 25,
                    critDmg: 200,
                    isBoss: true,
                    isSpecialBoss: true
                },
                rewards: {
                    exp: 30000,
                    gold: [8000, 15000],
                    equipment: {
                        rarity: 'legendary',
                        count: 2
                    },
                    materials: {
                        enhanceStone: 80,
                        reforgeStone: 20
                    }
                },
                firstClear: {
                    shards: 200,
                    equipment: {
                        rarity: 'legendary',
                        count: 3
                    }
                }
            },
            abyss: {
                id: 'boss_abyss',
                name: 'æ·±æ·µ',
                level: 90,
                ap: 40,
                dailyLimit: 1,
                enemy: {
                    name: 'é­”ç¥',
                    hp: 60000,
                    atk: 550,
                    def: 400,
                    crit: 30,
                    critDmg: 220,
                    isBoss: true,
                    isSpecialBoss: true
                },
                rewards: {
                    exp: 70000,
                    gold: [20000, 35000],
                    equipment: {
                        rarity: 'legendary',
                        count: 2,
                        mythicChance: 0.7
                    },
                    materials: {
                        enhanceStone: 150,
                        reforgeStone: 40
                    }
                },
                firstClear: {
                    shards: 300,
                    equipment: {
                        rarity: 'mythic',
                        count: 2
                    }
                }
            }
        }
    }
};

// é›£åº¦é¡è‰²
const DIFFICULTY_COLORS = {
    easy: '#4ade80',
    normal: '#60a5fa',
    hard: '#c084fc',
    hell: '#f87171'
};

// ========== å‰¯æœ¬ç³»çµ±æ ¸å¿ƒå‡½æ•¸ ==========

// åˆå§‹åŒ–å‰¯æœ¬æ•¸æ“šï¼ˆåœ¨éŠæˆ²åˆå§‹åŒ–æ™‚èª¿ç”¨ï¼‰
function initDungeons() {
    if (!gameState.dungeons) {
        gameState.dungeons = {
            records: {}
        };
    }
}

// æª¢æŸ¥æ¯æ—¥é‡ç½®
function checkDungeonDailyReset() {
    if (!gameState.dungeons) return;
    
    const now = Date.now();
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    
    // æª¢æŸ¥ç„¡ç›¡æ¨¡å¼æ¯æ—¥é‡ç½®
    if (gameState.endlessMode && gameState.endlessMode.lastEntryDate !== today) {
        gameState.endlessMode.dailyEntered = false;
    }
    
    for (const recordId in gameState.dungeons.records) {
        const record = gameState.dungeons.records[recordId];
        
        if (!record.lastReset) {
            record.lastReset = now;
            continue;
        }
        
        const lastResetDate = new Date(record.lastReset);
        const nowDate = new Date(now);
        
        // æª¢æŸ¥æ˜¯å¦è·¨å¤©
        if (lastResetDate.getDate() !== nowDate.getDate() || 
            lastResetDate.getMonth() !== nowDate.getMonth() || 
            lastResetDate.getFullYear() !== nowDate.getFullYear()) {
            
            record.dailyCount = 0;
            record.lastReset = now;
        }
    }
}

// ç²å–å‰¯æœ¬è¨˜éŒ„
function getDungeonRecord(dungeonId, difficulty) {
    const recordId = `${dungeonId}_${difficulty}`;
    
    if (!gameState.dungeons.records[recordId]) {
        gameState.dungeons.records[recordId] = {
            cleared: false,
            dailyCount: 0,
            totalCount: 0,
            bestTime: null,
            lastReset: Date.now()
        };
    }
    
    return gameState.dungeons.records[recordId];
}

// æª¢æŸ¥æ˜¯å¦å¯ä»¥æŒ‘æˆ°å‰¯æœ¬
function canChallengeDungeon(dungeonId, difficulty) {
    const dungeon = DUNGEONS_DATA[dungeonId];
    const difficultyData = dungeon.difficulties[difficulty];
    const record = getDungeonRecord(dungeonId, difficulty);
    
    // æª¢æŸ¥ç­‰ç´šè¦æ±‚
    if (gameState.player.level < difficultyData.level) {
        return { 
            canChallenge: false, 
            reason: `éœ€è¦ç­‰ç´š ${difficultyData.level}` 
        };
    }
    
    // æª¢æŸ¥AP
    if (gameState.player.ap < difficultyData.ap) {
        return { 
            canChallenge: false, 
            reason: `APä¸è¶³ï¼ˆéœ€è¦ ${difficultyData.ap} é»ï¼‰` 
        };
    }
    
    // æª¢æŸ¥æ¯æ—¥æ¬¡æ•¸
    if (record.dailyCount >= difficultyData.dailyLimit) {
        return { 
            canChallenge: false, 
            reason: `ä»Šæ—¥æŒ‘æˆ°æ¬¡æ•¸å·²ç”¨å®Œ` 
        };
    }
    
    return { canChallenge: true };
}

// æŒ‘æˆ°å‰¯æœ¬ï¼ˆä¸»å‡½æ•¸ï¼‰
function challengeDungeon(dungeonId, difficulty) {
    const dungeon = DUNGEONS_DATA[dungeonId];
    const difficultyData = dungeon.difficulties[difficulty];
    const record = getDungeonRecord(dungeonId, difficulty);
    
    // æª¢æŸ¥æ˜¯å¦å¯ä»¥æŒ‘æˆ°
    const checkResult = canChallengeDungeon(dungeonId, difficulty);
    if (!checkResult.canChallenge) {
        alert(checkResult.reason);
        return;
    }
    
    // ç›´æ¥é–‹å§‹æŒ‘æˆ°ï¼ˆå·²åœ¨è©³æƒ…ç•Œé¢ç¢ºèªï¼‰
    
    // æ‰£é™¤AP
    gameState.player.ap -= difficultyData.ap;
    
    // é–‹å§‹æˆ°é¬¥
    startDungeonBattle(dungeonId, difficulty, difficultyData, record);
}

// é–‹å§‹å‰¯æœ¬æˆ°é¬¥
function startDungeonBattle(dungeonId, difficulty, difficultyData, record) {
    const enemy = { 
        ...difficultyData.enemy,
        level: gameState.player.level  // æ·»åŠ æ€ªç‰©ç­‰ç´š
    };
    const battleStartTime = Date.now();
    
    // ç²å–éš¨å¾è£å‚™çµ„åˆæ•ˆæœ
    const comboEffects = getCompanionEquipmentCombo();
    
    // é—œé–‰å‰¯æœ¬ç•Œé¢
    closeDungeonDetailModal();
    closeDungeonsModal();
    
    // é¡¯ç¤ºæˆ°é¬¥æ—¥èªŒ
    addLog('å‰¯æœ¬', `ğŸ° é€²å…¥å‰¯æœ¬ï¼š${DUNGEONS_DATA[dungeonId].name} - ${difficultyData.name}`);
    addLog('å‰¯æœ¬', `âš”ï¸ é­é‡æ•µäººï¼š${enemy.name}`);
    
    // ä½¿ç”¨ç¾æœ‰æˆ°é¬¥ç³»çµ±
    showEnemyHP(enemy);
    
    let playerHp = gameState.player.hp;
    let enemyHp = enemy.hp;
    const enemyMaxHp = enemy.hp; // ä¿å­˜æ€ªç‰©æœ€å¤§è¡€é‡
    let round = 0;
    
    const battleInterval = setInterval(() => {
        round++;
        
        // ç©å®¶æ”»æ“Š
        let playerDmg = calculateDamage(gameState.player.atk, enemy.def, gameState.player.armorPen);
        const isCrit = Math.random() * 100 < gameState.player.crit;
        let finalDmg = isCrit ? Math.floor(playerDmg * gameState.player.critDmg / 100) : playerDmg;
        
        enemyHp -= finalDmg;
        
        if (isCrit) {
            addLog('æˆ°é¬¥', `ä½ é€ æˆäº† ${Math.floor(finalDmg)} é»å‚·å®³ ğŸ’¥æš´æ“Šï¼`);
            playSound('crit');
        } else {
            addLog('æˆ°é¬¥', `ä½ é€ æˆäº† ${Math.floor(finalDmg)} é»å‚·å®³`);
            playSound('attack');
        }
        
        updateEnemyHP(enemyHp, enemyMaxHp);
        
        if (enemyHp <= 0) {
            clearInterval(battleInterval);
            hideEnemyHP();
            
            const battleTime = Math.floor((Date.now() - battleStartTime) / 1000);
            
            // æˆ°é¬¥å‹åˆ©
            record.dailyCount++;
            record.totalCount++;
            
            if (!record.bestTime || battleTime < record.bestTime) {
                record.bestTime = battleTime;
            }
            
            const isFirstClear = !record.cleared;
            if (isFirstClear) {
                record.cleared = true;
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå®Œæˆå‰¯æœ¬
            updateQuestProgress('complete_dungeon', 1);
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå®Œæˆå›°é›£å‰¯æœ¬
            if (difficulty === 'hard' || difficulty === 'hell' || difficulty === 'abyss') {
                updateQuestProgress('complete_hard_dungeon', 1);
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šå®Œæˆä¸åŒé¡å‹å‰¯æœ¬
            if (!gameState.dailyQuests) gameState.dailyQuests = {};
            if (!gameState.dailyQuests.completedDungeonTypes) {
                gameState.dailyQuests.completedDungeonTypes = [];
            }
            if (!gameState.dailyQuests.completedDungeonTypes.includes(dungeonId)) {
                gameState.dailyQuests.completedDungeonTypes.push(dungeonId);
                updateQuestProgress('complete_different_dungeons', 1);
            }
            
            // è¨ˆç®—ä¸¦ç™¼æ”¾çå‹µ
            const rewards = calculateDungeonRewards(difficultyData, isFirstClear);
            applyDungeonRewards(rewards);
            
            // é¡¯ç¤ºçµç®—
            showDungeonResult(dungeonId, difficulty, rewards, battleTime, record, isFirstClear);
            
            playSound('victory');
            saveGame();
            updateUI();
            return;
        }
        
        // æ•µäººæ”»æ“Š
        let enemyDmg = calculateDamage(enemy.atk, gameState.player.def);
        
        if (gameState.player.dmgRed > 0 || comboEffects.dmgRed > 0) {
                    const totalDmgRed = gameState.player.dmgRed + (comboEffects.dmgRed * 100);
                    const dmgRedCap = Math.min(totalDmgRed, 75);
                    enemyDmg = Math.floor(enemyDmg * (1 - dmgRedCap / 100));
                }
        
        playerHp -= enemyDmg;
        gameState.player.hp = Math.max(0, playerHp);
        
        addLog('æˆ°é¬¥', `${enemy.name} é€ æˆäº† ${enemyDmg} é»å‚·å®³`);
        playSound('hit');
        
        if (playerHp <= 0) {
            clearInterval(battleInterval);
            hideEnemyHP();
            
            // æˆ°é¬¥å¤±æ•—
            addLog('å‰¯æœ¬', 'âŒ æŒ‘æˆ°å¤±æ•—ï¼');
            alert('æŒ‘æˆ°å¤±æ•—ï¼\n\nAPå·²æ¶ˆè€—ï¼Œä½†ä¸è¨ˆå…¥æŒ‘æˆ°æ¬¡æ•¸ã€‚');
            
            gameState.player.hp = gameState.player.maxHp;
            
            playSound('defeat');
            saveGame();
            updateUI();
            return;
        }
        
        updateUI();
    }, 1000);
}

// è¨ˆç®—å‰¯æœ¬çå‹µ
function calculateDungeonRewards(difficultyData, isFirstClear) {
    const rewards = {
        exp: difficultyData.rewards.exp || 0,
        gold: 0,
        equipment: [],
        materials: {
            enhanceStone: 0,
            reforgeStone: 0
        },
        shards: 0
    };
    
    // é‡‘å¹£
    if (difficultyData.rewards.gold) {
        const [min, max] = difficultyData.rewards.gold;
        rewards.gold = Math.floor(Math.random() * (max - min + 1)) + min;
    }
    
    // è£å‚™
    if (difficultyData.rewards.equipment) {
        const equipData = difficultyData.rewards.equipment;
        for (let i = 0; i < equipData.count; i++) {
            rewards.equipment.push(generateEquipmentByRarity(equipData.rarity));
        }
    }
    
    // ææ–™
    if (difficultyData.rewards.materials) {
        rewards.materials.enhanceStone = difficultyData.rewards.materials.enhanceStone || 0;
        rewards.materials.reforgeStone = difficultyData.rewards.materials.reforgeStone || 0;
    }
    
    // é¦–æ¬¡é€šé—œçå‹µ
    if (isFirstClear && difficultyData.firstClear) {
        const firstClear = difficultyData.firstClear;
        
        if (firstClear.shards) {
            rewards.shards += firstClear.shards;
        }
        
        if (firstClear.gold) {
            rewards.gold += firstClear.gold;
        }
        
        if (firstClear.equipment) {
            const equipData = firstClear.equipment;
            for (let i = 0; i < equipData.count; i++) {
                rewards.equipment.push(generateEquipmentByRarity(equipData.rarity));
            }
        }
        
        if (firstClear.materials) {
            rewards.materials.enhanceStone += firstClear.materials.enhanceStone || 0;
            rewards.materials.reforgeStone += firstClear.materials.reforgeStone || 0;
        }
    }
    
    return rewards;
}

// ç™¼æ”¾å‰¯æœ¬çå‹µ
function applyDungeonRewards(rewards) {
    // ç¶“é©—
    if (rewards.exp > 0) {
        gameState.player.exp += rewards.exp;
        // æª¢æŸ¥å‡ç´š
        while (gameState.player.exp >= gameState.player.expToNext) {
            levelUp();
        }
    }
    
    // é‡‘å¹£
    if (rewards.gold > 0) {
        gameState.player.gold += rewards.gold;
    }
    
    // ç¢ç‰‡
    if (rewards.shards > 0) {
        gameState.player.shards += rewards.shards;
        trackShardsGain(rewards.shards);
    }
    
    // è£å‚™
    for (const equipment of rewards.equipment) {
        // ä½¿ç”¨ addToInventory ä»¥è§¸ç™¼è‡ªå‹•è£å‚™
        if (addToInventory(equipment, false)) {
            gameState.stats.items++;
            if (equipment.rarity === 'legendary') {
                gameState.stats.legendaryItems++;
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç²å¾—è£å‚™
            updateQuestProgress('collect_equipment', 1);
            if (equipment.rarity === 'Rare' || equipment.rarity === 'Epic' || equipment.rarity === 'Legendary' || equipment.rarity === 'Set') {
                updateQuestProgress('collect_rare', 1);
            }
            if (equipment.rarity === 'legendary') {
                updateQuestProgress('collect_legendary', 1);
            }
        }
    }
    
    // ææ–™
    if (!gameState.materials) {
        gameState.materials = { enhanceStone: 0, reforgeStone: 0 };
    }
    if (rewards.materials.enhanceStone > 0) {
        gameState.materials.enhanceStone += rewards.materials.enhanceStone;
    }
    if (rewards.materials.reforgeStone > 0) {
        gameState.materials.reforgeStone += rewards.materials.reforgeStone;
    }
}

// æ ¹æ“šç¨€æœ‰åº¦ç”Ÿæˆè£å‚™
function generateEquipmentByRarity(rarity) {
    // ä½¿ç”¨generateItemç”Ÿæˆè£å‚™ï¼Œå‚³å…¥å°å¯«çš„ç¨€æœ‰åº¦åç¨±
    const item = generateItem('normal', rarity);
    
    // ç¢ºä¿ç¨€æœ‰åº¦æ­£ç¢ºè¨­ç½®
    if (item) {
        // generateItem å·²ç¶“æ­£ç¢ºè™•ç†ç¨€æœ‰åº¦ï¼Œä¸éœ€è¦é¢å¤–èª¿æ•´
        // åªéœ€ç¢ºä¿ rarity å­—æ®µæ˜¯å°å¯«æ ¼å¼
        item.rarity = rarity.toLowerCase();
    }
    
    return item;
}

        
        // å‰¯æœ¬UIå‡½æ•¸
        let currentDungeonId = null;
        let currentDifficulty = null;
        
        function openDungeonsModal() {
            const modal = document.getElementById('dungeons-modal');
            modal.classList.add('active');
            
            // æ›´æ–°APé¡¯ç¤º
            document.getElementById('dungeon-ap-display').textContent = `${gameState.player.ap}/${gameState.player.maxAp}`;
            
            // æª¢æŸ¥æ¯æ—¥é‡ç½®
            checkDungeonDailyReset();
            
            // æ¸²æŸ“å‰¯æœ¬åˆ—è¡¨
            renderDungeonsList();
        }
        
        function closeDungeonsModal() {
            document.getElementById('dungeons-modal').classList.remove('active');
        }
        
        function renderDungeonsList() {
            const container = document.getElementById('dungeons-list');
            let html = '';
            
            for (const dungeonId in DUNGEONS_DATA) {
                const dungeon = DUNGEONS_DATA[dungeonId];
                
                html += `
                    <div style="background: rgba(0, 217, 255, 0.05); padding: 15px; border-radius: 10px; border: 1px solid rgba(0, 217, 255, 0.3);">
                        <div style="display: flex; align-items: center; margin-bottom: 10px;">
                            <span style="font-size: 2rem; margin-right: 10px;">${dungeon.icon}</span>
                            <div>
                                <div style="font-size: 1.1rem; font-weight: bold; color: #00d9ff;">${dungeon.name}</div>
                                <div style="font-size: 0.85rem; color: #7a8fb8;">${dungeon.description}</div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 8px;">
                `;
                
                for (const difficulty in dungeon.difficulties) {
                    const diffData = dungeon.difficulties[difficulty];
                    const record = getDungeonRecord(dungeonId, difficulty);
                    const canChallenge = canChallengeDungeon(dungeonId, difficulty);
                    const remaining = diffData.dailyLimit - record.dailyCount;
                    
                    const diffColor = DIFFICULTY_COLORS[difficulty];
                    const isLocked = gameState.player.level < diffData.level;
                    
                    html += `
                        <button 
                            onclick="openDungeonDetail('${dungeonId}', '${difficulty}')"
                            style="padding: 10px; background: ${isLocked ? 'rgba(100, 100, 100, 0.3)' : `linear-gradient(135deg, ${diffColor}33 0%, ${diffColor}11 100%)`}; 
                                   border: 1px solid ${diffColor}; border-radius: 6px; cursor: ${isLocked ? 'not-allowed' : 'pointer'}; opacity: ${isLocked ? '0.5' : '1'};"
                            ${isLocked ? 'disabled' : ''}>
                            <div style="font-weight: bold; color: ${diffColor}; margin-bottom: 5px;">${diffData.name}</div>
                            <div style="font-size: 0.75rem; color: #7a8fb8;">
                                ${isLocked ? `Lv.${diffData.level}` : `${remaining}/${diffData.dailyLimit}`}
                            </div>
                        </button>
                    `;
                }
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function openDungeonDetail(dungeonId, difficulty) {
            currentDungeonId = dungeonId;
            currentDifficulty = difficulty;
            
            const dungeon = DUNGEONS_DATA[dungeonId];
            const diffData = dungeon.difficulties[difficulty];
            const record = getDungeonRecord(dungeonId, difficulty);
            
            const modal = document.getElementById('dungeon-detail-modal');
            const title = document.getElementById('dungeon-detail-title');
            const content = document.getElementById('dungeon-detail-content');
            
            title.textContent = `${dungeon.name} - ${diffData.name}`;
            
            const isFirstClear = !record.cleared;
            const remaining = diffData.dailyLimit - record.dailyCount;
            
            let rewardsHtml = '';
            if (diffData.rewards.exp) rewardsHtml += `<li>ç¶“é©—å€¼ï¼š${diffData.rewards.exp}</li>`;
            if (diffData.rewards.gold) rewardsHtml += `<li>é‡‘å¹£ï¼š${diffData.rewards.gold[0]}-${diffData.rewards.gold[1]}</li>`;
            if (diffData.rewards.equipment) rewardsHtml += `<li>è£å‚™ï¼š${diffData.rewards.equipment.rarity}å“è³ª Ã—${diffData.rewards.equipment.count}</li>`;
            if (diffData.rewards.materials) {
                if (diffData.rewards.materials.enhanceStone) rewardsHtml += `<li>å¼·åŒ–çŸ³ï¼š${diffData.rewards.materials.enhanceStone}</li>`;
                if (diffData.rewards.materials.reforgeStone) rewardsHtml += `<li>é‡é‘„çŸ³ï¼š${diffData.rewards.materials.reforgeStone}</li>`;
            }
            
            let firstClearHtml = '';
            if (isFirstClear && diffData.firstClear) {
                firstClearHtml = '<div style="background: rgba(255, 215, 0, 0.1); padding: 10px; border-radius: 8px; border: 1px solid rgba(255, 215, 0, 0.3); margin-top: 10px;">';
                firstClearHtml += '<div style="color: #FFD700; font-weight: bold; margin-bottom: 5px;">ğŸ é¦–æ¬¡é€šé—œçå‹µ</div>';
                firstClearHtml += '<ul style="margin: 0; padding-left: 20px; color: #7a8fb8;">';
                if (diffData.firstClear.shards) firstClearHtml += `<li>ç¢ç‰‡ï¼š${diffData.firstClear.shards}</li>`;
                if (diffData.firstClear.gold) firstClearHtml += `<li>é‡‘å¹£ï¼š${diffData.firstClear.gold}</li>`;
                if (diffData.firstClear.equipment) firstClearHtml += `<li>è£å‚™ï¼š${diffData.firstClear.equipment.rarity}å“è³ª Ã—${diffData.firstClear.equipment.count}</li>`;
                firstClearHtml += '</ul></div>';
            }
            
            content.innerHTML = `
                <div style="background: rgba(0, 217, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 217, 255, 0.3); margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span style="color: #7a8fb8;">ç­‰ç´šè¦æ±‚</span>
                        <span style="color: #00d9ff; font-weight: bold;">Lv.${diffData.level}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span style="color: #7a8fb8;">æ¶ˆè€—AP</span>
                        <span style="color: #4EA5FF; font-weight: bold;">${diffData.ap}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span style="color: #7a8fb8;">ä»Šæ—¥å‰©é¤˜</span>
                        <span style="color: ${remaining > 0 ? '#00ff88' : '#ff4444'}; font-weight: bold;">${remaining}/${diffData.dailyLimit}</span>
                    </div>
                </div>
                
                <div style="background: rgba(255, 136, 0, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(255, 136, 0, 0.3); margin-bottom: 10px;">
                    <div style="color: #ff8800; font-weight: bold; margin-bottom: 5px;">âš”ï¸ æ•µäººè³‡è¨Š</div>
                    <div style="color: #7a8fb8;">
                        <div>${diffData.enemy.name}</div>
                        <div style="font-size: 0.85rem; margin-top: 5px;">
                            HP: ${diffData.enemy.hp} | æ”»æ“Š: ${diffData.enemy.atk} | é˜²ç¦¦: ${diffData.enemy.def}
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(0, 255, 136, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 255, 136, 0.3);">
                    <div style="color: #00ff88; font-weight: bold; margin-bottom: 5px;">ğŸ çå‹µé è¦½</div>
                    <ul style="margin: 0; padding-left: 20px; color: #7a8fb8;">
                        ${rewardsHtml}
                    </ul>
                </div>
                
                ${firstClearHtml}
            `;
            
            modal.classList.add('active');
        }
        
        function closeDungeonDetailModal() {
            document.getElementById('dungeon-detail-modal').classList.remove('active');
        }
        
        function startDungeonChallenge() {
            closeDungeonDetailModal();
            challengeDungeon(currentDungeonId, currentDifficulty);
        }
        
        function showDungeonResult(dungeonId, difficulty, rewards, battleTime, record, isFirstClear) {
            const dungeon = DUNGEONS_DATA[dungeonId];
            const diffData = dungeon.difficulties[difficulty];
            
            const modal = document.getElementById('dungeon-result-modal');
            const content = document.getElementById('dungeon-result-content');
            
            let rewardsHtml = '<ul style="margin: 10px 0; padding-left: 20px;">';
            if (rewards.exp > 0) rewardsHtml += `<li>ç¶“é©—å€¼ +${rewards.exp}</li>`;
            if (rewards.gold > 0) rewardsHtml += `<li>é‡‘å¹£ +${rewards.gold}</li>`;
            if (rewards.shards > 0) rewardsHtml += `<li>ç¢ç‰‡ +${rewards.shards}</li>`;
            if (rewards.equipment.length > 0) {
                rewards.equipment.forEach(item => {
                    rewardsHtml += `<li style="color: ${item.color};">${item.name}</li>`;
                });
            }
            if (rewards.materials.enhanceStone > 0) rewardsHtml += `<li>å¼·åŒ–çŸ³ +${rewards.materials.enhanceStone}</li>`;
            if (rewards.materials.reforgeStone > 0) rewardsHtml += `<li>é‡é‘„çŸ³ +${rewards.materials.reforgeStone}</li>`;
            rewardsHtml += '</ul>';
            
            const remaining = diffData.dailyLimit - record.dailyCount;
            
            content.innerHTML = `
                <div style="text-align: center; margin: 15px 0;">
                    <div style="font-size: 1.2rem; color: #00d9ff; margin-bottom: 5px;">${dungeon.name} - ${diffData.name}</div>
                    <div style="color: #7a8fb8;">ç”¨æ™‚ï¼š${battleTime}ç§’</div>
                    ${isFirstClear ? '<div style="color: #FFD700; font-weight: bold; margin-top: 5px;">ğŸ‰ é¦–æ¬¡é€šé—œï¼</div>' : ''}
                </div>
                
                <div style="background: rgba(0, 255, 136, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(0, 255, 136, 0.3); margin: 15px 0;">
                    <div style="color: #00ff88; font-weight: bold; margin-bottom: 5px;">ğŸ ç²å¾—çå‹µ</div>
                    ${rewardsHtml}
                </div>
                
                <div style="background: rgba(78, 165, 255, 0.05); padding: 12px; border-radius: 8px; border: 1px solid rgba(78, 165, 255, 0.3);">
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span style="color: #7a8fb8;">å‰©é¤˜æ¬¡æ•¸</span>
                        <span style="color: ${remaining > 0 ? '#00ff88' : '#ff4444'}; font-weight: bold;">${remaining}/${diffData.dailyLimit}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin: 5px 0;">
                        <span style="color: #7a8fb8;">ç•¶å‰AP</span>
                        <span style="color: #4EA5FF; font-weight: bold;">${gameState.player.ap}/${gameState.player.maxAp}</span>
                    </div>
                </div>
            `;
            
            modal.classList.add('active');
        }
        
        function closeDungeonResultModal() {
            document.getElementById('dungeon-result-modal').classList.remove('active');
            closeDungeonsModal();
        }
        
        function rechallengeDungeon() {
            document.getElementById('dungeon-result-modal').classList.remove('active');
            openDungeonsModal();
        }
        
        // ========== ç„¡ç›¡æ¨¡å¼ç³»çµ± ==========
        
        function openEndlessModal() {
            // æª¢æŸ¥è§£é–ç‹€æ…‹
            checkEndlessModeUnlock();
            
            const modal = document.getElementById('endless-mode-modal');
            const lockedHint = document.getElementById('endless-locked-hint');
            const startBtn = document.getElementById('endless-start-btn');
            const continueBtn = document.getElementById('endless-continue-btn');
            
            // æ›´æ–°çµ±è¨ˆæ•¸æ“š
            document.getElementById('endless-highest-floor').textContent = gameState.endlessMode.highestFloor;
            document.getElementById('endless-average-floor').textContent = gameState.endlessMode.stats.averageFloor;
            document.getElementById('endless-checkpoint').textContent = gameState.endlessMode.checkpoint;
            document.getElementById('endless-buff-count').textContent = gameState.endlessMode.buffs.length;
            document.getElementById('endless-total-runs').textContent = gameState.endlessMode.stats.totalRuns;
            
            // é¡¯ç¤º/éš±è—Buffåˆ—è¡¨
            const buffsDisplay = document.getElementById('endless-buffs-display');
            const buffsList = document.getElementById('endless-buffs-list');
            
            if (gameState.endlessMode.buffs.length > 0) {
                buffsDisplay.style.display = 'block';
                
                // çµ±è¨ˆBuff
                const buffSummary = {};
                gameState.endlessMode.buffs.forEach(b => {
                    if (!buffSummary[b.type]) {
                        buffSummary[b.type] = { name: b.name.split(' ')[1], total: 0, count: 0 };
                    }
                    buffSummary[b.type].total += b.value;
                    buffSummary[b.type].count++;
                });
                
                // ç”ŸæˆBuffåˆ—è¡¨HTML
                let html = '';
                Object.entries(buffSummary).forEach(([type, summary]) => {
                    let displayValue;
                    if (type === 'crit' || type === 'dmgRed' || type === 'lifeSteal' || type === 'critDmg') {
                        displayValue = `+${Math.floor(summary.total)}%`;
                    } else {
                        displayValue = `+${Math.floor(summary.total * 100)}%`;
                    }
                    html += `<div>â€¢ ${summary.name}: ${displayValue} (Ã—${summary.count})</div>`;
                });
                buffsList.innerHTML = html;
            } else {
                buffsDisplay.style.display = 'none';
            }
            
            // æ ¹æ“šè§£é–ç‹€æ…‹é¡¯ç¤º/éš±è—å…ƒç´ 
            if (!gameState.endlessMode.unlocked) {
                lockedHint.style.display = 'block';
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                continueBtn.style.display = 'none';
            } else {
                lockedHint.style.display = 'none';
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                
                // é¡¯ç¤º/éš±è—ç¹¼çºŒæŒ‰éˆ•
                if (gameState.endlessMode.checkpoint > 1 && !gameState.endlessMode.active) {
                    continueBtn.style.display = 'block';
                } else {
                    continueBtn.style.display = 'none';
                }
            }
            
            // æª¢æŸ¥æ¯æ—¥é€²å…¥é™åˆ¶
            const today = new Date().toISOString().split('T')[0];
            const dailyLimitReached = gameState.endlessMode.lastEntryDate === today && gameState.endlessMode.dailyEntered;
            
            if (dailyLimitReached) {
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                startBtn.textContent = 'âš ï¸ ä»Šæ—¥å·²é€²å…¥ (æ˜å¤©å†ä¾†)';
                continueBtn.disabled = true;
                continueBtn.style.opacity = '0.5';
            } else if (gameState.player.ap < 10) {
                // æª¢æŸ¥APæ˜¯å¦è¶³å¤ 
                startBtn.disabled = true;
                startBtn.style.opacity = '0.5';
                startBtn.textContent = 'ğŸš€ é–‹å§‹æŒ‘æˆ° (APä¸è¶³)';
            } else {
                startBtn.textContent = 'ğŸš€ é–‹å§‹æŒ‘æˆ° (10 AP)';
            }
            
            modal.classList.add('active');
        }
        
        // é—œé–‰ç„¡ç›¡æ¨¡å¼ä»‹é¢
        function closeEndlessModal() {
            document.getElementById('endless-mode-modal').classList.remove('active');
        }
        
        // ç„¡ç›¡æ¨¡å¼Buffé¸é …æ± 
        const ENDLESS_BUFFS = [
            { id: 'atk', name: 'âš”ï¸ æ”»æ“Šå¼·åŒ–', type: 'atk', value: 0.10, desc: 'æ”»æ“ŠåŠ› +10%' },
            { id: 'def', name: 'ğŸ›¡ï¸ é˜²ç¦¦å¼·åŒ–', type: 'def', value: 0.10, desc: 'é˜²ç¦¦åŠ› +10%' },
            { id: 'crit', name: 'ğŸ¯ æš´æ“Šå¼·åŒ–', type: 'crit', value: 5, desc: 'æš´æ“Šç‡ +5%' },
            { id: 'hp', name: 'ğŸ’– ç”Ÿå‘½å¼·åŒ–', type: 'maxHp', value: 0.15, desc: 'æœ€å¤§ç”Ÿå‘½ +15%' },
            { id: 'critDmg', name: 'ğŸ’¥ æš´æ“Šå‚·å®³', type: 'critDmg', value: 20, desc: 'æš´æ“Šå‚·å®³ +20%' },
            { id: 'dmgRed', name: 'ğŸ›¡ï¸ æ¸›å‚·å¼·åŒ–', type: 'dmgRed', value: 5, desc: 'æ¸›å‚· +5%' },
            { id: 'lifeSteal', name: 'ğŸ©¸ å¸è¡€å¼·åŒ–', type: 'lifeSteal', value: 3, desc: 'å¸è¡€ +3%' }
        ];
        
        // æª¢æŸ¥æ˜¯å¦è§£é–ç„¡ç›¡æ¨¡å¼
        function checkEndlessModeUnlock() {
            if (!gameState.endlessMode.unlocked && gameState.player.level >= 30) {
                gameState.endlessMode.unlocked = true;
                addLog('ç³»çµ±', 'ğŸ—¼ æ­å–œï¼ä½ å·²è§£é–ã€ç„¡ç›¡æŒ‘æˆ°å¡”ã€‘ï¼åœ¨å‰¯æœ¬é é¢é–‹å§‹æŒ‘æˆ°ã€‚');
                saveGame();
            }
        }
        
        // é–‹å§‹ç„¡ç›¡æ¨¡å¼
        function startEndlessMode(fromCheckpoint = false) {
            if (!gameState.endlessMode.unlocked) {
                addLog('ç³»çµ±', 'ç„¡ç›¡æ¨¡å¼éœ€è¦é”åˆ° Lv.30 æ‰èƒ½è§£é–ï¼');
                return;
            }
            
            // æª¢æŸ¥æ¯æ—¥é€²å…¥é™åˆ¶
            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
            if (gameState.endlessMode.lastEntryDate === today && gameState.endlessMode.dailyEntered) {
                addLog('ç³»çµ±', 'âš ï¸ ç„¡ç›¡æ¨¡å¼æ¯å¤©åªèƒ½é€²å…¥ä¸€æ¬¡ï¼æ˜å¤©å†ä¾†å§ï¼');
                return;
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰è¶³å¤ çš„é«”åŠ›
            if (gameState.player.ap < 10) {
                addLog('ç³»çµ±', 'é–‹å§‹ç„¡ç›¡æ¨¡å¼éœ€è¦ 10 APï¼');
                return;
            }
            
            gameState.player.ap -= 10;
            gameState.endlessMode.active = true;
            
            // è¨˜éŒ„ä»Šæ—¥å·²é€²å…¥
            gameState.endlessMode.lastEntryDate = today;
            gameState.endlessMode.dailyEntered = true;
            
            if (fromCheckpoint && gameState.endlessMode.checkpoint > 1) {
                gameState.endlessMode.currentFloor = gameState.endlessMode.checkpoint;
                addLog('ç„¡ç›¡æ¨¡å¼', `å¾æª¢æŸ¥é»ç¬¬ ${gameState.endlessMode.checkpoint} å±¤ç¹¼çºŒæŒ‘æˆ°ï¼`);
            } else {
                gameState.endlessMode.currentFloor = 1;
                gameState.endlessMode.buffs = [];
                gameState.endlessMode.stats.totalRuns++;
                addLog('ç„¡ç›¡æ¨¡å¼', 'é–‹å§‹ç„¡ç›¡æŒ‘æˆ°ï¼ç¥ä½ å¥½é‹ï¼');
            }
            
            updateUI();
            saveGame();
            
            // é–‹å§‹ç¬¬ä¸€å±¤æˆ°é¬¥
            startEndlessFloor();
        }
        
        // é–‹å§‹ç•¶å‰å±¤æˆ°é¬¥
        function startEndlessFloor() {
            if (!gameState.endlessMode.active) return;
            
            // é—œé–‰ç„¡ç›¡æ¨¡å¼è¦–çª—ï¼Œè®“ç©å®¶çœ‹åˆ°æˆ°é¬¥æ—¥èªŒ
            closeEndlessModal();
            
            const floor = gameState.endlessMode.currentFloor;
            const isBoss = floor % 10 === 0;
            
            // ç”Ÿæˆæ•µäºº
            const enemy = generateEndlessEnemy(floor, isBoss);
            
            // é¡¯ç¤ºå±¤æ•¸ä¿¡æ¯
            const bossHint = (floor % 10 === 9) ? ' (ä¸‹ä¸€å±¤Boss!)' : '';
            const nextMilestone = Math.ceil(floor / 50) * 50;
            const milestoneHint = (floor % 50 === 49) ? ` (ç¬¬${nextMilestone}å±¤æœ‰ç‰¹æ®Šçå‹µ!)` : '';
            
            addLog('ç„¡ç›¡æ¨¡å¼', `â”â”â” ç¬¬ ${floor} å±¤${bossHint}${milestoneHint} â”â”â”`);
            
            if (isBoss) {
                addLog('ç„¡ç›¡æ¨¡å¼', `âš ï¸ Bossæˆ°ï¼${enemy.name} å‡ºç¾äº†ï¼`);
            }
            
            // é–‹å§‹æˆ°é¬¥
            endlessBattle(enemy);
        }
        
        // ç”Ÿæˆç„¡ç›¡æ¨¡å¼æ•µäºº
        function generateEndlessEnemy(floor, isBoss) {
            // åŸºç¤æ•µäººæ¨¡æ¿
            const baseEnemy = isBoss ? 
                { name: `ç¬¬${floor}å±¤å®ˆè­·è€…`, hp: 200, atk: 30, def: 20 } :
                { name: `ç¬¬${floor}å±¤æŒ‘æˆ°è€…`, hp: 100, atk: 15, def: 10 };
            
            // å±¬æ€§æˆé•·: æ¯å±¤ +5%
            const growthRate = 1 + (floor - 1) * 0.05;
            const hpGrowth = 1 + (floor - 1) * 0.08; // HPé¡å¤–æˆé•·
            
            let enemy = {
                name: baseEnemy.name,
                hp: Math.floor(baseEnemy.hp * growthRate * hpGrowth),
                maxHp: Math.floor(baseEnemy.hp * growthRate * hpGrowth),
                atk: Math.floor(baseEnemy.atk * growthRate),
                def: Math.floor(baseEnemy.def * growthRate),
                isBoss: isBoss,
                floor: floor
            };
            
            // Bossé¡å¤–åŠ æˆ
            if (isBoss) {
                enemy.hp = Math.floor(enemy.hp * 2.5);
                enemy.maxHp = enemy.hp;
                enemy.atk = Math.floor(enemy.atk * 1.3);
                enemy.def = Math.floor(enemy.def * 1.3);
            }
            
            return enemy;
        }
        
        // ç„¡ç›¡æ¨¡å¼æˆ°é¬¥
        function endlessBattle(enemy) {
            // æ‡‰ç”¨ç„¡ç›¡æ¨¡å¼Buffåˆ°ç©å®¶
            const buffedPlayer = applyEndlessBuffs();
            
            // æˆ°é¬¥å¾ªç’°
            let battleLog = [];
            let round = 0;
            const maxRounds = 100;
            
            while (buffedPlayer.hp > 0 && enemy.hp > 0 && round < maxRounds) {
                round++;
                
                // ç©å®¶æ”»æ“Š
                const playerDmg = calculateDamage(buffedPlayer.atk, enemy.def, buffedPlayer.armorPen || 0);
                enemy.hp -= playerDmg;
                battleLog.push(`[å›åˆ${round}] ä½ é€ æˆ ${playerDmg} å‚·å®³`);
                
                if (enemy.hp <= 0) break;
                
                // æ•µäººåæ“Š
                const enemyDmg = calculateDamage(enemy.atk, buffedPlayer.def, 0);
                const actualDmg = Math.floor(enemyDmg * (1 - (buffedPlayer.dmgRed || 0) / 100));
                buffedPlayer.hp -= actualDmg;
                battleLog.push(`[å›åˆ${round}] æ•µäººé€ æˆ ${actualDmg} å‚·å®³`);
            }
            
            // åŒæ­¥ç©å®¶HP
            gameState.player.hp = buffedPlayer.hp;
            
            // é¡¯ç¤ºæˆ°é¬¥æ—¥èªŒ(ç°¡åŒ–ç‰ˆ)
            if (battleLog.length <= 6) {
                battleLog.forEach(log => addLog('æˆ°é¬¥', log));
            } else {
                addLog('æˆ°é¬¥', battleLog[0]);
                addLog('æˆ°é¬¥', `... æ¿€æˆ° ${round} å›åˆ ...`);
                addLog('æˆ°é¬¥', battleLog[battleLog.length - 1]);
            }
            
            // åˆ¤å®šçµæœ
            if (buffedPlayer.hp > 0) {
                endlessVictory(enemy);
            } else {
                endlessDefeat();
            }
        }
        
        // æ‡‰ç”¨ç„¡ç›¡æ¨¡å¼Buff
        function applyEndlessBuffs() {
            const player = { ...gameState.player };
            
            gameState.endlessMode.buffs.forEach(buff => {
                switch(buff.type) {
                    case 'atk':
                        player.atk = Math.floor(player.atk * (1 + buff.value));
                        break;
                    case 'def':
                        player.def = Math.floor(player.def * (1 + buff.value));
                        break;
                    case 'maxHp':
                        const hpRatio = player.hp / player.maxHp;
                        player.maxHp = Math.floor(player.maxHp * (1 + buff.value));
                        player.hp = Math.floor(player.maxHp * hpRatio);
                        break;
                    case 'crit':
                        player.crit += buff.value;
                        break;
                    case 'critDmg':
                        player.critDmg += buff.value;
                        break;
                    case 'dmgRed':
                        player.dmgRed += buff.value;
                        break;
                    case 'lifeSteal':
                        player.lifeSteal += buff.value;
                        break;
                }
            });
            
            return player;
        }
        
        // ç„¡ç›¡æ¨¡å¼å‹åˆ©
        function endlessVictory(enemy) {
            const floor = gameState.endlessMode.currentFloor;
            
            // è¨ˆç®—çå‹µï¼ˆå¤§å¹…é™ä½ä»¥å¹³è¡¡éŠæˆ²ï¼‰
            const goldReward = Math.floor(20 * floor * (1 + floor * 0.01));
            const expReward = Math.floor(30 * floor * (1 + floor * 0.01));
            
            gameState.player.gold += goldReward;
            gameState.player.exp += expReward;
            gameState.endlessMode.stats.totalKills++;
            gameState.endlessMode.stats.totalGold += goldReward;
            gameState.endlessMode.stats.totalFloors++;
            
            addLog('ç„¡ç›¡æ¨¡å¼', `âœ¨ é€šé—œç¬¬ ${floor} å±¤ï¼ç²å¾— ${goldReward} é‡‘å¹£ã€${expReward} ç¶“é©—`);
            
            // Bossçå‹µ: è£å‚™
            if (enemy.isBoss) {
                const rarity = getEndlessEquipmentRarity(floor);
                const equipment = generateItem('normal', rarity);
                if (equipment && addToInventory(equipment)) {
                    addLog('ç„¡ç›¡æ¨¡å¼', `ğŸ Bossçå‹µï¼š${equipment.name}`);
                }
                
                // è¨­ç½®æª¢æŸ¥é»
                gameState.endlessMode.checkpoint = floor;
                addLog('ç„¡ç›¡æ¨¡å¼', `ğŸ“ æª¢æŸ¥é»å·²è¨­ç½®åœ¨ç¬¬ ${floor} å±¤`);
            }
            
            // 50å±¤é‡Œç¨‹ç¢‘çå‹µ
            if (floor % 50 === 0) {
                showEndlessMilestoneReward(floor);
                return; // ç­‰å¾…é¸æ“‡çå‹µå¾Œå†ç¹¼çºŒ
            }
            
            // 20å±¤Buffé¸æ“‡
            if (floor % 20 === 0) {
                showEndlessBuffChoice(floor);
                return; // ç­‰å¾…é¸æ“‡Buffå¾Œå†ç¹¼çºŒ
            }
            
            // æ›´æ–°æœ€é«˜è¨˜éŒ„
            if (floor > gameState.endlessMode.highestFloor) {
                gameState.endlessMode.highestFloor = floor;
                addLog('ç„¡ç›¡æ¨¡å¼', `ğŸ† æ–°è¨˜éŒ„ï¼æœ€é«˜å±¤æ•¸ï¼š${floor}`);
            }
            
            // æ›´æ–°ä»»å‹™é€²åº¦ï¼šç„¡ç›¡æ¨¡å¼å±¤æ•¸ï¼ˆåªè¨˜éŒ„æœ€é«˜å±¤ï¼‰
            updateQuestProgress('endless_floors', gameState.endlessMode.highestFloor, true);
            
            // æª¢æŸ¥å‡ç´š
            if (gameState.player.exp >= gameState.player.expToNext) {
                levelUp();
            }
            
            // ç¹¼çºŒä¸‹ä¸€å±¤
            gameState.endlessMode.currentFloor++;
            updateUI();
            saveGame();
            
            // æ¯10é—œè©¢å•1æ¬¡æ˜¯å¦ç¹¼çºŒï¼ˆé™¤éæ˜¯BUFFæˆ–é‡Œç¨‹ç¢‘é—œå¡ï¼Œé‚£äº›å·²ç¶“æœ‰è‡ªå·±çš„è™•ç†æµç¨‹ï¼‰
            const nextFloor = gameState.endlessMode.currentFloor;
            if (nextFloor % 10 === 0) {
                setTimeout(() => {
                    if (confirm(`ç¹¼çºŒæŒ‘æˆ°ç¬¬ ${nextFloor} å±¤ï¼Ÿ`)) {
                        startEndlessFloor();
                    } else {
                        endEndlessMode(false);
                    }
                }, 500);
            } else {
                // é10çš„å€æ•¸ï¼Œè‡ªå‹•ç¹¼çºŒ
                setTimeout(() => {
                    startEndlessFloor();
                }, 500);
            }
        }
        
        // ç„¡ç›¡æ¨¡å¼å¤±æ•—
        function endlessDefeat() {
            const floor = gameState.endlessMode.currentFloor;
            
            addLog('å¤±æ•—', `ğŸ’€ åœ¨ç¬¬ ${floor} å±¤æˆ°æ•—äº†...`);
            
            // æ›´æ–°çµ±è¨ˆ
            if (floor > gameState.endlessMode.highestFloor) {
                gameState.endlessMode.highestFloor = floor;
                addLog('è¨˜éŒ„', `ğŸ† æ–°è¨˜éŒ„ï¼æœ€é«˜å±¤æ•¸ï¼š${floor}`);
            }
            
            // è¨ˆç®—å¹³å‡å±¤æ•¸
            const stats = gameState.endlessMode.stats;
            stats.averageFloor = Math.floor(stats.totalFloors / stats.totalRuns);
            
            // å¾©æ´»ç©å®¶
            gameState.player.hp = gameState.player.maxHp;
            
            updateUI();
            saveGame();
            
            // è©¢å•æ˜¯å¦å¾æª¢æŸ¥é»ç¹¼çºŒ
            setTimeout(() => {
                const choice = confirm(
                    `å¾æª¢æŸ¥é»(ç¬¬${gameState.endlessMode.checkpoint}å±¤)ç¹¼çºŒï¼Ÿ\n` +
                    `ç¢ºå®š: å¾æª¢æŸ¥é»ç¹¼çºŒ(ä¿ç•™Buff)\n` +
                    `å–æ¶ˆ: çµæŸæŒ‘æˆ°`
                );
                
                if (choice) {
                    startEndlessMode(true);
                } else {
                    endEndlessMode(true);
                }
            }, 500);
        }
        
        // çµæŸç„¡ç›¡æ¨¡å¼
        function endEndlessMode(defeated) {
            gameState.endlessMode.active = false;
            
            if (!defeated) {
                addLog('ç„¡ç›¡æ¨¡å¼', 'ä½ é¸æ“‡äº†é€€å‡ºæŒ‘æˆ°ã€‚');
            }
            
            addLog('çµ±è¨ˆ', `æœ¬æ¬¡æŒ‘æˆ°: ç¬¬ ${gameState.endlessMode.currentFloor} å±¤`);
            addLog('çµ±è¨ˆ', `æ­·å²æœ€é«˜: ç¬¬ ${gameState.endlessMode.highestFloor} å±¤`);
            
            updateUI();
            saveGame();
        }
        
        // ç²å–è£å‚™å“è³ª(æ ¹æ“šå±¤æ•¸)
        function getEndlessEquipmentRarity(floor) {
            if (floor >= 61) {
                // 61+å±¤: ç´«è‰²-æ©™è‰²
                return Math.random() < 0.3 ? 'Epic' : 'Rare';
            } else if (floor >= 31) {
                // 31-60å±¤: è—è‰²-ç´«è‰²
                return Math.random() < 0.2 ? 'Rare' : 'Uncommon';
            } else {
                // 1-30å±¤: ç¶ è‰²-è—è‰²
                return Math.random() < 0.3 ? 'Uncommon' : 'Common';
            }
        }
        
        // é¡¯ç¤º50å±¤é‡Œç¨‹ç¢‘çå‹µé¸æ“‡
        function showEndlessMilestoneReward(floor) {
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.95); z-index: 99999;
                display: flex; align-items: center; justify-content: center;
                pointer-events: auto;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: linear-gradient(135deg, #1a2332 0%, #2d3e50 100%);
                border: 2px solid #ffd700;
                border-radius: 15px;
                padding: 30px;
                max-width: 500px;
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
                position: relative;
                z-index: 100000;
                pointer-events: auto;
            `;
            
            dialog.innerHTML = `
                <h2 style="color: #ffd700; text-align: center; margin-bottom: 20px;">
                    ğŸ‰ ç¬¬ ${floor} å±¤é‡Œç¨‹ç¢‘çå‹µï¼
                </h2>
                <p style="color: #7a8fb8; text-align: center; margin-bottom: 30px;">
                    é¸æ“‡ä¸€é …çå‹µï¼š
                </p>
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button id="reward-epic" style="
                        padding: 15px 20px;
                        background: linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%);
                        border: 2px solid #ce93d8;
                        border-radius: 10px;
                        color: white;
                        cursor: pointer;
                        font-size: 1rem;
                        pointer-events: auto;
                        position: relative;
                        z-index: 100001;
                        transition: all 0.3s;
                    ">
                        ğŸ’œ å²è©©è£å‚™ Ã—1
                    </button>
                    <button id="reward-shards" style="
                        padding: 15px 20px;
                        background: linear-gradient(135deg, #9c27b0 0%, #ba68c8 100%);
                        border: 2px solid #ce93d8;
                        border-radius: 10px;
                        color: white;
                        cursor: pointer;
                        font-size: 1rem;
                        pointer-events: auto;
                        position: relative;
                        z-index: 100001;
                        transition: all 0.3s;
                    ">
                        ğŸ’ ç¢ç‰‡ Ã—200
                    </button>
                    <button id="reward-gold" style="
                        padding: 15px 20px;
                        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
                        border: 2px solid #fff;
                        border-radius: 10px;
                        color: #0a192f;
                        cursor: pointer;
                        font-size: 1rem;
                        font-weight: bold;
                        pointer-events: auto;
                        position: relative;
                        z-index: 100001;
                        transition: all 0.3s;
                    ">
                        ğŸ’° é‡‘å¹£ Ã—20000
                    </button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // ç¶å®šé¸æ“‡äº‹ä»¶ï¼ˆä½¿ç”¨setTimeoutç¢ºä¿DOMå®Œå…¨æ¸²æŸ“ï¼‰
            setTimeout(() => {
                const btnEpic = document.getElementById('reward-epic');
                const btnShards = document.getElementById('reward-shards');
                const btnGold = document.getElementById('reward-gold');
                
                if (btnEpic) {
                    btnEpic.onclick = (e) => {
                        e.stopPropagation();
                        btnEpic.disabled = true;
                        btnEpic.style.opacity = '0.5';
                        const epic = generateItem('normal', 'Epic');
                        if (epic && addToInventory(epic)) {
                            addLog('ç„¡ç›¡æ¨¡å¼', `ğŸ’œ ç²å¾—å²è©©è£å‚™ï¼š${epic.name}ï¼`);
                        }
                        setTimeout(() => {
                            if (document.body.contains(overlay)) {
                                document.body.removeChild(overlay);
                            }
                            continueEndlessAfterReward();
                        }, 100);
                    };
                    btnEpic.onmouseenter = () => {
                        if (!btnEpic.disabled) {
                            btnEpic.style.transform = 'scale(1.05)';
                            btnEpic.style.boxShadow = '0 0 20px rgba(156, 39, 176, 0.8)';
                        }
                    };
                    btnEpic.onmouseleave = () => {
                        btnEpic.style.transform = 'scale(1)';
                        btnEpic.style.boxShadow = 'none';
                    };
                }
                
                if (btnShards) {
                    btnShards.onclick = (e) => {
                        e.stopPropagation();
                        btnShards.disabled = true;
                        btnShards.style.opacity = '0.5';
                        gameState.player.shards += 200;
                        addLog('ç„¡ç›¡æ¨¡å¼', 'ğŸ’ ç²å¾— 200 ç¢ç‰‡ï¼');
                        setTimeout(() => {
                            if (document.body.contains(overlay)) {
                                document.body.removeChild(overlay);
                            }
                            continueEndlessAfterReward();
                        }, 100);
                    };
                    btnShards.onmouseenter = () => {
                        if (!btnShards.disabled) {
                            btnShards.style.transform = 'scale(1.05)';
                            btnShards.style.boxShadow = '0 0 20px rgba(156, 39, 176, 0.8)';
                        }
                    };
                    btnShards.onmouseleave = () => {
                        btnShards.style.transform = 'scale(1)';
                        btnShards.style.boxShadow = 'none';
                    };
                }
                
                if (btnGold) {
                    btnGold.onclick = (e) => {
                        e.stopPropagation();
                        btnGold.disabled = true;
                        btnGold.style.opacity = '0.5';
                        gameState.player.gold += 20000;
                        addLog('ç„¡ç›¡æ¨¡å¼', 'ğŸ’° ç²å¾— 20000 é‡‘å¹£ï¼');
                        setTimeout(() => {
                            if (document.body.contains(overlay)) {
                                document.body.removeChild(overlay);
                            }
                            continueEndlessAfterReward();
                        }, 100);
                    };
                    btnGold.onmouseenter = () => {
                        if (!btnGold.disabled) {
                            btnGold.style.transform = 'scale(1.05)';
                            btnGold.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.8)';
                        }
                    };
                    btnGold.onmouseleave = () => {
                        btnGold.style.transform = 'scale(1)';
                        btnGold.style.boxShadow = 'none';
                    };
                }
            }, 100);
        }
        
        // é‡Œç¨‹ç¢‘çå‹µå¾Œç¹¼çºŒ
        function continueEndlessAfterReward() {
            const floor = gameState.endlessMode.currentFloor;
            
            // æ›´æ–°æœ€é«˜è¨˜éŒ„
            if (floor > gameState.endlessMode.highestFloor) {
                gameState.endlessMode.highestFloor = floor;
            }
            
            // ç¹¼çºŒä¸‹ä¸€å±¤
            gameState.endlessMode.currentFloor++;
            updateUI();
            saveGame();
            
            // æ¯10é—œè©¢å•1æ¬¡æ˜¯å¦ç¹¼çºŒ
            const nextFloor = gameState.endlessMode.currentFloor;
            if (nextFloor % 10 === 0) {
                setTimeout(() => {
                    if (confirm(`ç¹¼çºŒæŒ‘æˆ°ç¬¬ ${nextFloor} å±¤ï¼Ÿ`)) {
                        startEndlessFloor();
                    } else {
                        endEndlessMode(false);
                    }
                }, 500);
            } else {
                // é10çš„å€æ•¸ï¼Œè‡ªå‹•ç¹¼çºŒ
                setTimeout(() => {
                    startEndlessFloor();
                }, 500);
            }
        }
        
        // é¡¯ç¤ºBuffé¸æ“‡ä»‹é¢
        function showEndlessBuffChoice(floor) {
            // éš¨æ©Ÿé¸3å€‹Buff
            const shuffled = [...ENDLESS_BUFFS].sort(() => Math.random() - 0.5);
            const choices = shuffled.slice(0, 3);
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.95); z-index: 99999;
                display: flex; align-items: center; justify-content: center;
                pointer-events: auto;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: linear-gradient(135deg, #1a2332 0%, #2d3e50 100%);
                border: 2px solid #00d9ff;
                border-radius: 15px;
                padding: 30px;
                max-width: 600px;
                box-shadow: 0 0 30px rgba(0, 217, 255, 0.5);
                position: relative;
                z-index: 100000;
                pointer-events: auto;
            `;
            
            dialog.innerHTML = `
                <h2 style="color: #00d9ff; text-align: center; margin-bottom: 20px;">
                    ğŸ ç¬¬ ${floor} å±¤çå‹µ - é¸æ“‡æ°¸ä¹…Buff
                </h2>
                <p style="color: #7a8fb8; text-align: center; margin-bottom: 30px;">
                    é¸æ“‡ä¸€å€‹Buff,æ•ˆæœæ°¸ä¹…ç”Ÿæ•ˆä¸¦å¯ç–ŠåŠ ï¼
                </p>
                <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    ${choices.map((buff, idx) => `
                        <button id="buff-choice-${idx}" style="
                            padding: 20px;
                            background: linear-gradient(135deg, rgba(0,217,255,0.2) 0%, rgba(0,168,204,0.2) 100%);
                            border: 2px solid rgba(0,217,255,0.5);
                            border-radius: 10px;
                            color: white;
                            cursor: pointer;
                            font-size: 1rem;
                            text-align: center;
                            min-width: 150px;
                            pointer-events: auto;
                            position: relative;
                            z-index: 100001;
                            transition: all 0.3s;
                        ">
                            <div style="font-size: 2rem; margin-bottom: 10px;">${buff.name.split(' ')[0]}</div>
                            <div style="font-weight: bold; margin-bottom: 5px;">${buff.name.split(' ')[1]}</div>
                            <div style="color: #00d9ff; font-size: 1.2rem;">${buff.desc}</div>
                        </button>
                    `).join('')}
                </div>
                <p style="color: #888; text-align: center; margin-top: 20px; font-size: 0.9rem;">
                    ğŸ’¡ æç¤º: Buffå¯ä»¥ç–ŠåŠ ,å¤šæ¬¡é¸æ“‡åŒé¡å‹Buffæ•ˆæœæœƒç´¯åŠ 
                </p>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // ç¶å®šé¸æ“‡äº‹ä»¶ï¼ˆä½¿ç”¨setTimeoutç¢ºä¿DOMå®Œå…¨æ¸²æŸ“ï¼‰
            setTimeout(() => {
                choices.forEach((buff, idx) => {
                    const btn = document.getElementById(`buff-choice-${idx}`);
                    if (btn) {
                        btn.onclick = (e) => {
                            e.stopPropagation();
                            // é˜²æ­¢é‡è¤‡é»æ“Š
                            btn.disabled = true;
                            btn.style.opacity = '0.5';
                            btn.style.cursor = 'not-allowed';
                            selectEndlessBuff(buff, floor);
                            setTimeout(() => {
                                if (document.body.contains(overlay)) {
                                    document.body.removeChild(overlay);
                                }
                            }, 100);
                        };
                        // æ·»åŠ hoveræ•ˆæœ
                        btn.onmouseenter = () => {
                            if (!btn.disabled) {
                                btn.style.transform = 'scale(1.05)';
                                btn.style.boxShadow = '0 0 20px rgba(0, 217, 255, 0.8)';
                            }
                        };
                        btn.onmouseleave = () => {
                            btn.style.transform = 'scale(1)';
                            btn.style.boxShadow = 'none';
                        };
                    }
                });
            }, 100);
        }
        
        // é¸æ“‡Buff
        function selectEndlessBuff(buff, floor) {
            const newBuff = {
                id: `${buff.id}_${Date.now()}`,
                name: buff.name,
                type: buff.type,
                value: buff.value,
                floor: floor
            };
            
            gameState.endlessMode.buffs.push(newBuff);
            addLog('ç„¡ç›¡æ¨¡å¼', `âœ¨ ç²å¾—æ°¸ä¹…Buffï¼š${buff.name} (${buff.desc})`);
            
            // é¡¯ç¤ºç•¶å‰æ‰€æœ‰Buff
            const buffSummary = {};
            gameState.endlessMode.buffs.forEach(b => {
                if (!buffSummary[b.type]) {
                    buffSummary[b.type] = { name: b.name.split(' ')[1], total: 0, count: 0 };
                }
                buffSummary[b.type].total += b.value;
                buffSummary[b.type].count++;
            });
            
            addLog('ç„¡ç›¡æ¨¡å¼', 'ç•¶å‰æ°¸ä¹…Buff:');
            Object.values(buffSummary).forEach(summary => {
                const displayValue = summary.total >= 1 ? `+${Math.floor(summary.total)}` : `+${Math.floor(summary.total * 100)}%`;
                addLog('ç„¡ç›¡æ¨¡å¼', `  ${summary.name} ${displayValue} (Ã—${summary.count})`);
            });
            
            // æ›´æ–°æœ€é«˜è¨˜éŒ„
            if (floor > gameState.endlessMode.highestFloor) {
                gameState.endlessMode.highestFloor = floor;
            }
            
            // ç¹¼çºŒä¸‹ä¸€å±¤
            gameState.endlessMode.currentFloor++;
            updateUI();
            saveGame();
            
            // é¸æ“‡BUFFå¾Œï¼Œæ¯10é—œè©¢å•1æ¬¡æ˜¯å¦ç¹¼çºŒ
            const nextFloor = gameState.endlessMode.currentFloor;
            if (nextFloor % 10 === 0) {
                setTimeout(() => {
                    if (confirm(`ç¹¼çºŒæŒ‘æˆ°ç¬¬ ${nextFloor} å±¤ï¼Ÿ`)) {
                        startEndlessFloor();
                    } else {
                        endEndlessMode(false);
                    }
                }, 500);
            } else {
                // é10çš„å€æ•¸ï¼Œè‡ªå‹•ç¹¼çºŒ
                setTimeout(() => {
                    startEndlessFloor();
                }, 500);
            }
        }
function openAutoEquipSettings() {
    try {
        // åˆå§‹åŒ–è¨­å®šï¼ˆå…¼å®¹èˆŠå­˜æª”ï¼‰
        if (!gameState.autoEquipment) {
            gameState.autoEquipment = {
                enabled: false,
                autoSalvage: false,
                salvageQuality: ['common'],
                protectSet: true,
                considerSet: false,
                stats: {
                    autoEquipped: 0,
                    autoSalvaged: 0,
                    materialsGained: 0
                }
            };
        }
        

        // æ›´æ–° UI ç‹€æ…‹
        document.getElementById('auto-equip-toggle').checked = gameState.autoEquipment.enabled;
        document.getElementById('auto-salvage-toggle').checked = gameState.autoEquipment.autoSalvage;
        document.getElementById('protect-set').checked = gameState.autoEquipment.protectSet;
        document.getElementById('consider-set').checked = gameState.autoEquipment.considerSet;
        

        // æ›´æ–°åˆ†è§£å“è³ªé¸æ“‡
        const qualities = gameState.autoEquipment.salvageQuality || ['common'];
        document.getElementById('salvage-common').checked = qualities.includes('common');
        document.getElementById('salvage-fine').checked = qualities.includes('fine');
        document.getElementById('salvage-rare').checked = qualities.includes('rare');
        document.getElementById('salvage-epic').checked = qualities.includes('epic');
        document.getElementById('salvage-legendary').checked = qualities.includes('legendary');
        document.getElementById('salvage-mythic').checked = qualities.includes('mythic');
        document.getElementById('salvage-eternal').checked = qualities.includes('eternal');
        document.getElementById('salvage-set').checked = qualities.includes('set');
        

        // æ›´æ–°çµ±è¨ˆ
        updateAutoEquipStats();
        

        const modal = document.getElementById('auto-equip-modal');
        
        // å¼·åˆ¶è¨­ç½®æ¨£å¼
        modal.style.cssText = `
            display: flex !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.95) !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 10000 !important;
            padding: 20px !important;
        `;
        
        // å¼·åˆ¶è¨­ç½® modal-content æ¨£å¼
        const modalContent = modal.querySelector('.modal-content');
        if (modalContent) {
            modalContent.style.cssText = `
                background: linear-gradient(135deg, rgba(26, 31, 53, 0.98) 0%, rgba(15, 20, 40, 0.98) 100%) !important;
                padding: 25px !important;
                border-radius: 12px !important;
                max-width: 500px !important;
                width: 100% !important;
                max-height: 80vh !important;
                overflow-y: auto !important;
                border: 3px solid #00d9ff !important;
                box-shadow: 0 0 50px rgba(0, 217, 255, 0.6) !important;
                display: block !important;
            `;
        }
        
        modal.classList.add('active');
    } catch (error) {
        console.error('openAutoEquipSettings éŒ¯èª¤:', error);
        alert('éŒ¯èª¤: ' + error.message);
    }
}

// é—œé–‰è¨­å®šé¢æ¿
function closeAutoEquipSettings() {
    document.getElementById('auto-equip-modal').style.display = 'none';
    saveGame();
}

// åˆ‡æ›è‡ªå‹•è£å‚™
function toggleAutoEquip() {
    gameState.autoEquipment.enabled = document.getElementById('auto-equip-toggle').checked;
    addLog('è¨­å®š', gameState.autoEquipment.enabled ? 'âœ… å·²å•Ÿç”¨è‡ªå‹•è£å‚™' : 'âŒ å·²é—œé–‰è‡ªå‹•è£å‚™');
    saveGame();
}

// åˆ‡æ›è‡ªå‹•åˆ†è§£
function toggleAutoSalvage() {
    gameState.autoEquipment.autoSalvage = document.getElementById('auto-salvage-toggle').checked;
    addLog('è¨­å®š', gameState.autoEquipment.autoSalvage ? 'âœ… å·²å•Ÿç”¨è‡ªå‹•åˆ†è§£' : 'âŒ å·²é—œé–‰è‡ªå‹•åˆ†è§£');
    saveGame();
}

// æ›´æ–°åˆ†è§£å“è³ª
function updateSalvageQuality() {
    const qualities = [];
    if (document.getElementById('salvage-common').checked) qualities.push('common');
    if (document.getElementById('salvage-uncommon').checked) qualities.push('uncommon');
    if (document.getElementById('salvage-fine').checked) qualities.push('fine');
    if (document.getElementById('salvage-rare').checked) qualities.push('rare');
    if (document.getElementById('salvage-epic').checked) qualities.push('epic');
    if (document.getElementById('salvage-legendary').checked) qualities.push('legendary');
    if (document.getElementById('salvage-mythic').checked) qualities.push('mythic');
    if (document.getElementById('salvage-eternal').checked) qualities.push('eternal');
    if (document.getElementById('salvage-set').checked) qualities.push('set');
    
    gameState.autoEquipment.salvageQuality = qualities;
    addLog('è¨­å®š', `ğŸ”§ æ›´æ–°åˆ†è§£å“è³ªï¼š${qualities.join(', ')}`);
    saveGame();
}

// åˆ‡æ›ä¿è­·å¥—è£
function toggleProtectSet() {
    gameState.autoEquipment.protectSet = document.getElementById('protect-set').checked;
    addLog('è¨­å®š', gameState.autoEquipment.protectSet ? 'ğŸ›¡ï¸ å·²å•Ÿç”¨å¥—è£ä¿è­·' : 'ğŸ›¡ï¸ å·²é—œé–‰å¥—è£ä¿è­·');
    saveGame();
}

// åˆ‡æ›è€ƒæ…®å¥—è£æ•ˆæœ
function toggleConsiderSet() {
    gameState.autoEquipment.considerSet = document.getElementById('consider-set').checked;
    addLog('è¨­å®š', gameState.autoEquipment.considerSet ? 'â­ è©•åˆ†æ™‚å°‡è€ƒæ…®å¥—è£æ•ˆæœ' : 'â­ è©•åˆ†æ™‚ä¸è€ƒæ…®å¥—è£æ•ˆæœ');
    saveGame();
}

// æ›´æ–°çµ±è¨ˆé¡¯ç¤º
function updateAutoEquipStats() {
    if (!gameState.autoEquipment || !gameState.autoEquipment.stats) return;
    
    document.getElementById('auto-equip-count').textContent = gameState.autoEquipment.stats.autoEquipped || 0;
    document.getElementById('auto-salvage-count').textContent = gameState.autoEquipment.stats.autoSalvaged || 0;
    document.getElementById('materials-gained').textContent = gameState.autoEquipment.stats.materialsGained || 0;
}

// æ‰‹å‹•æ‰¹é‡åˆ†è§£ï¼ˆèˆŠç‰ˆï¼Œä¿ç•™ä»¥é˜²ç›¸å®¹æ€§å•é¡Œï¼‰
function manualSalvageAll(quality) {
    if (!confirm(`ç¢ºå®šè¦åˆ†è§£æ‰€æœ‰${quality === 'common' ? 'æ™®é€š' : 'ç²¾è‰¯'}å“è³ªçš„è£å‚™å—ï¼Ÿ`)) return;
    
    const rarityMap = {
        'common': 'Common',
        'fine': 'Fine',
        'rare': 'Rare'
    };
    
    const targetRarity = rarityMap[quality];
    let salvaged = 0;
    let totalMaterials = 0;
    
    gameState.inventory = gameState.inventory.filter(item => {
        if (!item || item.type === 'consumable') return true;
        if (item.rarity !== targetRarity) return true;
        if (shouldProtectEquipment(item)) return true;
        
        const materials = salvageEquipment(item);
        totalMaterials += materials;
        salvaged++;
        return false;
    });
    
    if (salvaged > 0) {
        if (!gameState.materials) {
            gameState.materials = { enhanceStone: 0 };
        }
        gameState.materials.enhanceStone = (gameState.materials.enhanceStone || 0) + totalMaterials;
        
        gameState.autoEquipment.stats.autoSalvaged += salvaged;
        gameState.autoEquipment.stats.materialsGained += totalMaterials;
        
        addLog('æ‰¹é‡åˆ†è§£', `ğŸ”§ åˆ†è§£äº† ${salvaged} ä»¶${quality === 'common' ? 'æ™®é€š' : 'ç²¾è‰¯'}è£å‚™ï¼Œç²å¾— ${totalMaterials} å€‹å¼·åŒ–çŸ³`);
        playSound('item');
        
        updateAutoEquipStats();
        updateUI();
        saveGame();
    } else {
        addLog('æ‰¹é‡åˆ†è§£', 'æ²’æœ‰å¯åˆ†è§£çš„è£å‚™');
    }
        
}

// ä¸€éµåˆ†è§£ï¼ˆæ ¹æ“šå‹¾é¸å“éšï¼‰
function manualSalvageSelected() {
    // ç²å–å‹¾é¸çš„å“è³ª
    const selectedQualities = [];
    if (document.getElementById('salvage-common')?.checked) selectedQualities.push('common');
    if (document.getElementById('salvage-fine')?.checked) selectedQualities.push('fine');
    if (document.getElementById('salvage-rare')?.checked) selectedQualities.push('rare');
    if (document.getElementById('salvage-epic')?.checked) selectedQualities.push('epic');
    if (document.getElementById('salvage-legendary')?.checked) selectedQualities.push('legendary');
    if (document.getElementById('salvage-mythic')?.checked) selectedQualities.push('mythic');
    if (document.getElementById('salvage-eternal')?.checked) selectedQualities.push('eternal');
    if (document.getElementById('salvage-set')?.checked) selectedQualities.push('set');
    
    if (selectedQualities.length === 0) {
        addLog('æ‰¹é‡åˆ†è§£', 'è«‹è‡³å°‘å‹¾é¸ä¸€å€‹å“è³ª');
        return;
    }
    
    // å“è³ªåç¨±å°ç…§
    const qualityNames = {
        'common': 'ç ´èˆŠ',
        'fine': 'ç²¾è‰¯',
        'rare': 'ç¨€æœ‰',
        'epic': 'å²è©©',
        'legendary': 'å‚³èªª',
        'mythic': 'ç¥è©±',
        'eternal': 'æ°¸æ†',
        'set': 'å¥—è£'
    };
    
    const qualityList = selectedQualities.map(q => qualityNames[q]).join('ã€');
    
    if (!confirm(`ç¢ºå®šè¦åˆ†è§£æ‰€æœ‰ä»¥ä¸‹å“è³ªçš„è£å‚™å—ï¼Ÿ\n\n${qualityList}\n\nï¼ˆå·²è£å‚™å’Œæ¯å€‹éƒ¨ä½æœ€å¥½çš„è£å‚™æœƒè¢«ä¿ç•™ï¼‰`)) return;
    
    // å“è³ªå°ç…§è¡¨ï¼ˆä¿æŒå°å¯«ï¼Œèˆ‡éŠæˆ²ä¸­çš„ rarity å±¬æ€§ä¸€è‡´ï¼‰
    const rarityMap = {
        'common': 'Common',
        'uncommon': 'Uncommon',
        'fine': 'Fine',
        'rare': 'Rare',
        'epic': 'Epic',
        'legendary': 'Legendary',
        'mythic': 'Mythic',
        'eternal': 'Eternal',
        'set': 'Set'
    };
    
    const targetRarities = selectedQualities.map(q => rarityMap[q].toLowerCase());
    let salvaged = 0;
    let totalMaterials = 0;
    let totalFragments = 0;
    
    gameState.inventory = gameState.inventory.filter(item => {
        if (!item || item.type === 'consumable') return true;
        
        // å¥—è£ç‰¹æ®Šè™•ç†ï¼šæª¢æŸ¥ setName å±¬æ€§
        const isSet = item.setName ? true : false;
        const itemRarity = isSet && selectedQualities.includes('set') ? 'set' : (item.rarity ? item.rarity.toLowerCase() : '');
        
        if (!targetRarities.includes(itemRarity)) return true;
        if (shouldProtectEquipment(item)) return true;
        
        const materials = salvageEquipment(item);
        totalMaterials += materials;
        
        // ç¨€æœ‰ä»¥ä¸Šçš„è£å‚™é¡å¤–ç²å¾—ç¢ç‰‡
        if (['rare', 'epic', 'legendary', 'mythic', 'eternal', 'set'].includes(itemRarity)) {
            const fragmentAmount = {
                'rare': 1,
                'epic': 2,
                'legendary': 5,
                'mythic': 10,
                'eternal': 20,
                'set': 3
            }[itemRarity] || 0;
            totalFragments += fragmentAmount;
        }
        
        salvaged++;
        return false;
    });
    
    if (salvaged > 0) {
        // åˆå§‹åŒ–è³‡æº
        if (!gameState.materials) {
            gameState.materials = { enhanceStone: 0, fragment: 0 };
        }
        if (!gameState.materials.enhanceStone) gameState.materials.enhanceStone = 0;
        if (!gameState.materials.fragment) gameState.materials.fragment = 0;
        
        gameState.materials.enhanceStone += totalMaterials;
        gameState.materials.fragment += totalFragments;
        
        gameState.autoEquipment.stats.autoSalvaged += salvaged;
        gameState.autoEquipment.stats.materialsGained += totalMaterials;
        
        let logMessage = `ğŸ”§ åˆ†è§£äº† ${salvaged} ä»¶è£å‚™ï¼ˆ${qualityList}ï¼‰`;
        if (totalMaterials > 0) logMessage += `\nç²å¾— ${totalMaterials} å€‹å¼·åŒ–çŸ³`;
        if (totalFragments > 0) logMessage += `ã€${totalFragments} å€‹ç¢ç‰‡`;
        
        addLog('æ‰¹é‡åˆ†è§£', logMessage);
        playSound('item');
        
        updateAutoEquipStats();
        updateUI();
        saveGame();
    } else {
        addLog('æ‰¹é‡åˆ†è§£', 'æ²’æœ‰ç¬¦åˆæ¢ä»¶çš„è£å‚™å¯åˆ†è§£');
    }
}
</script>

<style>
/* Toggle Switch æ¨£å¼ */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 24px;
}

.switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #2c3e50;
    transition: .4s;
}

.slider:before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: .4s;
}

input:checked + .slider {
    background-color: #43e97b;
}

input:checked + .slider:before {
    transform: translateX(26px);
}

.slider.round {
    border-radius: 24px;
}

.slider.round:before {
    border-radius: 50%;
}
</style>
